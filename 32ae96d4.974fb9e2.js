(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{137:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return s})),t.d(e,"metadata",(function(){return o})),t.d(e,"toc",(function(){return i})),t.d(e,"default",(function(){return l}));var _=t(3),r=t(7),a=(t(0),t(333)),c=["components"],s={},o={unversionedId:"Apple/\u5e76\u53d1\u7f16\u7a0b/\u5e76\u53d1\u7f16\u7a0b",id:"Apple/\u5e76\u53d1\u7f16\u7a0b/\u5e76\u53d1\u7f16\u7a0b",isDocsHomePage:!1,title:"\u5e76\u53d1\u7f16\u7a0b",description:"\u5c0f\u6280\u5de7\uff1a",source:"@site/docs/Apple/\u5e76\u53d1\u7f16\u7a0b/\u5e76\u53d1\u7f16\u7a0b.md",slug:"/Apple/\u5e76\u53d1\u7f16\u7a0b/\u5e76\u53d1\u7f16\u7a0b",permalink:"/docs/Apple/\u5e76\u53d1\u7f16\u7a0b/\u5e76\u53d1\u7f16\u7a0b",editUrl:"dys-typora-open://mine/survival/docs/Apple/\u5e76\u53d1\u7f16\u7a0b/\u5e76\u53d1\u7f16\u7a0b.md",version:"current",sidebar:"Apple",previous:{title:"iOS\u9006\u5411",permalink:"/docs/Apple/\u9006\u5411/iOS\u9006\u5411"},next:{title:"\u7f51\u7edc\u7f16\u7a0b",permalink:"/docs/Apple/\u7f51\u7edc\u7f16\u7a0b/\u7f51\u7edc\u7f16\u7a0b"}},i=[{value:"pthread",id:"pthread",children:[]},{value:"\u540c\u6b65",id:"\u540c\u6b65",children:[]},{value:"RZPaas\u7684\u95f2\u7f6e\u7ebf\u7a0b",id:"rzpaas\u7684\u95f2\u7f6e\u7ebf\u7a0b",children:[{value:"\u8c03\u7528\u6808",id:"\u8c03\u7528\u6808",children:[]},{value:"\u4e3b\u8981\u7684\u4e24\u4e2a\u51fd\u6570\u5206\u6790",id:"\u4e3b\u8981\u7684\u4e24\u4e2a\u51fd\u6570\u5206\u6790",children:[]},{value:"RAPaasSDK",id:"rapaassdk",children:[]},{value:"libcxx",id:"libcxx",children:[]},{value:"libpthread",id:"libpthread",children:[]}]}],d={toc:i};function l(n){var e=n.components,t=Object(r.a)(n,c);return Object(a.b)("wrapper",Object(_.a)({},d,t,{components:e,mdxType:"MDXLayout"}),Object(a.b)("p",null,"\u5c0f\u6280\u5de7\uff1a"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"\u5bf9\u4e8e\u591a\u7ebf\u7a0b\u7a0b\u5e8f\uff0c\u6253\u4e2a\u65ad\u70b9\uff0c\u7136\u540e\u67e5\u770b\u7ebf\u7a0b\u5806\u6808\u6765\u5b66\u4e60\u3002")),Object(a.b)("h2",{id:"pthread"},"pthread"),Object(a.b)("p",null,Object(a.b)("a",{parentName:"p",href:"https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html"},"https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html")),Object(a.b)("h2",{id:"\u540c\u6b65"},"\u540c\u6b65"),Object(a.b)("p",null,"\u5e76\u53d1\u7684\u53e6\u4e00\u9762\u662f\u540c\u6b65\u3002\u4e5f\u5c31\u662f\u987a\u5e8f\u6027\uff0c\u6309\u7167\u987a\u5e8f\u4e00\u4e2a\u4e00\u4e2a\u6765\u3002\u4e34\u754c\u533a\u4ee3\u7801\uff08\u8bfb\u5199\u5171\u4eab\u53d8\u91cf\uff09\u7684\u6267\u884c\uff0c\u4e0d\u80fd\u540c\u65f6\u8fdb\u884c\uff0c\u4e1a\u52a1\u7684\u903b\u8f91\uff0c\u6211\u9700\u8981\u6709\u4f9d\u8d56\uff0c\u5fc5\u987b\u4e00\u4e2a\u6709\u7ed3\u679c\u4e4b\u540e\u624d\u80fd\u8fdb\u884c\u4e0b\u4e00\u4e2a\u3002\u7531\u6b64\u884d\u751f\u51fa\u9501\uff0c\u6761\u4ef6\u53d8\u91cf\uff0c\u4fe1\u53f7\u91cf\u3002"),Object(a.b)("p",null,"\u4fe1\u53f7\u91cf\u662f\u7b80\u5316\u7248\u7684\u6761\u4ef6\u53d8\u91cf\u3002"),Object(a.b)("p",null,"\u6761\u4ef6\u53d8\u91cf\u7684\u6761\u4ef6\u9700\u8981\u81ea\u5df1\u5904\u7406\uff0c\u4fe1\u53f7\u91cf\u7b80\u5316\u4e3a\uff0c\u6574\u5f62\u53d8\u91cf\u548c0\u7684\u6bd4\u8f83\u3002"),Object(a.b)("p",null,"\u975e\u7b80\u5355\u7684\u6570\u503c\u548c0\u6bd4\u8f83\uff0c\u800c\u662f\u9700\u8981\u5404\u79cd\u903b\u8f91\u64cd\u4f5c\u7684\u590d\u6742\u573a\u666f\uff0c\u9700\u8981\u4f7f\u7528\u6761\u4ef6\u53d8\u91cf\u3002"),Object(a.b)("h2",{id:"rzpaas\u7684\u95f2\u7f6e\u7ebf\u7a0b"},"RZPaas\u7684\u95f2\u7f6e\u7ebf\u7a0b"),Object(a.b)("p",null,"\u4e00\u4e2a\u7ebf\u7a0b\u6c60\u7684\u95f2\u7f6e\u7ebf\u7a0b"),Object(a.b)("h3",{id:"\u8c03\u7528\u6808"},"\u8c03\u7528\u6808"),Object(a.b)("p",null,"\u7ebf\u7a0b\u6c60\u7684\u95f2\u7f6e\u7ebf\u7a0b\u7684\u8c03\u7528\u6808"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"0   libsystem_kernel.dylib              0x0000000195f6ebc0 __psynch_cvwait + 8\n1   libsystem_pthread.dylib             0x0000000195e911e4 _pthread_cond_wait + 680\n2   libc++.1.dylib                      0x0000000195fc2d44 std::__1::condition_variable::__do_timed_wait+ 52548 (std::__1::unique_lock<std::__1::mutex>&, std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1l, 1000000000l> > >) + 100\n3   RZPaas_iOS                          0x0000000102e7ae48 rz::Thread::ThreadFun() + 142920 (ThreadPool.cpp:28)\n4   RZPaas_iOS                          0x0000000102e7b464 void* std::__1::__thread_proxy<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void (rz::Thread::*)(), rz::Thread*> >(void*) + 144484 (thread:299)\n5   libsystem_pthread.dylib             0x0000000195e8d8fc _pthread_start + 168\n\n")),Object(a.b)("h3",{id:"\u4e3b\u8981\u7684\u4e24\u4e2a\u51fd\u6570\u5206\u6790"},"\u4e3b\u8981\u7684\u4e24\u4e2a\u51fd\u6570\u5206\u6790"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"\u7ebf\u7a0b\u5165\u53e3\u51fd\u6570")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"void* std::__1::__thread_proxy< F >(void*)\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"__thread_proxy")," \u4ee3\u7406\u4e86",Object(a.b)("inlineCode",{parentName:"p"},"rz::Thread::ThreadFun()")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"\u7b49\u5f85\u6761\u4ef6\u53d8\u91cf")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"std::__1::condition_variable::__do_timed_wait(E, D)\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"A = std::__1::ratio<1l, 1000000000l>\nB = std::__1::chrono::duration<long long, A >\nC = std::__1::chrono::system_clock\nD = std::__1::chrono::time_point<C, B >\nE = std::__1::unique_lock<std::__1::mutex>&\nstd::__1::condition_variable::__do_timed_wait(E, D)\n\nA = rz::Thread*\nB = void (rz::Thread::*)()\nC = std::__1::default_delete<std::__1::__thread_struct>\nD = std::__1::__thread_struct\nE = std::__1::unique_ptr<D, C >\nF = std::__1::tuple<E, B, A>\nvoid* std::__1::__thread_proxy< F >(void*)\n\n")),Object(a.b)("h3",{id:"rapaassdk"},"RAPaasSDK"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'//\u542f\u52a8\u7ebf\u7a0b\u6c60\nvoid ThreadPool::Start() {\n    if (running) return;\n    running = true;\n    for (int i = 0; i < RZPaaSConfig::dataFlowThreadNum; i++) {\n      std::shared_ptr<Thread> thread = std::make_shared<Thread>();\n      threadPool.push_back(thread);\n    }\n  }\n\n//\u7ebf\u7a0b\u6784\u9020\u51fd\u6570\nThread::Thread() {\n  running = true;\n  workThread = std::thread(&Thread::ThreadFun, this);\n}\n\n//\u7ebf\u7a0b\u8fd0\u884c\u51fd\u6570\nvoid Thread::ThreadFun() {\n  ProcessTask* task;\n  while (running) {\n    task = ThreadPool::getTask();\n    if (task != nullptr) {\n      auto _olog = RZLOG_GUARD(task->processName, "threadPool run task overTime: ", 200);\n      task->taskFun();\n      delete task;\n      task = nullptr;\n    } else {\n      working = false;\n      std::unique_lock<std::mutex> lk(threadMX);\n      conditionVariable.wait_for(lk, std::chrono::milliseconds(10));\n      working = true;\n    }\n  }\n}\n\n')),Object(a.b)("h3",{id:"libcxx"},"libcxx"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'template <class _Fp, class ..._Args,\n          class\n         >\nthread::thread(_Fp&& __f, _Args&&... __args)\n{\n    typedef unique_ptr<__thread_struct> _TSPtr;\n    _TSPtr __tsp(new __thread_struct);\n    typedef tuple<_TSPtr, typename decay<_Fp>::type, typename decay<_Args>::type...> _Gp;\n    unique_ptr<_Gp> __p(\n            new _Gp(_VSTD::move(__tsp),\n                    _VSTD::__decay_copy(_VSTD::forward<_Fp>(__f)),\n                    _VSTD::__decay_copy(_VSTD::forward<_Args>(__args))...));\n    int __ec = _VSTD::__libcpp_thread_create(&__t_, &__thread_proxy<_Gp>, __p.get());\n    if (__ec == 0)\n        __p.release();\n    else\n        __throw_system_error(__ec, "thread constructor failed");\n}\n\n\ntemplate <class _Rep, class _Period>\ncv_status\ncondition_variable::wait_for(unique_lock<mutex>& __lk,\n                             const chrono::duration<_Rep, _Period>& __d)\n{\n    using namespace chrono;\n    if (__d <= __d.zero())\n        return cv_status::timeout;\n    using __ns_rep = nanoseconds::rep;\n    steady_clock::time_point __c_now = steady_clock::now();\n\n#if defined(_LIBCPP_HAS_COND_CLOCKWAIT)\n    using __clock_tp_ns = time_point<steady_clock, nanoseconds>;\n    __ns_rep __now_count_ns = _VSTD::__safe_nanosecond_cast(__c_now.time_since_epoch()).count();\n#else\n    using __clock_tp_ns = time_point<system_clock, nanoseconds>;\n    __ns_rep __now_count_ns = _VSTD::__safe_nanosecond_cast(system_clock::now().time_since_epoch()).count();\n#endif\n\n    __ns_rep __d_ns_count = _VSTD::__safe_nanosecond_cast(__d).count();\n\n    if (__now_count_ns > numeric_limits<__ns_rep>::max() - __d_ns_count) {\n        __do_timed_wait(__lk, __clock_tp_ns::max());\n    } else {\n        __do_timed_wait(__lk, __clock_tp_ns(nanoseconds(__now_count_ns + __d_ns_count)));\n    }\n\n    return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :\n                                                 cv_status::timeout;\n}\n\n\n\nvoid\ncondition_variable::__do_timed_wait(unique_lock<mutex>& lk,\n     chrono::time_point<chrono::system_clock, chrono::nanoseconds> tp) noexcept\n{\n    using namespace chrono;\n    if (!lk.owns_lock())\n        __throw_system_error(EPERM,\n                            "condition_variable::timed wait: mutex not locked");\n    nanoseconds d = tp.time_since_epoch();\n    if (d > nanoseconds(0x59682F000000E941))\n        d = nanoseconds(0x59682F000000E941);\n    __libcpp_timespec_t ts;\n    seconds s = duration_cast<seconds>(d);\n    typedef decltype(ts.tv_sec) ts_sec;\n    _LIBCPP_CONSTEXPR ts_sec ts_sec_max = numeric_limits<ts_sec>::max();\n    if (s.count() < ts_sec_max)\n    {\n        ts.tv_sec = static_cast<ts_sec>(s.count());\n        ts.tv_nsec = static_cast<decltype(ts.tv_nsec)>((d - s).count());\n    }\n    else\n    {\n        ts.tv_sec = ts_sec_max;\n        ts.tv_nsec = giga::num - 1;\n    }\n    int ec = __libcpp_condvar_timedwait(&__cv_, lk.mutex()->native_handle(), &ts);\n    if (ec != 0 && ec != ETIMEDOUT)\n        __throw_system_error(ec, "condition_variable timed_wait failed");\n}\n\nint __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,\n                               __libcpp_timespec_t *__ts)\n{\n  return pthread_cond_timedwait(__cv, __m, __ts);\n}\n\n')),Object(a.b)("h3",{id:"libpthread"},"libpthread"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"int\npthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,\n        const struct timespec *abstime)\n{\n    return _pthread_cond_wait(cond, mutex, abstime, 0, _pthread_conformance());\n}\n\n\n\n/*\n * Suspend waiting for a condition variable.\n * If conformance is not cancelable, we skip the pthread_testcancel(),\n * but keep the remaining conforming behavior.\n */\nPTHREAD_NOEXPORT OS_NOINLINE\nint\n_pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex,\n            const struct timespec *abstime, int isRelative,\n            pthread_conformance_t conforming)\n{\n    int res;\n    struct timespec then = { 0, 0 };\n    bool timeout_elapsed = false;\n\n    if (!_pthread_mutex_check_signature(mutex) &&\n            !_pthread_mutex_check_signature_init(mutex)) {\n        return EINVAL;\n    }\n\n    bool ulock = _pthread_mutex_uses_ulock(mutex);\n    uint32_t sig = ulock ? _PTHREAD_COND_SIG_ulock : _PTHREAD_COND_SIG_psynch;\n    res = _pthread_cond_check_init(cond, &sig);\n    if (res != 0) {\n        return res;\n    }\n\n    if (conforming == PTHREAD_CONFORM_UNIX03_CANCELABLE) {\n        pthread_testcancel();\n    }\n\n    /* send relative time to kernel */\n    if (abstime) {\n        if (abstime->tv_nsec < 0 || abstime->tv_nsec >= NSEC_PER_SEC) {\n            // TODO: PTHREAD_STRICT candidate\n            return EINVAL;\n        }\n\n        if (isRelative == 0) {\n            struct timespec now;\n            struct timeval tv;\n            __gettimeofday(&tv, NULL);\n            TIMEVAL_TO_TIMESPEC(&tv, &now);\n\n            if ((abstime->tv_sec == now.tv_sec) ?\n                (abstime->tv_nsec <= now.tv_nsec) :\n                (abstime->tv_sec < now.tv_sec)) {\n                timeout_elapsed = true;\n            } else {\n                /* Compute relative time to sleep */\n                then.tv_nsec = abstime->tv_nsec - now.tv_nsec;\n                then.tv_sec = abstime->tv_sec - now.tv_sec;\n                if (then.tv_nsec < 0) {\n                    then.tv_nsec += NSEC_PER_SEC;\n                    then.tv_sec--;\n                }\n            }\n        } else {\n            then.tv_sec = abstime->tv_sec;\n            then.tv_nsec = abstime->tv_nsec;\n            if ((then.tv_sec == 0) && (then.tv_nsec == 0)) {\n                timeout_elapsed = true;\n            }\n        }\n    }\n\n    if (!ulock && cond->busy != NULL && cond->busy != mutex) {\n        // TODO: PTHREAD_STRICT candidate\n        return EINVAL;\n    }\n\n    /*\n     * If timeout is known to have elapsed, we still need to unlock and\n     * relock the mutex to allow other waiters to get in line and\n     * modify the condition state.\n     */\n    if (timeout_elapsed) {\n        res = pthread_mutex_unlock(mutex);\n        if (res != 0) {\n            return res;\n        }\n        res = pthread_mutex_lock(mutex);\n        if (res != 0) {\n            return res;\n        }\n\n        return ETIMEDOUT;\n    }\n\n    if (ulock) {\n        return _pthread_ulock_cond_wait(cond, mutex, &then, conforming);\n    } else {\n        return _pthread_psynch_cond_wait(cond, mutex, &then, conforming);\n    }\n}\n\n\n\nstatic int\n_pthread_psynch_cond_wait(pthread_cond_t *cond,\n            pthread_mutex_t *mutex,\n            const struct timespec *then,\n            pthread_conformance_t conforming)\n{\n    uint32_t mtxgen, mtxugen, flags=0, updateval;\n    uint32_t lcntval, ucntval, scntval;\n    uint32_t nlval, ulval, savebits;\n    volatile uint64_t *c_lsseqaddr;\n    volatile uint32_t *c_lseqcnt, *c_useqcnt, *c_sseqcnt;\n    uint64_t oldval64, newval64, mugen, cvlsgen;\n    uint32_t *npmtx = NULL;\n\n    COND_GETSEQ_ADDR(cond, &c_lsseqaddr, &c_lseqcnt, &c_useqcnt, &c_sseqcnt);\n\n    do {\n        lcntval = *c_lseqcnt;\n        ucntval = *c_useqcnt;\n        scntval = *c_sseqcnt;\n\n        oldval64 = (((uint64_t)scntval) << 32);\n        oldval64 |= lcntval;\n\n        /* remove c and p bits on S word */\n        savebits = scntval & PTH_RWS_CV_BITSALL;\n        ulval = (scntval & PTHRW_COUNT_MASK);\n        nlval = lcntval + PTHRW_INC;\n        newval64 = (((uint64_t)ulval) << 32);\n        newval64 |= nlval;\n    } while (!os_atomic_cmpxchg(c_lsseqaddr, oldval64, newval64, seq_cst));\n\n    cond->busy = mutex;\n\n    int res = _pthread_mutex_droplock(mutex, &flags, &npmtx, &mtxgen, &mtxugen);\n\n    /* TBD: cases are for normal (non owner for recursive mutex; error checking)*/\n    if (res != 0) {\n        return EINVAL;\n    }\n    if ((flags & _PTHREAD_MTX_OPT_NOTIFY) == 0) {\n        npmtx = NULL;\n        mugen = 0;\n    } else {\n        mugen = ((uint64_t)mtxugen << 32) | mtxgen;\n    }\n    flags &= ~_PTHREAD_MTX_OPT_MUTEX;   /* reset the mutex bit as this is cvar */\n\n    cvlsgen = ((uint64_t)(ulval | savebits)<< 32) | nlval;\n\n    // SUSv3 requires pthread_cond_wait to be a cancellation point\n    if (conforming == PTHREAD_CONFORM_UNIX03_CANCELABLE) {\n        pthread_cleanup_push(_pthread_psynch_cond_cleanup, (void *)cond);\n        updateval = __psynch_cvwait(cond, cvlsgen, ucntval, (pthread_mutex_t *)npmtx, mugen, flags, (int64_t)(then->tv_sec), (int32_t)(then->tv_nsec));\n        pthread_testcancel();\n        pthread_cleanup_pop(0);\n    } else {\n        updateval = __psynch_cvwait(cond, cvlsgen, ucntval, (pthread_mutex_t *)npmtx, mugen, flags, (int64_t)(then->tv_sec), (int32_t)(then->tv_nsec));\n    }\n\n    if (updateval == (uint32_t)-1) {\n        int err = errno;\n        switch (err & 0xff) {\n        case ETIMEDOUT:\n            res = ETIMEDOUT;\n            break;\n        case EINTR:\n            // spurious wakeup (unless canceled)\n            res = 0;\n            break;\n        default:\n            res = EINVAL;\n            break;\n        }\n\n        // add unlock ref to show one less waiter\n        _pthread_cond_updateval(cond, mutex, err, 0);\n    } else if (updateval != 0) {\n        // Successful wait\n        // The return due to prepost and might have bit states\n        // update S and return for prepo if needed\n        _pthread_cond_updateval(cond, mutex, 0, updateval);\n    }\n\n    pthread_mutex_lock(mutex);\n\n    return res;\n}\n\n")))}l.isMDXComponent=!0},333:function(n,e,t){"use strict";t.d(e,"a",(function(){return l})),t.d(e,"b",(function(){return m}));var _=t(0),r=t.n(_);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function c(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var _=Object.getOwnPropertySymbols(n);e&&(_=_.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,_)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?c(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,_,r=function(n,e){if(null==n)return{};var t,_,r={},a=Object.keys(n);for(_=0;_<a.length;_++)t=a[_],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(_=0;_<a.length;_++)t=a[_],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var i=r.a.createContext({}),d=function(n){var e=r.a.useContext(i),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},l=function(n){var e=d(n.components);return r.a.createElement(i.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return r.a.createElement(r.a.Fragment,{},e)}},p=r.a.forwardRef((function(n,e){var t=n.components,_=n.mdxType,a=n.originalType,c=n.parentName,i=o(n,["components","mdxType","originalType","parentName"]),l=d(t),p=_,m=l["".concat(c,".").concat(p)]||l[p]||u[p]||a;return t?r.a.createElement(m,s(s({ref:e},i),{},{components:t})):r.a.createElement(m,s({ref:e},i))}));function m(n,e){var t=arguments,_=e&&e.mdxType;if("string"==typeof n||_){var a=t.length,c=new Array(a);c[0]=p;var s={};for(var o in e)hasOwnProperty.call(e,o)&&(s[o]=e[o]);s.originalType=n,s.mdxType="string"==typeof n?n:_,c[1]=s;for(var i=2;i<a;i++)c[i]=t[i];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);