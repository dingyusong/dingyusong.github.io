<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Blog Atom Feed"><title data-react-helmet="true">Objective-C-面向对象 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Objective-C-面向对象 | My Site"><meta data-react-helmet="true" name="description" content="title: Objective-C"><meta data-react-helmet="true" property="og:description" content="title: Objective-C"><meta data-react-helmet="true" property="og:url" content="http://localhost:9999//docs/编程语言/Objective-C/Objective-C-面向对象"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="http://localhost:9999//docs/编程语言/Objective-C/Objective-C-面向对象"><link rel="stylesheet" href="/styles.8cfbcdec.css">
<link rel="preload" href="/styles.4ec932fe.js" as="script">
<link rel="preload" href="/runtime~main.3425bbd6.js" as="script">
<link rel="preload" href="/main.4d172be4.js" as="script">
<link rel="preload" href="/1.978a979f.js" as="script">
<link rel="preload" href="/284.9b127a42.js" as="script">
<link rel="preload" href="/285.87bc8610.js" as="script">
<link rel="preload" href="/935f2afb.0ad17a86.js" as="script">
<link rel="preload" href="/283.46b48473.js" as="script">
<link rel="preload" href="/49fbe45c.d3c64a77.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a><a class="navbar__item navbar__link" href="/docs/">基础</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/编程语言/编程语言">语言</a><a class="navbar__item navbar__link" href="/docs/工具/常用工具">工具</a><a class="navbar__item navbar__link" href="/docs/应用开发/应用开发">应用开发</a><a class="navbar__item navbar__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a><a class="navbar__item navbar__link" href="/docs/音视频/音视频">音视频</a><a class="navbar__item navbar__link" href="/docs/项目/项目">项目</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Search" aria-label="Search" class="navbar__search-input search-bar"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">基础</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/编程语言/编程语言">语言</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/工具/常用工具">工具</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/应用开发/应用开发">应用开发</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/音视频/音视频">音视频</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/项目/项目">项目</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">Objective-C-面向对象</h1></header><div class="markdown"><p>title: Objective-C
toc: true
categories: [iOS]
tags: [Objective-C]
date: 2018-07-02 16:13:52</p><hr><p>[toc]</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="对象"></a>对象<a class="hash-link" href="#对象" title="Direct link to heading">#</a></h1><p>OC对象的内存结构</p><p><img alt="20191203157536116977435.png" src="/assets/images/20191203157536116977435-5eff5bdb0dde6c897f450bb1eec3f697.png"></p><ul><li><p>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</p></li><li><p>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</p><ol><li>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</li><li>成员变量的列表,</li><li>属性列表,</li></ol><p>它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p></li></ul><p>翻译过来就是</p><table><thead><tr><th>Objective-C 对象的结构图</th></tr></thead><tbody><tr><td>ISA指针</td></tr><tr><td>根类的实例变量</td></tr><tr><td>倒数第二层父类的实例变量</td></tr><tr><td>...</td></tr><tr><td>父类的实例变量</td></tr><tr><td>类的实例变量</td></tr></tbody></table><ul><li>根对象就是NSObject，它的superclass指针指向nil</li><li>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</li></ul><p><img alt="20191203157536139160749.jpg" src="/assets/images/20191203157536139160749-c508b057ef914606458c8dbca9e5b174.jpg"></p><p>[从 NSObject 的初始化了解 isa]([https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md](<a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E" target="_blank" rel="noopener noreferrer">https://github.com/draveness/analyze/blob/master/contents/objc/从</a> NSObject 的初始化了解 isa.md))</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="属性"></a>属性<a class="hash-link" href="#属性" title="Direct link to heading">#</a></h2><p>属性和成员变量的区别</p><p>OC的属性-Property</p><p>属性(property)用于封装对象中的数据。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="基本概念"></a>基本概念<a class="hash-link" href="#基本概念" title="Direct link to heading">#</a></h3><p>在声明一个属性（property）的时候尽量使用<code>Foundation</code>框架的数据类型，如整形使用<code>NSInteger</code>或<code>NSUInteger</code>表示，时间间隔的浮点类型使用<code>NSTimeInterval</code>表示，这样代码数据类型更统一。</p><p><code>@synthesize</code>表示为这两个属性自动生成名为<code>_name</code>和<code>_age</code>的底层实例变量，并自动生成相关的<code>getter</code>和<code>setter</code>也可以不写编译器默认会自动生成<code>&#x27;_属性名&#x27;</code>的实例变量以及相关的<code>getter</code>和<code>setter</code>。</p><p><a href="https://blog.csdn.net/shuai265/article/details/75024275" target="_blank" rel="noopener noreferrer">@synthesize 的作用</a></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@dynamic的意思是动态绑定一个属性的实现，直白的说，就是告诉编译器这个属性不用你去做任何操作，完全由程序员自己来完成实现，包括getter，setter方法。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@synthesize的意思是编译器自动生成相应代码，除非程序员自己已经实现了。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">这两者的应用环境：</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">一般情况下，我们通常会用@synthesize来完成相关的属性操作，这样我们不写get和set方法完全没问题，因为编译时编译器默认已经生成了一套get和set方法。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@dynamic最常用的地方是类别里添加属性操作。都知道，在category里面不能添加属性。当我们有这个需求时，我们必须通过运行时runtime来完成，这时编译器不会自动给我们生成get和set方法，我们就需要自己来完成实现。这时我们就需要告诉编译器这个方法我自己去实现，这个时候需要给编译器一个标记@dynamic。然后我们再通过runtime的objc_setAssociatedObject/objc_getAssociatedObject来完成属性的get和set实现。OK！</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods,复写存取方法）或者使用 @dynamic 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。</p><p>//synthesize合成的意思，如果不写是autosynthesize，自动合成。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">dynamic  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 英  [daɪˈnæmɪk]   美  [daɪˈnæmɪk]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">adj. 动态的；动力的；动力学的；有活力的</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">n. 动态；动力</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">synthesize  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 英  [ˈsɪnθəsaɪz]   美  [ˈsɪnθəsaɪz]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">vt. 合成；综合</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">vi. 合成；综合</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 属性有如下几个特性：</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 1.使用了属性(property)的话，会自动生成对应的名为属性名加下划线的实例变量(ivar)，私有属性也一样。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如属性：property1自动给生成_property1的成员变量，私有属性property6自动给生成_property6的成员变量</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 2.使用了@synthesize 但是没有指定成员变量名，则会生成一个同名的成员变量;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如：@synthesize property2;自动为属性property2生成了一个同名的ivar，property2。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 3.如果使用@synthesize指定了一个成员变量名，无论是否和系统的默认一样加下划线，如果这个成员变量存在则不再生成，如果不存在则自动生成一个指定名称的成员变量。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如：@synthesize property3 = _property3;和系统生成名规则一样，且_property3存在则不再生成。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> @synthesize property4 = property4Exc;和系统生成名规则不一样，且property4Exc存在则不再生成。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> @synthesize property5 = property5Exc;和系统生成名规则不一样，且property5Exc不存在则自动生成一个property5Exc。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 4.成员变量不必和属性一一匹配。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如：ivar7 和 ivar8，就只是纯粹的成员变量，没有对应的属性。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 5.当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如：property7 就没有自动生成对应的_property7 的实例变量。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 6.重写了只读属性的 getter 时,系统就不会生成 ivar（实例变量/成员变量）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如：property8 是只读属性，且重写了-(NSString *)property8 方法， 就没有自动生成对应的_property8 的实例变量。想想也没有必要。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 7.使用了 @dynamic 时,系统就不会生成 ivar（实例变量/成员变量）和set，get方法。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如：property9</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 8.在 @protocol 中定义的所有属性需要手动@synthesize 手动合成</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如：ViewControllerProtol中定义的，如果遵循ViewControllerProtol，则必须手动合成property10，否则会报警告，手动合成后不仅会生成相应的变量，还会生成相应的存取方法。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 21:24:58.219481+0800 PropertyStudy[13133:663785] ivar 7:property10</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 21:24:58.220286+0800 PropertyStudy[13133:663785] method 4:property10</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 21:24:58.220517+0800 PropertyStudy[13133:663785] method 5:setProperty10:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 21:24:58.206794+0800 PropertyStudy[13133:663785] propertyName 14:property10</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 9.在 category 中定义的所有属性，需要@dynamic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如：ViewController (DYSDefaultCategory)中定义的property11，必须使用@dynamic property11; 手动实现其set和get方法。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 10.重载的属性。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。否则默认使用父类定义的ivar。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 例如：子类DYSDisableDog的legnumber属性需要重载父类DYSDog的legnumber，因为是特殊情况，所以需要手动合成ivar来重载父类属性。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#import &quot;ASGGestureBlocker.h&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#import &quot;CVGGestureVerityView.h&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@interface ASGGestureBlocker ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//    UIView *_blockerView;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@implementation ASGGestureBlocker</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@synthesize blockerView = _blockerView;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 打印结果如下：</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.386887+0800 PropertyStudy[11778:592871] propertyName 1:property6</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387066+0800 PropertyStudy[11778:592871] propertyName 2:property1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387172+0800 PropertyStudy[11778:592871] propertyName 3:property2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387277+0800 PropertyStudy[11778:592871] propertyName 4:property3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387370+0800 PropertyStudy[11778:592871] propertyName 5:property4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387471+0800 PropertyStudy[11778:592871] propertyName 6:property5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387471+0800 PropertyStudy[11778:592871] propertyName 6:property7</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387585+0800 PropertyStudy[11778:592871] ivar 1:ivar7</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387683+0800 PropertyStudy[11778:592871] ivar 2:_property3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387786+0800 PropertyStudy[11778:592871] ivar 3:property4Exc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.387915+0800 PropertyStudy[11778:592871] ivar 4:ivar8</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.388011+0800 PropertyStudy[11778:592871] ivar 5:property2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.388110+0800 PropertyStudy[11778:592871] ivar 6:property5Exc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.388337+0800 PropertyStudy[11778:592871] ivar 7:_property1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     2018-11-03 20:18:11.388572+0800 PropertyStudy[11778:592871] ivar 8:_property6</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Demo：</p><p><a href="https://github.com/DingYusong/PropertyStudy" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/PropertyStudy</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="属性修饰符"></a>属性修饰符<a class="hash-link" href="#属性修饰符" title="Direct link to heading">#</a></h3><p>开发中，使用@property声明一个属性的时候，要给属性添加一些修饰符 例如：retain、copy、weak、strong、assign、nonatomic、atomic 这些修饰符如何使用，对于不明白的开发人员来说，是一大难题。有时候就是因为使用错了修饰符而导致程序莫名其妙的就崩溃了。</p><p>atomic：生成的setter、getter操作为原子操作，为系统默认，执行性能低。</p><p>nonatomic：生成的setter、getter操作是非原子操作，推荐手动设置为nonatomic属性，执行性能高。</p><p>assign：用来修饰值类型，这里的值类型我们可以理解为基础数据类型（NSInteger）和C语言类型数据（int,float,double,char,bool）。不会更改引用计数。</p><p>retain：释放旧对象，并使传入的新对象引用计数+1。只能用于NSObject及其子类。</p><p>strong：强引用，会将对象的指针指向新的地址，并持有一个新对象，这个新对象的引用计数+1。</p><p>weak：</p><p>1.弱引用，只是引用属性的指针，而不持有属性，属性的引用计数不会+1。</p><p>2.和assign类似，但是不同的是，当指向的对象被释放后，weak会被自动置空，而assign不会置空，所以会导致野指针出现，所以，在声明delegate的时候使用weak，当使用assign修饰的时候，需要手动给delegate置空。</p><p>思考：</p><p>基本数据类型没有指针，没有引用计数这一说，改变就改变了，随着其宿主对象消失而消失。所以assign不置为nil也是可以的。</p><p>copy：</p><p>1.只能修饰遵守NSCoping协议的类</p><p>2.作用是在内存上开辟出一片新的空间，然后将调用者复制进去，这样对于调用者而言，引用计数是不变的.</p><p>3.对于一些不可变类型，如：NSString、NSArray、NSDictionary、NSSet之类，copy并不会在内存上开辟新的空间，而是为调用者的引用计数+1，这里等同于retain.</p><p>值得注意的是copy也属于强引用，但是在使用中和strong还是又很大的区别，在修饰不可变类型数据的时候要使用copy。这样就可以避免将可变数据赋值给不可变数据是出现问题。</p><p>考虑一下这段代码会发生什么事，如果没有修饰为Copy时：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSMutableString *mString = [[NSMutableString alloc] initWithString:@&quot;string&quot;];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    self.value = mString;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>这里创建一个可变的字符串对象，并赋值给了一个声明为不可变的字符串对象。这样导致本来指向不可变字符串对象的value指向了一个可变字符串对象。
但如果用了Copy修饰，那么在赋值前，可变的字符串对象先Copy为不可变字符串对象，再赋值到value上，这样就可以避免一些不可避免错误发生。</p><p>所以对这些不可变类的声明需要用Copy而不是Strong</p><p>3.总结
copy，strong，weak，assign的区别。</p><p>可变变量中，copy是重新开辟一个内存，strong，weak，assgin后三者不开辟内存，只是指针指向原来保存值的内存的位置，storng指向后会对该内存引用计数+1，而weak，assgin不会。weak，assgin会在引用保存值的内存引用计数为0的时候值为空，并且weak会将内存值设为nil，assign不会，assign在内存没有被重写前依旧可以输出，但一旦被重写将出现奔溃</p><p>不可变变量中，因为值本身不可被改变，copy没必要开辟出一块内存存放和原来内存一模一样的值，所以内存管理系统默认都是浅拷贝。其他和可变变量一样，如weak修饰的变量同样会在内存引用计数为0时变为nil。</p><p>容器本身遵守上面准则，但容器内部的每个值都是浅拷贝。</p><p><strong>综上所述，当创建property构造器创建变量value1的时候，使用copy，strong，weak，assign根据具体使用情况来决定。value1 = value2，如果你希望value1和value2的修改不会互相影响的就用用copy，反之用strong,weak,assign。如果你还希望原来值C(C是什么见示意图1)为nil的时候，你的变量不为nil就用strong,反之用weak和assign。weak和assign保证了不强引用某一块内存，如delegate我们就用weak表示，就是为了防止循环引用的产生。
另外，我们上面讨论的是类变量，直接创建局部变量默认是Strong修饰
</strong></p><p>补充：delegate为什么要用weak或者assign而不用strong</p><p>a创建对象b,b中有C类对象c，所以a对b有一个引用,b对c有一个引用，a.b引用计数分别为1，1。当c.delegate = b的时候，实则是对b有了一个引用，如果此时c的delegate用strong修饰则会对b的值内存引用计数+1，b引用计数为2。当a的生命周期结束，随之释放对b的引用，b的引用计数变为1，导致b不能释放，b不能释放又导致b对c的引用不能释放，c引用计数还是为1，这样就造成了b和c一直留在了内存中。</p><p>而要解决这个问题就是使用weak或者assign修饰delegate，这样虽然会有c仍然会对b有一个引用，但是引用是弱引用，当a生命周期结束的时候，b的引用计数变为0，b释放后随之c的引用消失，c引用计数变为0，释放。</p><p>NSString的特殊性：</p><p><a href="https://www.jianshu.com/p/f26e1fb64f7f" target="_blank" rel="noopener noreferrer">NSString在不同的初始化方式导致的神奇现象</a></p><p>使用<code>unsafe_unretained</code>修饰时效果与<code>assign</code>相同，不会增加引用计数，当所赋的值被销毁时不会被置为<code>nil</code>可能会发生野指针错误。<code>unsafe_unretained</code>与<code>assign</code>的区别在于，<code>unsafe_unretained</code>只能修饰对象，不能修饰标量类型，而<code>assign</code>两者均可修饰。</p><p>参考文档</p><ul><li><p><a href="https://blog.csdn.net/m0_37681833/article/details/60872342" target="_blank" rel="noopener noreferrer">OC--属性修饰符</a></p></li><li><p><a href="https://www.jianshu.com/p/a29a0bdd5da8" target="_blank" rel="noopener noreferrer">iOS中copy,strong,retain,weak和assign的区别</a></p></li><li><p><a href="https://www.jianshu.com/p/646ae400fe7b" target="_blank" rel="noopener noreferrer">iOS @property探究(一): 基础详解</a></p></li></ul><hr><p>参考文档</p><ul><li><a href="https://www.jianshu.com/p/646ae400fe7b" target="_blank" rel="noopener noreferrer">iOS @property探究(一): 基础详解</a></li><li><a href="https://www.jianshu.com/p/44d12884e24e" target="_blank" rel="noopener noreferrer">iOS @property探究(二): 深入理解</a></li><li><a href="https://www.cnblogs.com/kuaixian/p/5411963.html" target="_blank" rel="noopener noreferrer">property synthesize dynamic 的不同和区别</a></li><li><a href="https://segmentfault.com/a/1190000002904657" target="_blank" rel="noopener noreferrer">OC 中，覆盖属性会有怎么样的化学反应？</a></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="属性-1"></a>属性<a class="hash-link" href="#属性-1" title="Direct link to heading">#</a></h3><p><strong>@property 的本质是什么？</strong></p><blockquote><p>@property = ivar + getter + setter;//@property可以看做是一个语法糖（实例变量+存取方法的简写）</p></blockquote><p>下面解释下：</p><blockquote><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p></blockquote><p>自动合成（默认）
完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。</p><p>手动合成
@synthesize 语法来指定实例变量的名字.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objectivec codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">@synthesize</span><span class="token plain"> firstName </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> _myFirstName</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">@synthesize</span><span class="token plain"> lastName </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> _myLastName</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>@synthesize 和 @dynamic （协议和类别）属性
<a href="https://github.com/DingYusong/PropertyStudy" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/PropertyStudy</a>
如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;
@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。
@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。</p><p>什么情况下不会autosynthesis（自动合成）？</p><ol><li>同时重写了 setter 和 getter 时</li><li>重写了只读属性的 getter 时</li><li>使用了 @dynamic 时</li><li>在 @protocol 中定义的所有属性</li><li>在 category 中定义的所有属性</li><li>重载的属性</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="属性修饰符-1"></a>属性修饰符<a class="hash-link" href="#属性修饰符-1" title="Direct link to heading">#</a></h3><p>property的默认属性修饰符：</p><ol><li>对应基本数据类型默认关键字是
atomic,readwrite,assign</li><li>对于普通的 Objective-C 对象
atomic,readwrite,strong</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="原子性"></a>原子性<a class="hash-link" href="#原子性" title="Direct link to heading">#</a></h4><p>atomic/nonatomic
指定合成存取方法是否为原子操作，可以理解为是否线程安全，但在iOS上即时使用atomic也不一定是线程安全的，要保证线程安全需要使用锁机。
可以发现<strong>几乎所有代码的属性设置都会使用nonatomic，这样能够提高访问性能，在iOS中使用锁机制的开销较大，会损耗性能</strong>。</p><ul><li>atomic</li></ul><p>生成的setter、getter操作为原子操作，为系统默认，执行性能低。</p><ol><li>读写安全。</li></ol><p>假设有一个 atomic 的属性 &quot;name&quot;，如果线程 A 调<code>[self setName:@&quot;A&quot;]</code>，线程 B 调<code>[self setName:@&quot;B&quot;]</code>，线程 C 调<code>[self name]</code>，那么所有这些不同线程上的操作都将依次顺序执行——也就是说，如果一个线程正在执行 getter/setter，其他线程就得等待。因此，属性 name 是读/写安全的。
链接：<a href="https://www.jianshu.com/p/7288eacbb1a2" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/7288eacbb1a2</a></p><ol start="2"><li>非线程安全。</li></ol><p>如果有另一个线程 D 同时在调<code>[name release]</code>，那可能就会crash，因为 release 不受 getter/setter 操作的限制。也就是说，这个属性只能说是读/写安全的，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。</p><ul><li>nonatomic</li></ul><p>生成的setter、getter操作是非原子操作，推荐手动设置为nonatomic属性，执行性能高。</p><p>非读写安全，也非线程安全。</p><p>如果 name 属性是 nonatomic 的，那么上面例子里的所有线程 A、B、C、D 都可以同时执行，可能导致无法预料的结果。如果是 atomic 的，那么 A、B、C 会串行，而 D 还是并行的。</p><p>作者：戴仓薯
链接：<a href="https://www.jianshu.com/p/7288eacbb1a2" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/7288eacbb1a2</a>
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="读写性"></a>读写性<a class="hash-link" href="#读写性" title="Direct link to heading">#</a></h4><ul><li>readwrite</li></ul><p>是编译器的默认选项，表示自动生成getter和setter，如果需要getter和setter不写即可。</p><ul><li>readonly</li></ul><p>表示只合成getter而不合成setter。</p><p><strong>完全禁止外部对只读属性进行修改</strong></p><p>1、在类内部修改只读属性时，不要通过主动添加setter函数方式
2、重写+(BOOL)accessInstanceVariablesDirectly 函数并返回NO。
这样处理完后，外部就无法修改“只读”属性。</p><p>链接：<a href="https://www.jianshu.com/p/3033b306126a" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/3033b306126a</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="内存管理"></a>内存管理<a class="hash-link" href="#内存管理" title="Direct link to heading">#</a></h4><p><a href="/docs/编程语言/Objective-C/Objective-C/内存管理.md#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%AD%E4%B9%89">属性的内存管理语义</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="方法名"></a>方法名<a class="hash-link" href="#方法名" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">getter=&lt;name&gt; 、setter=&lt;name&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="空设置"></a>空设置<a class="hash-link" href="#空设置" title="Direct link to heading">#</a></h4><p>nonnull,null_resettable,nullable</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="方法"></a>方法<a class="hash-link" href="#方法" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="方法的执行过程"></a>方法的执行过程<a class="hash-link" href="#方法的执行过程" title="Direct link to heading">#</a></h3><p>在 Objective-C 中的“方法调用”其实应该叫做消息传递。 <code>[receiver message]</code> 会被翻译为 <code>objc_msgSend(receiver, @selector(message))</code>。objc_msgSend方法调用的过程如下：</p><ol><li>首先根据receiver对象的isa指针获取它对应的class</li><li>优先在class的cache查找message方法，如果找不到，再到methodLists查找</li><li>如果没有在class找到，再到super_class查找</li><li>一旦找到message这个方法，再依据receiver 中的self 指针找到当前的对象,调用当前对象的具体实现的方法(IMP),然后传递参数,调用实现方法。如果都没有找到，那就会进入“消息转发机制”。</li></ol><p>消息转发机制三部曲：</p><ol><li><p>resolution</p><p>objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p></li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objectivec codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//当某个对象不能接受某个selector时，向对象所属的类动态添加所需的selector：</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">BOOL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain">resolveInstanceMethod</span><span class="token punctuation" style="color:rgb(199, 146, 234)">:</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">SEL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain">sel</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">sel </span><span class="token operator" style="color:rgb(137, 221, 255)">==</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">@selector</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">eat</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><span class="token function" style="color:rgb(130, 170, 255)">class_addMethod</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Person class</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> sel</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">IMP</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain">eat</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&quot;&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//返回Yes将不再调用该方法下面的方法</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> Yes</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token keyword" style="font-style:italic">super</span><span class="token plain"> resolveInstanceMethod</span><span class="token punctuation" style="color:rgb(199, 146, 234)">:</span><span class="token plain">sel</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">eat</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">NSLog</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token string" style="color:rgb(195, 232, 141)">@&quot;eat&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><ol start="2"><li>Fast forwarding</li></ol><p>如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。
这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objectivec codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//当某个对象不能接受某个selector时，将对该selector的调用转发给另一个对象</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token operator" style="color:rgb(137, 221, 255)">-</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">id</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain">forwardingTargetForSelector</span><span class="token punctuation" style="color:rgb(199, 146, 234)">:</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">SEL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain">aSelector</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">aSelector </span><span class="token operator" style="color:rgb(137, 221, 255)">==</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">@selector</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">eat1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//转发给Student实例来处理</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Student alloc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> init</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token keyword" style="font-style:italic">super</span><span class="token plain"> forwardingTargetForSelector</span><span class="token punctuation" style="color:rgb(199, 146, 234)">:</span><span class="token plain">aSelector</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><ol start="3"><li><p>Normal forwarding</p><p>这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p></li></ol><p>objc_msgSend()
向对象发送消息[obj foo]和objc_msgSend()函数
方法编译之后就是objc_msgSend()函数调用</p><p>unrecognized selector的异常。
当调用该对象上某个方法,而该对象上没有实现这个方法的时候会报这个异常。向一个对象发送他不存在的方法会报异常，而向nil发送消息则不存在异常。</p><p>参考： <a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md" target="_blank" rel="noopener noreferrer">从源代码看 ObjC 中消息的发送</a></p><p>demo:<a href="https://github.com/DingYusong/objc_msg_send_demo" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/objc_msg_send_demo</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="oc方法执行过程"></a>OC方法执行过程<a class="hash-link" href="#oc方法执行过程" title="Direct link to heading">#</a></h3><p>在 Objective-C 中的“方法调用”其实应该叫做消息传递 <code>[receiver message]</code> 会被翻译为 <code>objc_msgSend(receiver, @selector(message))</code> 那么方法调用的过程是怎么样的呢？</p><p>首先我们看一下objc_msgSend它具体是如何发送消息:</p><ol><li>首先根据receiver对象的isa指针获取它对应的class</li><li>优先在class的cache查找message方法，如果找不到，再到
methodLists查找</li><li>如果没有在class找到，再到super_class查找</li><li>一旦找到message这个方法，再依据receiver 中的self 指针找到当前的对象,调用当前对象的具体实现的方法(IMP),然后传递参数,调用实现方法。</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="runtime层面"></a>runtime层面<a class="hash-link" href="#runtime层面" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="objective-c层面"></a>Objective-C层面<a class="hash-link" href="#objective-c层面" title="Direct link to heading">#</a></h3><p><code>[receiver message]</code></p><p>三大措施：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">//当某个对象不能接受某个selector时，向对象所属的类动态添加所需的selector：</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (BOOL)resolveInstanceMethod:(SEL)sel{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (sel == @selector(eat)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        class_addMethod([Person class], sel, (IMP)eat, &quot;&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //返回Yes将不再调用该方法下面的方法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return Yes;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return [super resolveInstanceMethod:sel];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void eat(){</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;eat&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">//当某个对象不能接受某个selector时，将对该selector的调用转发给另一个对象</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//当某个对象不能接受某个selector时，将对该selector的调用转发给另一个对象</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)forwardingTargetForSelector:(SEL)aSelector{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (aSelector == @selector(eat1)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//无法处理的selector转 发给另一个对象</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return [[Student alloc] init];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return [super forwardingTargetForSelector:aSelector];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">//当某个对象不能接受某个selector时，自己新建方法签名，再在forwardInvocation中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSString *sel = NSStringFromSelector(selector);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if ([sel rangeOfString:@&quot;set&quot;].location == 0){</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }else{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return [NSMethodSignature signatureWithObjCTypes:&quot;@@:&quot;];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="常用场景"></a>常用场景<a class="hash-link" href="#常用场景" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="替换掉原来的方法"></a>替换掉原来的方法<a class="hash-link" href="#替换掉原来的方法" title="Direct link to heading">#</a></h4><p>比如：JSPatch 的热修复实现</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="总结-1"></a>总结<a class="hash-link" href="#总结-1" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">performSelector</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">NSInvocation</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">[recaiver message]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="课后"></a>课后<a class="hash-link" href="#课后" title="Direct link to heading">#</a></h2><p>打印对象的引用计数</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;retainCount:%td&quot;,CFGetRetainCount((__bridge  CFTypeRef)(self)));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;retainCount:%td&quot;,[[self valueForKey:@&quot;retainCount&quot;] integerValue]);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>参考文档</p><ul><li><p><a href="https://github.com/Draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md" target="_blank" rel="noopener noreferrer"><strong>从源代码看 ObjC 中消息的发送</strong></a></p></li><li><p><a href="https://www.jianshu.com/p/649792014865" target="_blank" rel="noopener noreferrer">OC 消息转发机制</a></p></li><li><p><a href="https://www.jianshu.com/p/434dac7c5f33" target="_blank" rel="noopener noreferrer">OC方法调用流程及消息转发</a></p></li></ul><p>打印对象：复写<code>-(void)descirption</code></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="类别和扩展"></a>类别和扩展<a class="hash-link" href="#类别和扩展" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="类别"></a>类别<a class="hash-link" href="#类别" title="Direct link to heading">#</a></h2><p>✓ 使用类别就是为了能够为现有类添加新的方法，不用继承该现有类，就可使用现有类的对象调用添加的方法了。
✓ 类别可以使类的实现分散在多个文件中.
✓ 类别中不能有变量，类别中没有放变量的位置.
✓ 如果类中的方法和类别中的方法名称相同，这将造成冲突，类别的方法将完全取代类的方法。
✓ 同一个类的不同类别声明了相同的方法，这将导致不稳定，哪个方法会被调用</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="协议"></a>协议<a class="hash-link" href="#协议" title="Direct link to heading">#</a></h1><p>继承</p><p>协议</p><p>​	虚函数</p><p>​	1.函数返回值自己使用，这点相当于继承。当然协议相当于public的函数，返回值其他类也可以使用。</p><p>​	2.反向传参数。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@protocol YYISelectCouponViewControllerDelegate &lt;NSObject&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 选择优惠券</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> @param coupon 优惠券,为nil为不使用优惠券</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">-(void)userSelectedCoupon:(DMGDeductible *)coupon;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>YYISelectCouponViewController</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">                [self.delegate userSelectedCoupon:model];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>GBuyGoldOrderViewController</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@interface GBuyGoldOrderViewController : RootViewController&lt;YYISelectCouponViewControllerDelegate&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>而他继承这个协议，也可以看做虚函数继承，我们只是要他的功能。(返回值，输出)。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma mark -  YYISelectCouponViewControllerDelegate</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">-(void)userSelectedCoupon:(DMGDeductible *)coupon{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    self.selectCoupon = coupon;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>将self传过去，本质上是让 <code>mycoupon</code>持有自己，和delegate无关，不管是不是代理函数都行。只要是public函数都可以。可以是<code>userSelectedCoupon</code>也可以是<code>GBuyGoldOrderViewController.h</code>中定义的其他函数。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        YYISelectCouponViewController *mycoupon = [[YYISelectCouponViewController alloc] initWithCouponArray:_couponArray delegate:self];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        [self.navigationController  pushViewController:mycoupon animated:YES];</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>反向传值不一定得用代理啊，public的属性赋值和方法调用都可以传值啊。</p><p>但是代理可以解耦。</p><p>协议可以继承，也可以实现代理模式，最重要的是继承的<code>纯虚函数的抽象类</code>的概念（要特定的返回类型，但是每个类的会实现不一样）。</p><p>代理模式的说明：</p><p>XXObject  *obj = [XXobject new];</p><p>tableView.delegate =  obj;</p><p>tableView 内部肯定有用delegate方法的。</p><p>协议和public方法的区别是，协议提前定了需要实现的方法，虽然不知道谁去实现，但是可以调用。这是一个约定。还可以设定某些方式是必须实现的，某些方法是可选的等等。但是切记 代理模式只是协议的一个应用，不是全部。</p><p>Public 函数大概分为有返回值和无返回值的。</p><p>1.有返回值的，一般作为工具类。要的是输出。为自己服务，可以使直接返回，也可以是block返回。</p><p>2.无返回值的，一般是属性。要的是对方的变化，或者是对方的服务。</p><p>回到协议的本质：</p><p>比如前端开发和UI定义了一个协议，页面控制器就相当于是UI开发，tableView就相当于是前端，定的协议是UI设计师给前端提供UI设计图。页面控制器只要继承了tableViewDelegate 就必须实现代理方法。就相当于某个UI同学接受了这个任务就需要提供UI设计图，而前端同学不需要知道是怎们设计，只要拿结果就行了。</p><p>协议：约束和规矩。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#ifndef _OBJC_NSOBJECT_H_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#define _OBJC_NSOBJECT_H_</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#if __OBJC__</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;objc/objc.h&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;objc/NSObjCRuntime.h&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@class NSString, NSMethodSignature, NSInvocation;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@protocol NSObject</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (BOOL)isEqual:(id)object;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@property (readonly) NSUInteger hash;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@property (readonly) Class superclass;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &#x27;type(of: anObject)&#x27; instead&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (instancetype)self;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)performSelector:(SEL)aSelector;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)performSelector:(SEL)aSelector withObject:(id)object;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (BOOL)isProxy;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (BOOL)isKindOfClass:(Class)aClass;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (BOOL)isMemberOfClass:(Class)aClass;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (BOOL)conformsToProtocol:(Protocol *)aProtocol;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (BOOL)respondsToSelector:(SEL)aSelector;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (instancetype)retain OBJC_ARC_UNAVAILABLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (oneway void)release OBJC_ARC_UNAVAILABLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@property (readonly, copy) NSString *description;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@optional</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@property (readonly, copy) NSString *debugDescription;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">OBJC_ROOT_CLASS</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">OBJC_EXPORT</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@interface NSObject &lt;NSObject&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic push</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Class isa  OBJC_ISA_AVAILABILITY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic pop</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (void)load;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (void)initialize;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (instancetype)init</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#if NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NS_DESIGNATED_INITIALIZER</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#endif</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)dealloc OBJC_SWIFT_UNAVAILABLE(&quot;use &#x27;deinit&#x27; to define a de-initializer&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)finalize OBJC_DEPRECATED(&quot;Objective-C garbage collection is no longer supported&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)copy;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)mutableCopy;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (id)copyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (id)mutableCopyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (BOOL)instancesRespondToSelector:(SEL)aSelector;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (BOOL)conformsToProtocol:(Protocol *)protocol;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (IMP)methodForSelector:(SEL)aSelector;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (IMP)instanceMethodForSelector:(SEL)aSelector;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)doesNotRecognizeSelector:(SEL)aSelector;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (BOOL)allowsWeakReference UNAVAILABLE_ATTRIBUTE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (BOOL)retainWeakReference UNAVAILABLE_ATTRIBUTE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (BOOL)isSubclassOfClass:(Class)aClass;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (NSUInteger)hash;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (Class)superclass;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &#x27;aClass.self&#x27; instead&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (NSString *)description;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (NSString *)debugDescription;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#endif</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#endif</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>比如NSObject继承NSObject协议，那个NSObject协议中的方法，我们就可以方程NSObject继承来的方法直接使用了。（认识继承的概念）由此可见，协议名和类名是可以一样的。</p><p>OC的协议-Protocol</p><p>你想要的，由别人来实现。</p><p>例如：</p><p>你要买衣服，衣服有服装厂家生产。你只需要告知这个需求（Protocol），接了这个需求（继承这个Protocol）的厂家（继承协议的实体类）来为你做衣服（实现代理方法）。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多继承"></a>多继承<a class="hash-link" href="#多继承" title="Direct link to heading">#</a></h2><p>C类要同时继承A类和B类，则称之为多继承。而Objective-C不支持多继承，由于消息机制名字查找发生在运行时而非编译时，很难解决多个基类可能导致的二义性问题。</p><p>为何OC不支持多继承？</p><p><a href="https://www.quora.com/Why-isnt-multiple-inheritance-supported-in-Objective-C" target="_blank" rel="noopener noreferrer">https://www.quora.com/Why-isnt-multiple-inheritance-supported-in-Objective-C</a></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Multiple inheritance is disallowed in many popular languages because it introduces potential for difficult-to-resolve conflicts. This is especially true when dealing with Dynamic dispatch (sometimes called &quot;Virtual functions&quot;), and the Diamond problem.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多继承的坏处"></a>多继承的坏处<a class="hash-link" href="#多继承的坏处" title="Direct link to heading">#</a></h3><p>名字冲突：</p><p>多个父类具有相同的属性名或者方法名。就会造成冲突。oc中的消息查找会出错。</p><p>动态调度（虚函数）</p><p><a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem</a></p><p><a href="https://en.wikipedia.org/wiki/Dynamic_dispatch" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Dynamic_dispatch</a></p><p><a href="https://en.wikipedia.org/wiki/Virtual_function" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Virtual_function</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多继承的好处"></a>多继承的好处<a class="hash-link" href="#多继承的好处" title="Direct link to heading">#</a></h3><p>拥有了多个父类的属性和方法。扩展性更强。</p><p>y</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="oc多继承的实现"></a>OC多继承的实现<a class="hash-link" href="#oc多继承的实现" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="封装法"></a>封装法<a class="hash-link" href="#封装法" title="Direct link to heading">#</a></h4><p>封装一个类，包装想要继承的类（最简单）</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="协议法"></a>协议法<a class="hash-link" href="#协议法" title="Direct link to heading">#</a></h4><p>协议相当于虚函数，实现需要自己来。适合于只要继承接口，而实现需要自己来的情景。</p><p>虽然OC在语法上禁止类使用多继承，但是却可以用协议来实现多继承。协议只能提供接口，而没有提供实现方式，如果只是想多继承基类的接口，那么遵守多协议无疑是最好的方法。</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="idnsobjectselfclass"></a>id,NSObject,self,Class<a class="hash-link" href="#idnsobjectselfclass" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="id和nsobject"></a>id和NSObject<a class="hash-link" href="#id和nsobject" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="nsobject"></a>NSObject<a class="hash-link" href="#nsobject" title="Direct link to heading">#</a></h2><ol><li><p>OC基类。</p></li><li><p>NSObject继承NSObject协议。</p></li><li><p>NSObject对象有一个isa的成员变量，指向Class(objc_class 结构体指针)</p></li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@interface NSObject &lt;NSObject&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic push</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Class isa  OBJC_ISA_AVAILABILITY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic pop</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct objc_class *Class;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="id"></a>id<a class="hash-link" href="#id" title="Direct link to heading">#</a></h2><ol><li>本质是 objc_object 结构体指针</li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/// Represents an instance of a class.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct objc_object {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/// A pointer to an instance of a class.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct objc_object *id;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><ol start="2"><li>objc_object 结构体 有一个名为isa的 指向Class(objc_class 结构体指针)。</li></ol><p>id 简单地申明了指向对象的指针，没有给编译器任何类型信息，因此，编译器不会做类型检查。但也因为是这样，你可以发送任何信息给id类型的对象。这就是为什么+alloc返回id类型，但调用[[Foo alloc] init]不会产生编译错误。</p><p>因此，<strong>id类型是运行时的动态类型</strong>，编译器无法知道它的真实类型，即使你发送一个id类型没有的方法，也不会产生编译警告。</p><p>NSObject 相当于 objc_object。</p><p>id  相当于  NSObject * 。</p><p>那id  是不是就是NSObject对象指针？。</p><p>id 不一定指向NSObject对象，id指向的是objc_object 结构体。</p><p><code>id&lt;NSObject&gt;</code> 指向继承<code>&lt;NSObject&gt;</code>协议的对象，注意不是NSObject对象，虽然，NSObject对象也继承NSObject协议。NSObject只能算是他的一个子集。例如NSProxy 也继承 NSObject对象。</p><p>区别：</p><p>一个是OC类，一个是结构体指针。</p><p>指向拥有NSObject方法对象的指针</p><p><code>id&lt;NSObject&gt;</code></p><p> 这点延伸到了协议和代理的协议。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">id告诉编译器，你不关心对象是什么类型，但它必须遵守NSObject协议(protocol)，编译器就能保证所有赋值给id类型的对象都遵守NSObject协议(protocol)。这样的指针可以指向任何NSObject对象，因为NSObject对象遵守NSObject协议(protocol)，而且，它也可以用来保存NSProxy对象，因为它也遵守NSObject协议(protocol)。这是非常强大，方便且灵活，你不用关心对象是什么类型，而只关心它实现了哪些方法。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>如果真的需要编译器检查，那你就考虑使用第2种或者第3种。很少看到NSObject＊能正常运行，但id无法正常运行的。使用协议(protocol)的优点是，它能指向NSProxy对象，而更常用的情况是，你只想知道某个对象遵守了哪个协议，而不用关心它是什么类型。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">补充：使用id&lt;NSObject&gt;来声明一个对象，相当于告诉编译我们并不知道这个对象的类型，但是它实现NSObject protocol。一个这种类型的指针，即可以用来指向NSObject*对象，也可以用来指向NSProxy*对象，因为NSObject对象与NSProxy对象都是现了NSObject protocol</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>相同点：</p><p>NSObject 和 id 都有一个isa成员变量。指向Class(objc_class 结构体指针)。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="self"></a>self<a class="hash-link" href="#self" title="Direct link to heading">#</a></h2><p>　　1&gt; self 是 OC 提供保留字；</p><p>　　2&gt; self 代表着当前方法的调用者；</p><p>　　3&gt; 在 - 方法中，self代表着&quot;对象&quot;；</p><p>　　4&gt; 在 + 方法中，self代表着&quot;类&quot;；</p><p>　　5&gt; self 是方法的隐藏的参数变量，指向当前调用方法的对象，另一个隐藏参数是 _cmd，代表当前类方法的selector。</p><p><a href="https://www.cnblogs.com/markstray/p/5611878.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/markstray/p/5611878.html</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="class"></a>Class<a class="hash-link" href="#class" title="Direct link to heading">#</a></h2><p>其实OC中Class也是对象 ，我们可以看看他们三个（<code>id</code> , <code>Class</code>,<code>NSObject *</code>）在runtime中的定义</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Class其实是 结构体 objc_class * 的指针 </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct objc_class *Class;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// id其实是 结构体 objc_object * 的指针 别名</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct objc_object *id;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//OC的基类 NSObject 的声明 - 可以理解为其实可以看做是首地址为指向  objc_class *  （Isa）指针的内存 都可以看做是对象</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@interface NSObject &lt;NSObject&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     Class isa  OBJC_ISA_AVAILABILITY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct objc_object {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    isa_t isa;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct objc_class : objc_object {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Class ISA;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Class superclass;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cache_t cache;             // formerly cache pointer and vtable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>通过上面的源码我盟可以总结出几点：</p><ul><li>Class其实是 结构体 objc_class * 的指针 别名</li><li>id其实是 结构体 objc_object * 的指针 别名</li><li>结构体<code>objc_object</code>与OC中的 <code>NSObject</code> 的首地址都是指向 <code>isa</code> ，可以理解为首地址为<code>ISA</code>指针的内存都可以称为对象。</li><li><code>objc_class</code> 是继承自 <code>objc_object</code> ，也就是说，OC中 <code>Class</code> 也是一个对象。因此框架中无论是<code>hook</code>的实例方法还是<code>hook</code>的类方法，都可以统一把 调用的对象（ <code>Class</code> 或   <code>NSObject *</code> ） 传参 给了<code>id</code> 类型。</li><li><a href="https://www.jianshu.com/p/0276f75e273a" target="_blank" rel="noopener noreferrer">id和NSObject的区别和联系</a></li><li><a href="https://www.jianshu.com/p/0276f75e273a" target="_blank" rel="noopener noreferrer">id和NSObject的区别和联系</a></li><li><a href="https://blog.csdn.net/colorapp/article/details/45317347" target="_blank" rel="noopener noreferrer">id、NSObject *、id<code>&lt;NSObject&gt;</code>、instancetype的区别</a></li></ul><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="课后问题"></a>课后问题<a class="hash-link" href="#课后问题" title="Direct link to heading">#</a></h1><p>问题？</p><ol><li>Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方法用继承好还是分类好？为什么？</li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Objective-C的类不可以多重继承；可以使用协议实现多个接口，通过实现多个接口可以完成C++的多重继承；Category是类别。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">用继承。因为不能用分类。分类覆盖掉原有类的方法，导致程序中其他调用的地方会改变。当然，如果是我来的话，我也不会用继承，而是新增一个方法，可以放到类别中。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><ol start="2"><li>import 跟#include 又什么区别，@class呢, <code>#import&lt;&gt;</code> 跟 #import&quot;&quot;又什么区别?</li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">1.import和include 的使用环境不同。一个是OC一个是C/C++。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">2.import和include 的导入文件处理上不同。无论import多少次，import只会导入一次，include却没有这个处理。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">3. @class主要作用是在头文件的相互包含问题时，在接口@interface中告诉编译器有这么个类，我使用，你别报错。而在实现@implementation文件中要使用相应类的接口，还是需要import引入相应的类</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>3.属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">属性修饰符</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">1.读写性 readwrite，readonly  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">当为readonly时，只会生成getter方法 不会生成setter方法 ，也就是不希望属性在类外被改变</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">2.原子性 nonatomic，atomic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使用nonatomic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">3.内存管理特性 assign，copy，strong， weak</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">赋值，持有。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">引用计数增加了没有，是否新开辟了内存。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><ol start="4"><li>写一个setter方法用于完成<code>@property (nonatomic,retain)NSString *name</code>,写一个setter方法用于完成<code>@property(nonatomic，copy)NSString *name</code></li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void) setName:(NSString*) name {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [name retain];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [_name release];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _name = name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)setName:(NSString *)name {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    id t = [str copy];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [_name release];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    _name = t;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><ol start="5"><li>对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">编译时是NSString的类型;运行时是NSData类型的对象</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><ol start="6"><li>常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int</li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">object-c的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><ol start="7"><li>id和NSObject *和instanceType的区别与联系？</li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/// A pointer to an instance of a class.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef struct objc_object *id;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/// Represents an instance of a class.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct objc_object {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@interface NSObject &lt;NSObject&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic push</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Class isa  OBJC_ISA_AVAILABILITY;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#pragma clang diagnostic pop</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>instanceType 就是实例类型，而非泛指。例如：</p><p>例子:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">NSString *str = [Person person];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">NSLog(@&quot;%lu&quot;, str.length);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>对于以上代码,如果</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">[Person person]返回值为id类型,则在编辑代码时xcode不会报错或者警告,运行时则会崩溃(因为OC是动态检测对象的真实类型);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">反之,当其返回值为instanceType时,xcode则会报出警告.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">所以,建议写类的方法时,对于返回值,如果是id类型的话,尽量使用instanceType.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><hr><p>原创文章，转载请保留原文链接，未经授权拒绝转载，谢谢。</p><p>联系作者：<a href="mailto:dys90@qq.com" target="_blank" rel="noopener noreferrer">dys90@qq.com</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="dys-typora-open://mine/survival/docs/编程语言/Objective-C/Objective-C-面向对象.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#属性" class="table-of-contents__link">属性</a><ul><li><a href="#基本概念" class="table-of-contents__link">基本概念</a></li><li><a href="#属性修饰符" class="table-of-contents__link">属性修饰符</a></li><li><a href="#总结" class="table-of-contents__link">总结</a></li><li><a href="#属性-1" class="table-of-contents__link">属性</a></li><li><a href="#属性修饰符-1" class="table-of-contents__link">属性修饰符</a></li></ul></li><li><a href="#方法" class="table-of-contents__link">方法</a><ul><li><a href="#方法的执行过程" class="table-of-contents__link">方法的执行过程</a></li><li><a href="#oc方法执行过程" class="table-of-contents__link">OC方法执行过程</a></li><li><a href="#runtime层面" class="table-of-contents__link">runtime层面</a></li><li><a href="#objective-c层面" class="table-of-contents__link">Objective-C层面</a></li><li><a href="#常用场景" class="table-of-contents__link">常用场景</a></li><li><a href="#总结-1" class="table-of-contents__link">总结</a></li></ul></li><li><a href="#课后" class="table-of-contents__link">课后</a></li><li><a href="#类别" class="table-of-contents__link">类别</a></li><li><a href="#多继承" class="table-of-contents__link">多继承</a><ul><li><a href="#多继承的坏处" class="table-of-contents__link">多继承的坏处</a></li><li><a href="#多继承的好处" class="table-of-contents__link">多继承的好处</a></li><li><a href="#oc多继承的实现" class="table-of-contents__link">OC多继承的实现</a></li></ul></li><li><a href="#id和nsobject" class="table-of-contents__link">id和NSObject</a></li><li><a href="#nsobject" class="table-of-contents__link">NSObject</a></li><li><a href="#id" class="table-of-contents__link">id</a></li><li><a href="#self" class="table-of-contents__link">self</a></li><li><a href="#class" class="table-of-contents__link">Class</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.4ec932fe.js"></script>
<script src="/runtime~main.3425bbd6.js"></script>
<script src="/main.4d172be4.js"></script>
<script src="/1.978a979f.js"></script>
<script src="/284.9b127a42.js"></script>
<script src="/285.87bc8610.js"></script>
<script src="/935f2afb.0ad17a86.js"></script>
<script src="/283.46b48473.js"></script>
<script src="/49fbe45c.d3c64a77.js"></script>
</body>
</html>