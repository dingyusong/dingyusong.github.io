<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Blog Atom Feed"><title data-react-helmet="true">数据结构 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="数据结构 | My Site"><meta data-react-helmet="true" name="description" content="数据结构"><meta data-react-helmet="true" property="og:description" content="数据结构"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/编程基础/数据结构与算法/数据结构"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/编程基础/数据结构与算法/数据结构"><link rel="stylesheet" href="/styles.8cfbcdec.css">
<link rel="preload" href="/styles.e736442d.js" as="script">
<link rel="preload" href="/runtime~main.500606b1.js" as="script">
<link rel="preload" href="/main.e34cadf8.js" as="script">
<link rel="preload" href="/1.3353372a.js" as="script">
<link rel="preload" href="/256.3f6603bc.js" as="script">
<link rel="preload" href="/257.427a7301.js" as="script">
<link rel="preload" href="/935f2afb.0ee8c40a.js" as="script">
<link rel="preload" href="/255.24175022.js" as="script">
<link rel="preload" href="/903e518c.84a82064.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/编程基础/编程基础/编程基础">编程基础</a><a class="navbar__item navbar__link" href="/docs/编程语言/编程语言">编程语言</a><a class="navbar__item navbar__link" href="/docs/工具/常用工具">工具</a><a class="navbar__item navbar__link" href="/docs/应用开发/应用开发">应用开发</a><a class="navbar__item navbar__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a><a class="navbar__item navbar__link" href="/docs/音视频/音视频">音视频</a><a class="navbar__item navbar__link" href="/docs/项目/项目">项目</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Search" aria-label="Search" class="navbar__search-input search-bar"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/编程基础/编程基础/编程基础">编程基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程语言/编程语言">编程语言</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/工具/常用工具">工具</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/应用开发/应用开发">应用开发</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/音视频/音视频">音视频</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/项目/项目">项目</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/编程基础/编程基础">编程基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/学习经验/学习经验">学习经验</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">数字电路</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数字电路/数字电路">数字电路</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">计算机组成原理</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机组成原理">计算机组成原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机是怎么跑起来的">计算机是怎么跑起来的</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机系统基础">计算机系统基础</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">操作系统</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/操作系统/操作系统">操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/操作系统/Unix系统管理">Unix系统管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/操作系统/Unix环境编程">Unix环境编程</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机网络/计算机网络">计算机网络</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机系统基础/计算机系统基础">计算机系统基础</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">编译链接调试</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/编译原理/编译原理">编译原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/编译原理/程序员的自我修养">程序员的自我修养</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">数据结构与算法</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/编程基础/数据结构与算法/数据结构与算法">数据结构与算法</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/编程基础/数据结构与算法/数据结构">数据结构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/编程基础/数据结构与算法/算法">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/编程基础/数据结构与算法/算法面试">算法面试</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/设计模式/设计模式">设计模式</a></li></ul></div></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">数据结构</h1></header><div class="markdown"><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数据结构"></a>数据结构<a class="hash-link" href="#数据结构" title="Direct link to heading">#</a></h1><p>[toc]</p><p>把数据按照一定规则组织起来，然后进行<strong>增删改查</strong>。不同的组织方式，对于增删改查会有不同的效率。（增删改查）</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="内存角度"></a>内存角度<a class="hash-link" href="#内存角度" title="Direct link to heading">#</a></h2><p>从内存角度来看，本质上分为两种：</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="内存连续"></a>内存连续<a class="hash-link" href="#内存连续" title="Direct link to heading">#</a></h3><p>底层是数组实现，随机访问效率很高，但是插入删除效率很低。</p><ul><li>数组</li><li>堆</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="内存不连续"></a>内存不连续<a class="hash-link" href="#内存不连续" title="Direct link to heading">#</a></h3><p>内存是不连续的，随机访问效率很低，但是插入删除效率很高。</p><ul><li>链表</li><li>树</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="高层数据结构抽象数据结构"></a>高层数据结构/抽象数据结构<a class="hash-link" href="#高层数据结构抽象数据结构" title="Direct link to heading">#</a></h2><p>这些都是在一些语言的标准库中被实现的数据结构，在日常开发中经常会用到。</p><p>容器类，一般包括以下操作。</p><ul><li>容器的构造</li><li>容器的查询-（isEmpty， size，capacity）</li><li>元素的构造</li><li>元素的增删改查</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="sequence-containers、序列容器、线性表"></a>Sequence containers、序列容器、线性表<a class="hash-link" href="#sequence-containers、序列容器、线性表" title="Direct link to heading">#</a></h3><p>Sequence containers implement data structures which can be accessed sequentially.</p><table><thead><tr><th>array(C++11)</th><th>static contiguous array  (class template)</th></tr></thead><tbody><tr><td>vector</td><td>dynamic contiguous array  (class template)</td></tr><tr><td>deque</td><td>double-ended queue  (class template)</td></tr><tr><td>forward_list(C++11)</td><td>singly-linked list  (class template)</td></tr><tr><td>list</td><td>doubly-linked list  (class template)</td></tr></tbody></table><p>序列容器实现可以顺序访问的数据结构。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="静态连续数组"></a>静态连续数组<a class="hash-link" href="#静态连续数组" title="Direct link to heading">#</a></h4><p>C++: Array</p><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>访问</td><td>O(1)</td></tr><tr><td>尾部添加</td><td>O(1)</td></tr><tr><td>非尾部添加</td><td>O(n)</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="动态连续数组"></a>动态连续数组<a class="hash-link" href="#动态连续数组" title="Direct link to heading">#</a></h4><p>C++: Vector </p><ul><li>resize</li></ul><p>动态扩容和缩容。</p><p>复杂度震荡</p><p>扩容：大于原来的容量，增加一倍</p><p>缩容：减小到现在容量的1/4，缩减一倍</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="todo-动态数组"></a>TODO: 动态数组<a class="hash-link" href="#todo-动态数组" title="Direct link to heading">#</a></h5><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" disabled=""> C++实现</li><li class="task-list-item"><input type="checkbox" disabled=""> Java实现</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="双端队列"></a>双端队列<a class="hash-link" href="#双端队列" title="Direct link to heading">#</a></h4><p>C++: deque</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="单项链表"></a>单项链表<a class="hash-link" href="#单项链表" title="Direct link to heading">#</a></h4><p>C++: forward_list</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="双向链表"></a>双向链表<a class="hash-link" href="#双向链表" title="Direct link to heading">#</a></h4><p>C++: list</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="associative-containers、关联容器"></a>Associative containers、关联容器<a class="hash-link" href="#associative-containers、关联容器" title="Direct link to heading">#</a></h3><p>Associative containers implement sorted data structures that can be quickly searched (<em>O(log n)</em> complexity).</p><table><thead><tr><th>[set](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/set.html)</th><th>collection of unique keys, sorted by keys  (class template)</th></tr></thead><tbody><tr><td>[map](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/map.html)</td><td>collection of key-value pairs, sorted by keys, keys are unique  (class template)</td></tr><tr><td>[multiset](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/multiset.html)</td><td>collection of keys, sorted by keys  (class template)</td></tr><tr><td>[multimap](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/multimap.html)</td><td>collection of key-value pairs, sorted by keys  (class template)</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="集合"></a>集合<a class="hash-link" href="#集合" title="Direct link to heading">#</a></h4><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Set&lt;E&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void add(E)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void remove( Ễ)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">boo lean contains( E)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int getSize()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">boolean isEmpty()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>C++：set</p><p>集合和映射</p><p>注意：集合和映射，类似的这种类，底层实现有可能是，二叉树，也有可能是别的结构。只要满足，实现其对外提供的接口即可。</p><p>不能重复添加。IP统计，词汇量统计， 客户统计</p><ul><li>注意</li></ul><p>存储的元素必须有可比较性。</p><table><thead><tr><th></th><th>有序集合</th><th>无序集合</th></tr></thead><tbody><tr><td>底层实现</td><td>平衡树(红黑树)</td><td>hash表（链地址法）</td></tr><tr><td>C++</td><td>Set</td><td>unordered_set</td></tr><tr><td>Java</td><td>TreeSet</td><td>HashSet</td></tr><tr><td>Swift</td><td></td><td>Set</td></tr><tr><td>Objective-C</td><td></td><td>NSSet</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="映射"></a>映射<a class="hash-link" href="#映射" title="Direct link to heading">#</a></h4><p>C++：map</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="bitmap-位图"></a>BitMap-位图<a class="hash-link" href="#bitmap-位图" title="Direct link to heading">#</a></h5><p>BitMap算法的核心思想是用bit数组来记录0-1两种状态，然后再将具体数据映射到这个比特数组的具体位置，这个比特位设置成0表示数据不存在，设置成1表示数据存在。</p><p>BitMap算在在大量数据查询、去重等应用场景中使用的比较多，这个算法具有比较高的空间利用率。</p><p><strong>实现</strong></p><p>BitMap算法的开源实现由<strong>JDK的BitSet和谷歌的EWAHCompressedBitmap。</strong></p><p>BitSet是对BitMap算法的简单实现，而EWAHCompressedBitmap对BitMap的存储空间做了优化。</p><ul><li><p>漫画：Bitmap算法 整合版：<a href="https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg</a></p></li><li><p><a href="https://www.cnblogs.com/54chensongxia/p/11591979.html" target="_blank" rel="noopener noreferrer">位图算法：什么是BitMap</a></p></li><li><p>究竟什么是位图？：<a href="http://jartto.wang/2018/12/09/bitmap/" target="_blank" rel="noopener noreferrer">http://jartto.wang/2018/12/09/bitmap/</a></p></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="布隆过滤器-bloom-filter"></a>布隆过滤器-Bloom Filter<a class="hash-link" href="#布隆过滤器-bloom-filter" title="Direct link to heading">#</a></h5><ul><li>它实质上是一个很长的二进制向量和一系列随机映射函数(Hash函数)</li><li>常见应用：网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统、解决缓存穿透问题</li></ul><p>优缺点 </p><ul><li><p>优点:空间效率和查询时间都远远超过一般的算法 </p></li><li><p>缺点:有一定的误判率、删除困难</p></li></ul><p>假设布隆过滤器由 20位二进制、 3 个哈希函数组成，每个元素经过哈希函数处理都能生成一个索引位置 </p><ul><li>添加元素:将每一个哈希函数生成的索引位置都设为 1</li><li>查询元素是否存在<ul><li>如果有一个哈希函数生成的索引位置不为 1，就代表不存在(100%准确) </li><li>如果每一个哈希函数生成的索引位置都为 1，就代表存在(存在一定的误判率)</li></ul></li><li>添加、查询的时间复杂度都是:O(k) ，k 是哈希函数的个数。空间复杂度是:O(m) ，m 是二进制位的个数。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多重集合"></a>多重集合<a class="hash-link" href="#多重集合" title="Direct link to heading">#</a></h4><p>C++：multiset</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多重映射"></a>多重映射<a class="hash-link" href="#多重映射" title="Direct link to heading">#</a></h4><p>C++：multimap</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="unordered-associative-containers、无序关联容器"></a>Unordered associative containers、无序关联容器<a class="hash-link" href="#unordered-associative-containers、无序关联容器" title="Direct link to heading">#</a></h3><p>Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (<em>O(1)</em> amortized, <em>O(n)</em> worst-case complexity).</p><table><thead><tr><th>[unordered_set](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/unordered_set.html)(C++11)</th><th>collection of unique keys, hashed by keys  (class template)</th></tr></thead><tbody><tr><td>[unordered_map](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/unordered_map.html)(C++11)</td><td>collection of key-value pairs, hashed by keys, keys are unique  (class template)</td></tr><tr><td>[unordered_multiset](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/unordered_multiset.html)(C++11)</td><td>collection of keys, hashed by keys  (class template)</td></tr><tr><td>[unordered_multimap](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/unordered_multimap.html)(C++11)</td><td>collection of key-value pairs, hashed by keys  (class template)</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="无序集合"></a>无序集合<a class="hash-link" href="#无序集合" title="Direct link to heading">#</a></h4><p>C++：unordered_set</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="无序映射"></a>无序映射<a class="hash-link" href="#无序映射" title="Direct link to heading">#</a></h4><p>C++：unordered_map</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="无序多重集合"></a>无序多重集合<a class="hash-link" href="#无序多重集合" title="Direct link to heading">#</a></h4><p>C++：unordered_multiset</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="无序多重映射"></a>无序多重映射<a class="hash-link" href="#无序多重映射" title="Direct link to heading">#</a></h4><p>C++：unordered_multimap</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="container-adaptors、容器适配器"></a>Container adaptors、容器适配器<a class="hash-link" href="#container-adaptors、容器适配器" title="Direct link to heading">#</a></h3><p>Container adaptors provide a different interface for sequential containers.</p><table><thead><tr><th>[stack](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/stack.html)</th><th>adapts a container to provide stack (LIFO data structure)  (class template)</th></tr></thead><tbody><tr><td>[queue](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/queue.html)</td><td>adapts a container to provide queue (FIFO data structure)  (class template)</td></tr><tr><td>[priority_queue](dfile:///Users/Ding/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/priority_queue.html)</td><td>adapts a container to provide priority queue  (class template)</td></tr></tbody></table><p>容器适配器为顺序容器提供不同的接口。（对其他容器的封装）</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="栈"></a>栈<a class="hash-link" href="#栈" title="Direct link to heading">#</a></h4><p>C++：std::stack</p><p>Java：java.util.Stack 底层实现为：java.util.Vector</p><p>动态数组实现栈：ArrayStack</p><table><thead><tr><th>操作</th><th>复杂度</th></tr></thead><tbody><tr><td>进栈：void push(E e);</td><td>O(1)</td></tr><tr><td>出栈：E pop();</td><td>O(1)</td></tr><tr><td>查看栈顶元素：E peek();</td><td>O(1)</td></tr></tbody></table><p>中间可能有数组的resize操作。但是resize的均摊复杂度也是O(1)。所以用动态数组实现栈非常合适。</p><p>单链表的头结点的插入和删除的复杂度是O(1),所以也能用来实现栈。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="队列"></a>队列<a class="hash-link" href="#队列" title="Direct link to heading">#</a></h4><p>C++：std::queue</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="优先队列"></a>优先队列<a class="hash-link" href="#优先队列" title="Direct link to heading">#</a></h4><p>C++：std::priority_queue</p><p><img alt="image-20211005173735540" src="/assets/images/image-20211005173735540-23ba420c94f64b4acf3bc26ab0564251.png"></p><p>在1,000,000个元素中选出钱100名？在N个元素中选出前M个元素。</p><p>排序：n*logn</p><p>优先队列：n*logm</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="底层数据结构"></a>底层数据结构<a class="hash-link" href="#底层数据结构" title="Direct link to heading">#</a></h2><p>高层数据结构是对底层数据结构的封装。高层数据结构是对外的，屏蔽了很多底层数据的实现细节，使用时我们不需要关心其内部是如何实现，只需要关心其特性即可。</p><ul><li><p>数组</p></li><li><p>链表</p></li><li><p>树</p><ul><li>二叉搜索树</li><li>完全二叉树<ul><li>二叉堆（最大堆，最小堆）（底层是数组实现，这也表明数组在内存中不一定是链表形式）</li></ul></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="线性结构"></a>线性结构<a class="hash-link" href="#线性结构" title="Direct link to heading">#</a></h2><p>一个前驱一个后继。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数组"></a>数组<a class="hash-link" href="#数组" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="静态数组"></a>静态数组<a class="hash-link" href="#静态数组" title="Direct link to heading">#</a></h4><p>数组大小不能变化。好处就是简答，效率高，比如OC的NSArray是只读的数组，线程安全。</p><table><thead><tr><th>语言</th><th>类型</th></tr></thead><tbody><tr><td>Java</td><td>java.util.Arrays</td></tr><tr><td>C++</td><td>std::array</td></tr><tr><td>Objective-C</td><td>NSArray</td></tr><tr><td>Swift</td><td>没有提供</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="动态数组"></a>动态数组<a class="hash-link" href="#动态数组" title="Direct link to heading">#</a></h4><p>数组的最大优点是支持随机访问查询是O(1)，插入删除非尾结点是O(n)。</p><ol><li>支持随机访问。O(1)级别</li><li>尾部插入删除。O(1)级别</li></ol><p>时间复杂度：</p><ul><li><p>添加</p><ul><li>addLast(e)				O(1)</li><li>addFirst(e)				O(n)</li><li>addIndex(e)				O(n/2)=O(n)</li></ul></li><li><p>删除</p><ul><li>removeLast(e)			O(1)</li><li>removeFirst(e)			O(n)</li><li>removeIndex(e)			O(n/2)=O(n)</li></ul></li><li><p>修改 O(1)</p><ul><li>setIndex(index, e)   O(1)</li></ul></li><li><p>查询</p><ul><li>get(index)        O(1)</li><li>contains(e)      O(n)</li><li>find(e)              O(n)</li></ul></li></ul><table><thead><tr><th>语言</th><th>类</th></tr></thead><tbody><tr><td>Java</td><td>java.util.Vector</td></tr><tr><td>C++</td><td>std::vector</td></tr><tr><td>Swift</td><td>Array</td></tr><tr><td>Objective-C</td><td>NSMutableArray</td></tr></tbody></table><p>栈的实现底层就是动态数组。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="单链表"></a>单链表<a class="hash-link" href="#单链表" title="Direct link to heading">#</a></h3><p>单链表的最大优点是动态。</p><p>如果只对头结点进行操作（添加，删除，修改，查询）的话，复杂度是O(1)。 其他的都是O(n)</p><ul><li><p>添加</p><ul><li>addLast(e)				    O(n)</li><li>addFirst(e)				    O(1)</li><li>addIndex(e)				  O(n/2)=O(n)</li></ul></li><li><p>删除</p><ul><li>removeLast(e)			  O(n)</li><li>removeFirst(e)			  O(1)</li><li>removeIndex(e)			O(n/2)=O(n)</li></ul></li><li><p>修改</p><ul><li>setIndex(index, e)         O(n)</li></ul></li><li><p>查询</p><ul><li>get(index)        O(n)</li><li>contains(e)      O(n)</li></ul></li></ul><p>乍一看这个复杂度，感觉这个单链表真没啥优势。</p><p>单链表的头结点的操作是O(1) 所以，也可以用来实现栈这种只在一端操作的结构。理论上是和数组实现的栈一个复杂度，都是O(1)。链表的包含更多的new操作，而数组需要resize。</p><p>近乎和链表相关的所有操作，都可以使用递归的形式完成。</p><p>链表研究：LinkedListProblems.pdf</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="双链表"></a>双链表<a class="hash-link" href="#双链表" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="循环链表"></a>循环链表<a class="hash-link" href="#循环链表" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数组链表"></a>数组链表<a class="hash-link" href="#数组链表" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="哈希表"></a>哈希表<a class="hash-link" href="#哈希表" title="Direct link to heading">#</a></h3><p>NSSet：hash</p><p>NSDIctionary：hash</p><p>提现了算法设计领域的经典思想：空间换时间。</p><p>哈希表是时间和空间之间的平衡。</p><p>哈希函数的设计是很重要的。</p><p>键通过哈希函数得到的所有分布越均匀越好。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="哈希函数的设计"></a>哈希函数的设计<a class="hash-link" href="#哈希函数的设计" title="Direct link to heading">#</a></h4><p>大素数</p><p>一个简单的解决办法：模一个素数。</p><p><a href="https://planetmath.org/goodhashtableprimes" target="_blank" rel="noopener noreferrer">https://planetmath.org/goodhashtableprimes</a></p><p><img alt="image-20211005193126446" src="/assets/images/image-20211005193126446-608cf50ff43cb4603be0978e3a04d1e6.png"></p><p><img alt="image-20211005193213516" src="/assets/images/image-20211005193213516-411b1192378e8f23cda5d4b1644f761c.png"></p><p>转成整型处理 并不是唯一的方法!
原则
1.一致性:如果a==b， 则hash(a) == hash(b)
2.高效性:计算高效简便
3.均匀性:哈希值均匀分布</p><p>Java，OC等类都有hashCode类似方法。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="hash冲突"></a>hash冲突<a class="hash-link" href="#hash冲突" title="Direct link to heading">#</a></h4><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="链地址法"></a>链地址法<a class="hash-link" href="#链地址法" title="Direct link to heading">#</a></h5><p><img alt="image-20211005193802725" src="/assets/images/image-20211005193802725-db7be5d1d73ba9cc14196f3357bdd78b.png"></p><p><img alt="image-20211005193842790" src="/assets/images/image-20211005193842790-cee559ae192321d84ee9f295a76093ca.png"></p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="开放地址法"></a>开放地址法<a class="hash-link" href="#开放地址法" title="Direct link to heading">#</a></h5><p><img alt="image-20211005194008581" src="/assets/images/image-20211005194008581-838ca58673b327773e85759b908d654a.png"></p><p><img alt="image-20211005194057305" src="/assets/images/image-20211005194057305-8eb32718b5fb9e936165ecf49d4546f0.png"></p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="再hash法"></a>再hash法<a class="hash-link" href="#再hash法" title="Direct link to heading">#</a></h5><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="树形结构"></a>树形结构<a class="hash-link" href="#树形结构" title="Direct link to heading">#</a></h2><p>为什么要有树结构？</p><p>将数据树结构存储后，出奇的高效。</p><p>只有一个前驱，但是有多个后继。</p><p>定义：</p><p>树是一种数据结构，它是由<strong>n（n&gt;=1）个有限节点</strong>组成一个具有<strong>层次关系</strong>的<strong>集合</strong>。</p><p><img alt="20200709159426299536002.jpg" src="/assets/images/20200709159426299536002-9f5a86f3d221ed3b80c18bb90a39f83b.jpg"></p><p>特点：</p><p>(01) 每个节点有零个或多个子节点；
(02) 没有父节点的节点称为根节点；
(03) 每一个非根节点有且只有一个父节点；
(04) 除了根节点外，每个子节点可以分为多个不相交的子树。</p><p><strong>树的基本术语</strong></p><p>若一个结点有子树，那么该结点称为子树根的&quot;双亲&quot;，子树的根是该结点的&quot;孩子&quot;。有相同双亲的结点互为&quot;兄弟&quot;。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。</p><p><strong>结点的度</strong>：结点拥有的子树的数目。
<strong>叶子</strong>：度为零的结点。
<strong>分支结点</strong>：度不为零的结点。
<strong>树的度</strong>：树中结点的最大的度。</p><p><strong>层次</strong>：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。
<strong>树的高度</strong>：树中结点的最大层次。
<strong>无序树</strong>：如果树中结点的各子树之间的次序是不重要的，可以交换位置。
<strong>有序树</strong>：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。
<strong>森林</strong>：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</p><p> <strong>二叉树的性质</strong></p><p>二叉树有以下几个性质：TODO(上标和下标)
<strong>性质1</strong>：二叉树第i层上的结点数目最多为 <strong>2**</strong>{i-1}<strong> (i≥1)。
</strong>性质2<strong>：深度为k的二叉树至多有</strong>2{k}-1<strong>个结点(k≥1)。
</strong>性质3<strong>：包含n个结点的二叉树的高度至少为</strong>log2 (n+1)<strong>。
</strong>性质4<strong>：在任意一棵二叉树中，若终端结点的个数为</strong>n0<strong>，度为2的结点数为</strong>n2<strong>，则</strong>n0=n2+1**。</p><p><strong>2.1 性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)</strong></p><p>证明：下面用&quot;数学归纳法&quot;进行证明。
(01) 当i=1时，第i层的节点数目为2{i-1}=2{0}=1。因为第1层上只有一个根结点，所以命题成立。
(02) 假设当i&gt;1，第i层的节点数目为2{i-1}。这个是根据(01)推断出来的！
下面根据这个假设，推断出&quot;第(i+1)层的节点数目为2{i}&quot;即可。
由于二叉树的每个结点至多有两个孩子，故&quot;第(i+1)层上的结点数目&quot; 最多是 &quot;第i层的结点数目的2倍&quot;。即，第(i+1)层上的结点数目最大值=2×2{i-1}=2{i}。
故假设成立，原命题得证！</p><p><strong>2.2 性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)</strong></p><p>证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用&quot;性质1&quot;可知，深度为k的二叉树的结点数至多为：
20+21+…+2k-1=2k-1
故原命题得证！</p><p><strong>2.3 性质3：包含n个结点的二叉树的高度至少为log2 (n+1)</strong></p><p>证明：根据&quot;性质2&quot;可知，高度为h的二叉树最多有2{h}–1个结点。反之，对于包含n个节点的二叉树的高度至少为log2(n+1)。</p><p><strong>2.4 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1</strong></p><p>证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=&quot;0度结点数(n0)&quot; + &quot;1度结点数(n1)&quot; + &quot;2度结点数(n2)&quot;。由此，得到等式一。
(等式一) n=n0+n1+n2
　   另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。
(等式二) n=n1+2n2+1
由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！</p><p><strong>3.1 满二叉树</strong></p><p><strong>定义</strong>：高度为h，并且由2{h} –1个结点的二叉树，被称为满二叉树。</p><p><strong>3.2 完全二叉树</strong></p><p><strong>定义</strong>：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。
<strong>特点</strong>：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。</p><p><strong>3.3 二叉查找树</strong></p><p><strong>定义</strong>：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。</p><p><strong>二叉树常见相关算法</strong></p><p>插入</p><p>删除</p><p>查找</p><p>遍历（前序遍历，中序遍历，后序遍历）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="二叉查找树-bst"></a>二叉查找树-BST<a class="hash-link" href="#二叉查找树-bst" title="Direct link to heading">#</a></h3><p>二叉查找树是二叉树中的一个重要的概念！也叫二分搜索树！</p><p><strong>定义</strong>：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。</p><p><img alt="20200709159426521147539.jpg" src="/assets/images/20200709159426521147539-7b8efbcd548277f26d13f0f5284a4e76.jpg"></p><p>递归</p><p>在二叉查找树中：
(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
(03) 任意节点的左、右子树也分别为二叉查找树。
(04) 没有键值相等的节点（no duplicate nodes）。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="支持的操作"></a>支持的操作<a class="hash-link" href="#支持的操作" title="Direct link to heading">#</a></h4><p><strong>创建</strong></p><p>创建节点的代码</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static Node* create_bstree_node(Type key, Node *parent, Node *left, Node* right)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Node* p;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if ((p = (Node *)malloc(sizeof(Node))) == NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return NULL;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    p-&gt;key = key;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    p-&gt;left = left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    p-&gt;right = right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    p-&gt;parent = parent;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return p;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>遍历</p><p>这里讲解<strong>前序遍历</strong>、<strong>中序遍历</strong>、<strong>后序遍历</strong>3种方式。</p><ul><li>前序遍历</li></ul><p>若二叉树非空，则执行以下操作：
(01) 访问根结点；
(02) 先序遍历左子树；
(03) 先序遍历右子树。</p><p>前序遍历代码</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void preorder_bstree(BSTree tree)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(tree != NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        printf(&quot;%d &quot;, tree-&gt;key);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        preorder_bstree(tree-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        preorder_bstree(tree-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><img alt="image-20211005142023294" src="/assets/images/image-20211005142023294-8c6aff4d8c9b55692279fd8da1f92322.png"></p><p><img alt="image-20211005142055796" src="/assets/images/image-20211005142055796-9974542410106390edba1865a42de6f8.png"></p><ul><li>中序遍历</li></ul><p>中序遍历得到的结果是顺序的。</p><p>若二叉树非空，则执行以下操作：
(01) 中序遍历左子树；
(02) 访问根结点；
(03) 中序遍历右子树。</p><p>中序遍历代码</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void inorder_bstree(BSTree tree)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(tree != NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        inorder_bstree(tree-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        printf(&quot;%d &quot;, tree-&gt;key);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        inorder_bstree(tree-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><img alt="image-20211005141944177" src="/assets/images/image-20211005141944177-e6ac9c3f30d51d4b97c1c7d8060eabdf.png"></p><ul><li>后序遍历</li></ul><p>若二叉树非空，则执行以下操作：
(01) 后序遍历左子树；
(02) 后序遍历右子树；
(03) 访问根结点。</p><p>后序遍历代码</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void postorder_bstree(BSTree tree)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(tree != NULL)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        postorder_bstree(tree-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        postorder_bstree(tree-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        printf(&quot;%d &quot;, tree-&gt;key);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><img alt="image-20211005141914538" src="/assets/images/image-20211005141914538-364a1e0cefad8810e900cd0e43f54ca1.png"></p><ul><li>层序遍历</li></ul><p><img alt="image-20211005142153080" src="/assets/images/image-20211005142153080-2b15b5757d7602c4467b697f2fb19903.png"></p><p>下面通过例子对这些遍历方式进行介绍。</p><p>引用场景： 内存释放。先释放孩子，最后释放自己。 </p><p>总结</p><p><strong>查找</strong></p><p>插入</p><p>删除</p><p>实践</p><ol><li>创建二叉查找树对象。</li><li>实现基于BST的集合BSTSet。</li><li>实现基于BST的映射BSTMap。</li><li>二分搜索树-插入-add</li><li>二分搜索树-查询-containes</li><li>二分搜索树-遍历-前中后序的递归写法（深度优先遍历）</li><li>二分搜索树-遍历-前中后序的非递归写法（前序遍历-借助栈结构）（经典教科书写法）（深度优先遍历）</li><li>二分搜索树-层序遍历（广度优先遍历）- 借助队列结构。</li><li>二分搜索树-删除 .</li><li>leetcode 349/350</li></ol><hr><ul><li><p>广度优先遍历的意义</p><ul><li>更快的找到问题的解</li><li>常用的算法设计中-最短路径</li><li>图中的深度优先遍历和广度优先遍历</li></ul></li></ul><hr><p>其他二分搜索树</p><ol><li>维护size的二分搜索树</li></ol><p><img alt="image-20211005142357322" src="/assets/images/image-20211005142357322-fb806d2476fbed9f6de624c8002ee88f.png"></p><ol start="2"><li>维护depth的二分搜索树</li></ol><p><img alt="image-20211005142506800" src="/assets/images/image-20211005142506800-40f88d3c561606a356bb819a544a0117.png"></p><ol start="3"><li>支持重复元素的二分搜索树</li></ol><p><img alt="image-20211005142531313" src="/assets/images/image-20211005142531313-e68922ef40899231e944f4f0a6bcfe87.png"></p><p><img alt="image-20211005142556931" src="/assets/images/image-20211005142556931-f0aac29b7d1afa10ca18a5210ff84031.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="二分搜索树的优势"></a>二分搜索树的优势<a class="hash-link" href="#二分搜索树的优势" title="Direct link to heading">#</a></h4><table><thead><tr><th></th><th>查找元素</th><th>插入元素</th><th>删除元素</th></tr></thead><tbody><tr><td>普通数组</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>顺序数组</td><td>O(logn)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>二分搜索树</td><td>O(logn)</td><td>O(logn)</td><td>O(logn)</td></tr></tbody></table><p>不仅可以查找数据，还可以高效的插入，删除数据，动态维护数据。</p><p>还可以方便的回答很多数据之间的关系问题：</p><ul><li>min,max,floor,ceil,rank,select</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="二叉平衡树（avl树）"></a>二叉平衡树（AVL树）<a class="hash-link" href="#二叉平衡树（avl树）" title="Direct link to heading">#</a></h3><p> 在二分搜索树的基础上，记录节点高度和计算平衡因子。</p><p> 加入节点后，沿着节点往上，维护平衡性（高度）。</p><p> 1.LL： 插入节点在不平衡节点的左侧的左侧。--&gt; 右旋转</p><p> 2.RR： 插入节点在不平衡节点的右侧的右侧。--&gt; 左旋转</p><p> 2.LR： 插入节点在不平衡节点的左侧的右侧。--&gt; 先左旋转，后右旋转</p><p> 2.RL： 插入节点在不平衡节点的右侧的左侧。--&gt; 先右旋转，后左旋转</p><p>在查找树的基础上进化出来的树。</p><p>AVL树中任何节点的两个子树的高度最大差别为1。</p><p>如果在AVL树中插入或删除节点后，使得高度之差大于1。此时，AVL树的平衡状态就被破坏，它就不再是一棵二叉树；为了让它重新维持在一个平衡状态，就需要对其进行旋转处理。学AVL树，重点的地方也就是它的旋转算法；</p><p><strong>(二叉查找树默认以第一个为根来进行二叉树的组织，而二叉平衡则会在插入的过程中转换树根以达到平衡)</strong></p><p><strong>旋转</strong>
前面说过，如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。这种失去平衡的可以概括为4种姿态：LL(左左)，LR(左右)，RR(右右)和RL(右左)。下面给出它们的示意图</p><p><img alt="20200814159738560898146.png" src="/assets/images/20200814159738560898146-070f9fd139e4f14bb24adf9d04da1406.png"></p><p>上图中的4棵树都是&quot;失去平衡的AVL树&quot;，从左往右的情况依次是：LL、LR、RL、RR。除了上面的情况之外，还有其它的失去平衡的AVL树，如下图：</p><p><img alt="20200814159738562725480.png" src="/assets/images/20200814159738562725480-6f7f0521f5152ce911d1de0a770e1393.png"></p><p>平衡二叉树的插入和删除动作后，要比较二叉树的左右树的高度差是否等于2，如果等于2则需要旋转二叉树。同时调整数的高度参数。</p><p><strong>LL的旋转</strong></p><p><img alt="20200814159738683827680.png" src="/assets/images/20200814159738683827680-5825a5b3da89b96dac7d00f482c0f6af.png"></p><p>图中左边是旋转之前的树，右边是旋转之后的树。从中可以发现，旋转之后的树又变成了AVL树，而且该旋转只需要一次即可完成。
对于LL旋转，你可以这样理解为：LL旋转是围绕&quot;失去平衡的AVL根节点&quot;进行的，也就是节点k2；而且由于是LL情况，即左左情况，就用手抓着&quot;左孩子，即k1&quot;使劲摇。将k1变成根节点，k2变成k1的右子树，&quot;k1的右子树&quot;变成&quot;k2的左子树&quot;。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"> * LL：左左对应的情况(左单旋转)。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"> *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"> * 返回值：旋转后的根节点</span></div><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"> */</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> Node</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">left_left_rotation</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">AVLTree k2</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    AVLTree k1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k1 </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">left</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">left </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">right</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">right </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> k2</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">height </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">MAX</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">HEIGHT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">left</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">HEIGHT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">right</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">height </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">MAX</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">HEIGHT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">left</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">height</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> k1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><strong>RR的旋转</strong></p><p>理解了LL之后，RR就相当容易理解了。RR是与LL对称的情况！RR恢复平衡的旋转方法如下：</p><p><img alt="2020081415973868776965.png" src="/assets/images/2020081415973868776965-ec21bd71817af00fd19af7723eb52c62.png"></p><p>图中左边是旋转之前的树，右边是旋转之后的树。RR旋转也只需要一次即可完成。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"> * RR：右右对应的情况(右单旋转)。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"> *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"> * 返回值：旋转后的根节点</span></div><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"> */</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">static</span><span class="token plain"> Node</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">right_right_rotation</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">AVLTree k1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    AVLTree k2</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k2 </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">right</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">right </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">left</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">left </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> k1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">height </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">MAX</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">HEIGHT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">left</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">HEIGHT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">right</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">height </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">MAX</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">HEIGHT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">k2</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">right</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> k1</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">height</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> k2</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><strong>LR的旋转</strong></p><p>LR失去平衡的情况，需要经过两次旋转才能让AVL树恢复平衡。如下图：</p><p><img alt="20200814159738692073848.png" src="/assets/images/20200814159738692073848-f07e6cd286f4021f2f7ac684c6008521.png"></p><p>第一次旋转是围绕&quot;k1&quot;进行的&quot;RR旋转&quot;，第二次是围绕&quot;k3&quot;进行的&quot;LL旋转&quot;。</p><p>LR的旋转代码</p><p><a href="javascript:void(0);" target="_blank" rel="noopener noreferrer"><img alt="复制代码" src="data:image/gif;base64,R0lGODlhFAAUANQHADJKYpKluc3P05qy4jJdta/M92KQ3vv8/nKi4rK/0rLC6mJ6mtHe7sHN4ZW19iJLmUp2wqKy0nKa8iJCgsLV9uLq8qKywnKa2oKy4lKC0qLC8qKqwnKS0oKn7cDI1AAAACH5BAEAAB8ALAAAAAAUABQAAAWE4CeOZGmeaKquLKkoSRwJrXLch7XQa4IfAc+ud6AUGIHCS+NwME6WX6Xw6xAaps2BiUFofpICwVMK3CoVxuDQZBgIhEf50EVc1rgKJSInmRkMDQ0dBx0IBhkZfGUAjY0cOAwUChZ9KQYHiIkZG5YoEAcRohYbAZ4nEHAPq6sTLa+wsSUhADs="></a></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * LR：左右对应的情况(左双旋转)。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * 返回值：旋转后的根节点</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static Node* left_right_rotation(AVLTree k3)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k3-&gt;left = right_right_rotation(k3-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return left_left_rotation(k3);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><a href="javascript:void(0);" target="_blank" rel="noopener noreferrer"><img alt="复制代码" src="data:image/gif;base64,R0lGODlhFAAUANQHADJKYpKluc3P05qy4jJdta/M92KQ3vv8/nKi4rK/0rLC6mJ6mtHe7sHN4ZW19iJLmUp2wqKy0nKa8iJCgsLV9uLq8qKywnKa2oKy4lKC0qLC8qKqwnKS0oKn7cDI1AAAACH5BAEAAB8ALAAAAAAUABQAAAWE4CeOZGmeaKquLKkoSRwJrXLch7XQa4IfAc+ud6AUGIHCS+NwME6WX6Xw6xAaps2BiUFofpICwVMK3CoVxuDQZBgIhEf50EVc1rgKJSInmRkMDQ0dBx0IBhkZfGUAjY0cOAwUChZ9KQYHiIkZG5YoEAcRohYbAZ4nEHAPq6sTLa+wsSUhADs="></a></p><p><strong>RL的旋转</strong>
RL是与LR的对称情况！RL恢复平衡的旋转方法如下：</p><p><img alt="20200814159738695333743.png" src="/assets/images/20200814159738695333743-65e9cb46074f42d98d55f8d24dbaef98.png"></p><p>第一次旋转是围绕&quot;k3&quot;进行的&quot;LL旋转&quot;，第二次是围绕&quot;k1&quot;进行的&quot;RR旋转&quot;。</p><p>RL的旋转代码</p><p><a href="javascript:void(0);" target="_blank" rel="noopener noreferrer"><img alt="复制代码" src="data:image/gif;base64,R0lGODlhFAAUANQHADJKYpKluc3P05qy4jJdta/M92KQ3vv8/nKi4rK/0rLC6mJ6mtHe7sHN4ZW19iJLmUp2wqKy0nKa8iJCgsLV9uLq8qKywnKa2oKy4lKC0qLC8qKqwnKS0oKn7cDI1AAAACH5BAEAAB8ALAAAAAAUABQAAAWE4CeOZGmeaKquLKkoSRwJrXLch7XQa4IfAc+ud6AUGIHCS+NwME6WX6Xw6xAaps2BiUFofpICwVMK3CoVxuDQZBgIhEf50EVc1rgKJSInmRkMDQ0dBx0IBhkZfGUAjY0cOAwUChZ9KQYHiIkZG5YoEAcRohYbAZ4nEHAPq6sTLa+wsSUhADs="></a></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * RL：右左对应的情况(右双旋转)。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * 返回值：旋转后的根节点</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static Node* right_left_rotation(AVLTree k1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    k1-&gt;right = left_left_rotation(k1-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return right_right_rotation(k1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="伸展树"></a>伸展树<a class="hash-link" href="#伸展树" title="Direct link to heading">#</a></h3><p>伸展树(Splay Tree)是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。它由Daniel Sleator和Robert Tarjan创造。
(01) 伸展树属于二叉查找树，即它具有和二叉查找树一样的性质：假设x为树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。
(02) 除了拥有二叉查找树的性质之外，伸展树还具有的一个特点是：当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。</p><p><strong>假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生，它是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。</strong></p><p>相比于&quot;二叉查找树&quot;和&quot;AVL树&quot;，学习伸展树时需要重点关注是&quot;伸展树的旋转算法&quot;。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="b树"></a>B树<a class="hash-link" href="#b树" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-3树"></a>2-3树<a class="hash-link" href="#2-3树" title="Direct link to heading">#</a></h3><p>2-3树是3阶B树。是B树的一种特例。</p><p><a href="https://zhuanlan.zhihu.com/p/104031183" target="_blank" rel="noopener noreferrer">动画 | 什么是2-3树？</a></p><p><img alt="image-20210620172007365" src="/assets/images/image-20210620172007365-79b8b259e3b202fcb622438b62d26156.png"></p><p><img alt="image-20210620172134893" src="/assets/images/image-20210620172134893-6650349b2a23bfd91f676889f06fd945.png"></p><p>绝对平衡的树：从根节点到任意节点经过的节点数量一定是相同的。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="插入操作"></a>插入操作<a class="hash-link" href="#插入操作" title="Direct link to heading">#</a></h4><p>维持绝对平衡。</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="插入2节点"></a>插入2节点<a class="hash-link" href="#插入2节点" title="Direct link to heading">#</a></h5><p><code>12</code> 插入节点 <code>6</code>形成一个3节点<code>6</code> <code>12</code></p><p><img alt="image-20210620173741039" src="/assets/images/image-20210620173741039-2e0c88df2d203d5ea38e77854f12e770.png"></p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="插入3节点"></a>插入3节点<a class="hash-link" href="#插入3节点" title="Direct link to heading">#</a></h5><h6><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="本身是根节点"></a>本身是根节点<a class="hash-link" href="#本身是根节点" title="Direct link to heading">#</a></h6><p><img alt="image-20210620173815377" src="/assets/images/image-20210620173815377-097e334179ef09d7f2afb1b87fd24cb0.png"></p><h6><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="父节点是2节点"></a>父节点是2节点<a class="hash-link" href="#父节点是2节点" title="Direct link to heading">#</a></h6><p>暂时形成4节点。然后分裂成3个2节点。向上同和</p><p><img alt="image-20210620174035914" src="/assets/images/image-20210620174035914-c61188d88a1881f6694058fa53ed1e23.png"></p><h6><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="父节点是3节点"></a>父节点是3节点<a class="hash-link" href="#父节点是3节点" title="Direct link to heading">#</a></h6><p><img alt="image-20210620173635028" src="/assets/images/image-20210620173635028-64bf3cb5f27787ed4e7910345368255c.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="红黑树"></a>红黑树<a class="hash-link" href="#红黑树" title="Direct link to heading">#</a></h3><p>红黑树的发明人:	Robert Sedgewick
现代计算机科学的前驱:	Donald Knuth</p><p>看算法4的介绍。3.3 平衡查找树。</p><p>java.util中的TreeMap和TreeSet基于红黑树。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="红黑树和2-3树的等价性"></a>红黑树和2-3树的等价性<a class="hash-link" href="#红黑树和2-3树的等价性" title="Direct link to heading">#</a></h4><p>2节点和3节点。</p><p>图：红黑-1</p><p><img alt="image-20210620174940475" src="/assets/images/image-20210620174940475-83013554d4d2afa7e0a5d35951d5d246.png"></p><p>图：红黑-2</p><p><img alt="image-20210620175102655" src="/assets/images/image-20210620175102655-e887ca0f9232c4a9c30826efcbd4a020.png"></p><p>图：红黑-3</p><p><img alt="image-20210620175111204" src="/assets/images/image-20210620175111204-7aeb34aa1bdb1b4fc6970aa411aed22a.png"></p><p> 红黑树红色的节点和其父亲节点一起等价为2-3树的3节点。</p><p>啊2-3树添加一个元素的时候，总是先和某个叶子节点先融合。 所以先设置为红色。</p><p>算法导论中的红黑树：</p><ol><li><p>每个节点或者是红色的，或者是黑色的</p></li><li><p>根节点是黑色的</p><p>2-3树等价性解释：根节点或者是2节点，或者是3节点，2节点是黑色的，3节点，父节点是黑色的。</p></li><li><p>每一个叶子节点（最后的空节点）是黑色的。</p><p>空节点是黑色。（代码判断isRed，如果为空是黑色的）空树也是黑色的。</p></li><li><p>如果一个节点是红色的，那么他的孩子节点都是黑色的。</p><p>2-3树等价性解释：见<code>图：红黑-1</code> 3节点对应，左中右，3个节点的左,中两个节点是红色节点的孩子。孩子要么是2节点那必然是黑色的。要么是3节点，那么分裂后父节点也是黑色的。</p></li><li><p>从任意一个节点到叶子节点，经过的黑色节点是一样的。</p><p>2-3树等价性解释：见<code>图：红黑-2</code> <code>图：红黑-3</code> 2-3树是一颗绝对平衡的树。从根节点到任意节点经过的节点数量一定是相同的。节点要么是2节点，要么是3节点，2节点和3节点都必然对应一个黑节点。</p></li></ol><p>红黑树是保持<code>黑平衡</code>的二叉树。黑节点绝对平衡。</p><p>最大高度2logn。依然是O(logn)</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="和avl的对比"></a>和AVL的对比<a class="hash-link" href="#和avl的对比" title="Direct link to heading">#</a></h4><p> 如果经常进行添加删除操作，红黑树的性能略好。AVL树需要进行频繁的保持平衡的动作。</p><p> 如果经常进行查询操作，AVL的性能好。因为相对而言，AVL的深度更低。</p><p>对于完全随机的数据，普通的二分搜索树很好用！</p><p>缺点：极端情况下退化为链表（或者高度不平衡）</p><p>对于查询较多的使用情况，AVL树很好用。</p><p>红黑树牺牲了平衡性（2logn的高度）</p><p>统计性能更优（综合增删改查所有的操作）</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="插入操作-1"></a>插入操作<a class="hash-link" href="#插入操作-1" title="Direct link to heading">#</a></h4><p>2-3树操作：添加一个新元素</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="添加到2节点，形成3节点"></a>添加到2节点，形成3节点<a class="hash-link" href="#添加到2节点，形成3节点" title="Direct link to heading">#</a></h5><ol><li>添加的是一个根节点</li></ol><p>向上融合的为红色节点，而根节点为黑节点。</p><ol><li>添加到左孩子</li></ol><p>直接添加</p><ol><li>添加到右孩子</li></ol><p><strong>左旋转</strong>。转下来的为红色。</p><p>红黑树，红色节点都是左倾的！</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="添加到3节点，暂时形成一个4节点。"></a>添加到3节点，暂时形成一个4节点。<a class="hash-link" href="#添加到3节点，暂时形成一个4节点。" title="Direct link to heading">#</a></h5><p><img alt="image-20210620220755348" src="/assets/images/image-20210620220755348-587fa06559e2d5abdbf4098b9bc054de.png"></p><ol><li>3节点的右侧</li></ol><p>颜色反转。根变红。</p><ol start="2"><li>3节点的中间</li></ol><p>左旋转</p><p>右旋转</p><p>颜色反转</p><ol start="3"><li>3节点的左侧</li></ol><p>右旋转。转下来的为红色。</p><p>颜色翻转</p><p>2节点的情况，可以归纳到3节点里面。</p><p>总结：</p><ol><li>左旋转</li></ol><p>isRed(node-&gt;right) &amp;&amp; !isRed(node-&gt;left)</p><ol start="2"><li>右旋转</li></ol><p>isRed(node-&gt;left) &amp;&amp; isRed(node-&gt;left-&gt;left)</p><ol start="3"><li>颜色反转</li></ol><p>isRed(node-&gt;left) &amp;&amp; isRed(node-&gt;right)</p><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><p><strong>红黑树的特性</strong>: <strong>（1）每个节点或者是黑色，或者是红色。</strong> <strong>（2）根节点是黑色。</strong> <strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong> <strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</strong> <strong>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p><p><strong>注意</strong>： (01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。 (02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p><p>从理论上看，平衡二叉树和红黑树区别在哪儿？</p><p>平衡二叉树追求的是绝对平衡！也就是说左子树和右子树差值必须小于等于1</p><p>红黑树呢？只需要保证左右子树中的黑色节点数量一致即可。这是赤裸裸的走捷径啊。这只是保证了黑色节点的绝对平衡，红色节点是不考虑的，也就是说左子树和右子树只要满足2倍以内的关系就可以了</p><p>好 ，接下来肯定是要实现了吧</p><p>你要平衡二叉树的绝对平衡应该怎么搞？你要去遍历所有节点，去判断每个节点的左右子树的高度，之后再从这些失衡节点中选取最低的失衡节点。然后再去旋转blablabla。</p><p>你要有节点的parent，left， right， leftHeight， rightheight,level.....反正你自己看吧</p><p>红黑树呢？保证弱平衡即可。每次插入一个red节点，之后只需要看parent节点是不是red再来判断要不要调整</p><p>相比较来看对二叉树进行修改时，红黑树要简单一些。</p><p>个人目前的一点儿看法，也许过一段时间红黑树研究结束后可能会有别的想法也说不定</p><p>先留存下自己的想法</p><p>作者：fanfan 链接：<a href="https://www.zhihu.com/question/27542473/answer/736401344" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/27542473/answer/736401344</a> 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><strong>一.为什么要有红黑树这种数据结构？</strong></p><p>  学过二叉查找树的同学都知道，普通的二叉查找树在极端情况下可退化成链表，此时的增删查O(n)效率都会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如 AVL。</p><p>　ALV树是一种严格按照定义来实现的平衡二叉查找树，所以它查找的效率非常稳定，为O(log n),由于其严格按照左右子树高度差不大于1的规则，插入和删除操作中需要大量且复杂的操作来保持ALV树的平衡（左旋和右旋），因此ALV树适用于大量查询，少量插入和删除的场景中。</p><p> 现在假设有这样一种场景：大量查询，插入和删除，使用ALV树就不太合适了，因为ALV树大量的插入和删除会非常耗时间，那么我们是否可以降低ALV树对平衡性的要求从而达到快速的插入和删除呢？</p><p> 答案肯定是有的，红黑树这种数据结构就应运而生了（因为ALV树是高度平衡的，所以查找起来肯定比红黑树快，但是红黑树在插入和删除方面的性能就远远不是ALV树所能比的了）。</p><p>当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成（性质4限定了不能出现两个连续的红色节点）。而性质5又限定了从任一节点到其每个叶子节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上红色节点数量 = 黑色节点数量。该路径长度为两倍黑色节点数量，也就是最短路径长度的2倍。举例说明一下，请看下图：</p><p><img alt="20200814159739023759045.png" src="/assets/images/20200814159739023759045-f484993df4ee07700c02d5eba6dd2cc7.png"></p><p><strong>注意红黑树的左旋和右旋和二叉平衡树的RR，LL，RL，LR旋转是不一样的</strong> 概念不要搞混了。</p><p>旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子。这话听起来有点绕，所以还是请看下图：</p><p><img alt="20200814159739050524685.png" src="/assets/images/20200814159739050524685-175a4cfaf055315f3132859fdfbd385e.png"></p><p>上图包含了左旋和右旋的示意图，这里以右旋为例进行说明，右旋节点 M 的步骤如下：</p><ol><li>将节点 M 的左孩子引用指向节点 E 的右孩子</li><li>将节点 E 的右孩子引用指向节点 M，完成旋转</li></ol><p><strong>四.红黑树的基本操作之添加元素</strong></p><p> 红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。性质1规定红黑树节点的颜色要么是红色要么是黑色，那么在插入新节点时，这个节点应该是红色还是黑色呢？答案是红色，原因也不难理解。如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。</p><p>　现在我们来分析一下新增的节点（红色）插入之后可能面临的几种情况，以及他们的处理措施：</p><p>1.插入的节点为根节点</p><p>　新插入的红色节点变成黑色节点，满足根节点为黑色节点的要求</p><p>2.父亲节点为黑色节点</p><p>　这个时候不需要进行任何调整操作，此时的树仍然是一颗标准的红黑树</p><p>3.父亲节点为红色节点的情况下，叔叔节点为红色节点（不用考虑左右）</p><p>　解决方案：将叔叔和父亲节点改为黑色，爷爷节点改为红色，然后又将爷爷节点当作插入节点看待，一直进行上面的操作，直到当前节点为根节点，然后将根节点变成黑色</p><p><img alt="20200814159739093947251.png" src="/assets/images/20200814159739093947251-441c1c2aa1215113b415b5a7cfcb7e6b.png"></p><p>4.父亲节点为红色，叔叔节点为黑色</p><p>1）父亲节点为爷爷节点的左孩子，新插入节点为父节点的左孩子（左左）</p><p>　解决方案：将父亲节点和爷爷节点颜色互换（父节点变为黑色，爷爷节点变为红色），然后对爷爷节点进行一次右旋</p><p><img alt="20200814159739095991843.png" src="/assets/images/20200814159739095991843-fd6066698701c913b29c04e621f2a1a7.png"></p><p>　注：上图叔叔是空叶子节点，所以也是黑色</p><p>2）父亲节点为爷爷节点的右孩子，新插入节点为父节点的右孩子（右右）</p><p>　解决方案：将父亲节点和爷爷节点颜色互换（父节点变为黑色，爷爷节点变为红色），然后对爷爷节点进行一次左旋</p><p><img alt="20200814159739099138031.png" src="/assets/images/20200814159739099138031-0215ba4f81cc4cd5e406d8eae293bfd7.png"></p><p>3）父亲节点为爷爷节点的左孩子，新插入节点为父节点的右孩子（左右）</p><p>　解决方案：对父亲节点进行一次左旋，然后就变成了情况1，按照情况1再进行处理</p><p><img alt="20200814159739108324468.png" src="/assets/images/20200814159739108324468-7ec8a7cf0b2dea78515b71aa791b26c6.png"></p><p>4）父亲节点为爷爷节点的右孩子，新插入节点为父节点的左孩子（右左）</p><p>　解决方案：对父亲节点进行一次右旋，然后就变成了情况2，按照情况2再进行处理</p><p><img alt="20200814159739110123402.png" src="/assets/images/20200814159739110123402-73446b03cbbedc6ee0ffb1c28066fd5b.png"></p><p>参考：<a href="https://www.cnblogs.com/panda28/p/11132462.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/panda28/p/11132462.html</a></p><p><strong>五.红黑树的基本操作之删除元素</strong></p><p> 相较于插入操作，红黑树的删除操作则要更为复杂一些。删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的前驱（该节点左子树中最大的节点）或者后继（该节点右子树中最小的节点），然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。由于前驱和后继至多只有一个孩子节点，这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，问题被简化了一些。</p><p>删除一个节点有以下四种情况：</p><p>　1.删除的节点没有孩子</p><p>　2.删除的节点只有左子树</p><p>  3.删除的节点只有右子树</p><p>  *4.删除的节点拥有左子树和右子树</p><p>　其实只有上面前三种情况，对于第四种情况，可以找到待删除节点的直接后继节点，用这个节点的值替代待删除节点，接着情况转变为删除这个直接后继节点，情况也变为前三种之一。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="伸展树-splay-tree"></a>伸展树-Splay Tree<a class="hash-link" href="#伸展树-splay-tree" title="Direct link to heading">#</a></h3><p>伸展树(Splay Tree)是一种二叉排序树，它能在O(log n)内完成插入、查找和删除操作。它由Daniel Sleator和Robert Tarjan创造。
(01) 伸展树属于二叉查找树，即它具有和二叉查找树一样的性质：假设x为树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。
(02) 除了拥有二叉查找树的性质之外，伸展树还具有的一个特点是：当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。</p><p><strong>假设想要对一个二叉查找树执行一系列的查找操作。为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生，它是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。</strong></p><p>相比于&quot;二叉查找树&quot;和&quot;AVL树&quot;，学习伸展树时需要重点关注是&quot;伸展树的旋转算法&quot;。</p><p>统计新能很优秀。局部性原理：刚被访问的内容下次高概率再次被访问。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="trie-字典树-前缀树"></a>trie-字典树-前缀树<a class="hash-link" href="#trie-字典树-前缀树" title="Direct link to heading">#</a></h3><p>Trie 树的核心思想是空间换时间。 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><p><img alt="image-20211005171342310" src="/assets/images/image-20211005171342310-18c4cc2b2344b412bc0dc54ec5088f7c.png"></p><p><img alt="image-20211005171501736" src="/assets/images/image-20211005171501736-e76c54e802fd9b1c995fc188530db4c3.png"></p><p><img alt="image-20211118091937692" src="/assets/images/image-20211118091937692-41ce9bc371b2229a6de9d78993d6ad7c.png"></p><p>tree 和trie的区别和联系</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Tree{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Tree *left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Tree *right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int val;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Trie{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;Trie *&gt; children;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bool isEnd;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//二叉Tree发散为两个节点，而Trie 可以发散为n个节点！</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="练习"></a>练习<a class="hash-link" href="#练习" title="Direct link to heading">#</a></h4><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" disabled=""> <a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener noreferrer">208. 实现 Trie (前缀树)</a></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="练习-1"></a>练习<a class="hash-link" href="#练习-1" title="Direct link to heading">#</a></h4><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener noreferrer">208. 实现 Trie (前缀树)</a></p><p><a href="https://leetcode-cn.com/submissions/detail/239746470/" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/submissions/detail/239746470/</a></p><p><a href="https://leetcode-cn.com/submissions/detail/239748423/" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/submissions/detail/239748423/</a></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Trie {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //children[0]表示a，children[1]表示b,依次类推，切记，不用直接明示a,b,c</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;Trie *&gt; children;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bool isEnd;//标记是否是end，字符串结尾</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //找到前置最后的节点</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Trie *startsPrefix(string prefix) {        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //固定套路：1：初始条件设置</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Trie *node = this;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //固定套路：4：设置好出循环体的条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(char ch : prefix) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //固定套路：2：进入循环体处理当前逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ch -= &#x27;a&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(node-&gt;children[ch] == nullptr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return nullptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //固定套路：3：进入下个循环体，设置对应的初始条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            node = node-&gt;children[ch];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return node;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Trie():children(26), isEnd(false) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //理解：节点本身并不存储字符，每个节点26个分叉，那个分叉代表到对应的字符信息</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void insert(string word) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //遍历word的每一个字符，如果不存在，则插入新节点，知道word遍历完成</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Trie *node = this;//1.确定初始条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(char ch : word) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //2.进入重复体处理当前层逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ch -= &#x27;a&#x27;;//将字母转化为下标</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(node-&gt;children[ch] == nullptr) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                node-&gt;children[ch] = new Trie();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }            </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //3.递推。进入下一层</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            node = node-&gt;children[ch];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //插入完成之后设置结尾为true（默认为false）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        node-&gt;isEnd = true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bool search(string word) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //遍历每一个字符，如果存在继续，如果不存在返回false，直到word遍历完成,trie也没有后续节点才算成功返回true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Trie *node = this-&gt;startsPrefix(word);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return node != nullptr &amp;&amp; node-&gt;isEnd;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //遍历每一个字符，如果存在继续，如果不存在返回false，直到word遍历完成,返回true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bool startsWith(string prefix) {        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Trie *node = this-&gt;startsPrefix(prefix);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return node != nullptr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * Your Trie object will be instantiated and called as such:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * Trie* obj = new Trie();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * obj-&gt;insert(word);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * bool param_2 = obj-&gt;search(word);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * bool param_3 = obj-&gt;startsWith(prefix);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="霍夫曼树带权路径"></a>霍夫曼树(带权路径)<a class="hash-link" href="#霍夫曼树带权路径" title="Direct link to heading">#</a></h3><p>霍夫曼编码-通过最少的编码量获得最大的信息量。</p><p><strong>定义</strong>：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。</p><ul><li>路径和路径长度</li></ul><blockquote><p><strong>定义</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p></blockquote><ul><li>结点的权及带权路径长度</li></ul><blockquote><p><strong>定义</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p></blockquote><ul><li>树的带权路径长度</li></ul><blockquote><p><strong>定义</strong>：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。</p></blockquote><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为：</p><blockquote><p><strong>1</strong>. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；
<strong>2</strong>. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
<strong>3</strong>. 从森林中删除选取的两棵树，并将新树加入森林；
<strong>4</strong>. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</p></blockquote><p><img alt="20200814159739243049720.png" src="/assets/images/20200814159739243049720-2109d624eb05022178afc4d9de4d3a6b.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="二叉堆"></a>二叉堆<a class="hash-link" href="#二叉堆" title="Direct link to heading">#</a></h3><p>堆(heap)，这里所说的堆是数据结构中的堆，而不是内存模型中的堆。堆通常是一个可以被看做一棵树，它满足下列性质：
[<strong>性质一</strong>] 堆中任意节点的值总是不大于(不小于)其子节点的值；
[<strong>性质二</strong>] 堆总是一棵完全树。
将任意节点不大于其子节点的堆叫做最小堆或小根堆，而将任意节点不小于其子节点的堆叫做最大堆或大根堆。常见的堆有二叉堆、左倾堆、斜堆、二项堆、斐波那契堆等等。</p><p><a href="https://blog.csdn.net/lalu58/article/details/53954465" target="_blank" rel="noopener noreferrer">数据结构::堆及堆的应用~</a></p><p>有限制的数组操作。</p><p>插入只能放到最后一个，删除只能删除第一个。</p><p><strong>二叉堆的定义</strong></p><p>二叉堆是<strong>完全二元树</strong>或者是近似完全二元树，它分为两种：最大堆和最小堆。
最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。示意图如下：</p><p><img alt="2020071015943614235603.jpg" src="/assets/images/2020071015943614235603-90b16b78b4aa99f29e139af6e0b4b38f.jpg"></p><p>二叉堆一般都通过&quot;数组&quot;来实现。数组实现的二叉堆，父节点和子节点的位置存在一定的关系。有时候，我们将&quot;二叉堆的第一个元素&quot;放在数组索引0的位置，有时候放在1的位置。当然，它们的本质一样(都是二叉堆)，只是实现上稍微有一丁点区别。
假设&quot;第一个元素&quot;在数组中的索引为 0 的话，则父节点和子节点的位置关系如下：
(01) 索引为i的左孩子的索引是 (2<em>i+1);
(02) 索引为i的左孩子的索引是 (2</em>i+2);
(03) 索引为i的父结点的索引是 floor((i-1)/2);</p><p>假设&quot;第一个元素&quot;在数组中的索引为 1 的话，则父节点和子节点的位置关系如下：
(01) 索引为i的左孩子的索引是 (2<em>i);
(02) 索引为i的左孩子的索引是 (2</em>i+1);
(03) 索引为i的父结点的索引是 floor(i/2);</p><p>二叉堆的核心是&quot;添加节点&quot;和&quot;删除节点&quot;，理解这两个算法，二叉堆也就基本掌握了。</p><ul><li>添加节点</li></ul><p><em>当向最大堆中添加数据时：先将数据加入到最大堆的最后，然后尽可能把这个元素往上挪，直到挪不动为止！</em></p><p>保存要挪动的点，向上寻找其父元素。</p><ul><li>删除节点</li></ul><p><em>最大堆中删除数据时：先删除该数据，然后用最大堆中最后一个的元素插入这个空位；接着，把这个“空位”尽量往上挪，直到剩余的数据变成一个最大堆。</em></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="replace和heapily"></a>Replace和Heapily<a class="hash-link" href="#replace和heapily" title="Direct link to heading">#</a></h4><ul><li>Replace</li></ul><p>将堆中的最大值替换为某个值。</p><ul><li>Heapily</li></ul><p>复杂度：O(n) </p><p>将任意数组转换为堆。</p><p>找到最后一个非叶子节点。往前依次shiftdown</p><p>将n个元素逐个插入的复杂度是n*logn</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="左倾堆"></a>左倾堆<a class="hash-link" href="#左倾堆" title="Direct link to heading">#</a></h3><p>左倾堆(leftist tree 或 leftist heap)，又被成为左偏树、左偏堆，最左堆等。
它和二叉堆一样，都是<strong>优先队列</strong>实现方式。当优先队列中涉及到<strong>&quot;对两个优先队列进行合并&quot;</strong>的问题时，二叉堆的效率就无法令人满意了，而本文介绍的左倾堆，则可以很好地解决这类问题。</p><p><strong>左倾堆的定义</strong></p><p>左倾堆是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针外，还有两个属性：<strong>键值</strong>和<strong>零距离</strong>。
(01) 键值的作用是来比较节点的大小，从而对节点进行排序。
(02) 零距离(英文名NPL，即Null Path Length)则是从一个节点到一个&quot;最近的不满节点&quot;的路径长度。不满节点是指该该节点的左右孩子至少有有一个为NULL。叶节点的NPL为0，NULL节点的NPL为-1。</p><p>理解<code>null path length (npl)</code></p><p><img alt="20200710159436822665929.png" src="/assets/images/20200710159436822665929-a03806efc4c74b68e9c865fa243c22fb.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="斜堆"></a>斜堆<a class="hash-link" href="#斜堆" title="Direct link to heading">#</a></h3><p>斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种。和左倾堆一样，它通常也用于实现优先队列。它的合并操作的时间复杂度也是O(lg n)。</p><p>相比于<a href="http://www.cnblogs.com/skywang12345/p/3638327.html" target="_blank" rel="noopener noreferrer">左倾堆</a>，斜堆的节点没有&quot;零距离&quot;这个属性。除此之外，它们斜堆的合并操作也不同。斜堆的合并操作算法如下：
(01) 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。
(02) 如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将&quot;较小堆的根节点的右孩子&quot;和&quot;较大堆&quot;进行合并。
(03) 合并后，交换新堆根节点的左孩子和右孩子。
第(03)步是斜堆和左倾堆的合并操作差别的关键所在，如果是左倾堆，则合并后要比较左右孩子的零距离大小，若右孩子的零距离 &gt; 左孩子的零距离，则交换左右孩子；最后，在设置根的零距离。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="斐波那契堆"></a>斐波那契堆<a class="hash-link" href="#斐波那契堆" title="Direct link to heading">#</a></h3><p>斐波那契堆(Fibonacci heap)是堆中一种，它和二项堆一样，也是一种可合并堆；可用于实现合并优先队列。斐波那契堆比二项堆具有更好的平摊分析性能，它的合并操作的时间复杂度是O(1)。
与二项堆一样，它也是由一组堆最小有序树组成，并且是一种可合并堆。
与二项堆不同的是，斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的，但是斐波那契堆中的树都是<strong>有根而无序</strong>的。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="并查集"></a>并查集<a class="hash-link" href="#并查集" title="Direct link to heading">#</a></h3><p>网络节点之间的连接问题和路径问题。比路径问题要回答的问题少。</p><p>主要支持两个动作：</p><ol><li>并：union(p, q)</li><li>查：isConnected(p,q)</li></ol><p>结构上是孩子指向父亲节点。的多叉树。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="线段树"></a>线段树<a class="hash-link" href="#线段树" title="Direct link to heading">#</a></h3><p>为甚要使用线段树？</p><p>实质：基于区间的统计查询。</p><p>2017年注册用户中消费最高的用户？消费最少的用户？学习时间最长的用户？</p><p>某个太空区间中的天体总量？</p><table><thead><tr><th></th><th>数组</th><th>线段树</th></tr></thead><tbody><tr><td>更新</td><td>O(n)</td><td>O(logn)</td></tr><tr><td>查询</td><td>O(n)</td><td>O(logn)</td></tr></tbody></table><p><img alt="image-20211005170904946" src="/assets/images/image-20211005170904946-d633febbd22bd71a434fe10d28641c90.png"></p><p>数组表示：</p><p><img alt="image-20211005171158860" src="/assets/images/image-20211005171158860-5a456263bd3a7d6498a9a0993763954c.png"></p><p><img alt="image-20211005171053812" src="/assets/images/image-20211005171053812-6de43b595e90b1ecd7cef8c6dc48c03c.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="kd树"></a>KD树<a class="hash-link" href="#kd树" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="区间树"></a>区间树<a class="hash-link" href="#区间树" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="哈夫曼树"></a>哈夫曼树<a class="hash-link" href="#哈夫曼树" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="图"></a>图<a class="hash-link" href="#图" title="Direct link to heading">#</a></h2><p><strong>图的定义</strong></p><p>定义：图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为&quot;顶点(vertex)&quot;，而点与点之间的连线则被成为&quot;边或弧&quot;(edege)。通常记为，G=(V,E)。</p><p><strong>图的种类</strong></p><p>根据边是否有方向，将图可以划分为：<strong>无向图</strong>和<strong>有向图</strong>。（无向图可以看做是特殊的有向图）</p><p>根据边是权重，将图可以划分为：<strong>无权图</strong>和<strong>有权图</strong>。（经典算法都是基于有权图的）</p><p>简单图：自环边，平行边</p><p><strong>2.1 无向图</strong></p><p><img alt="20200713159461000481476.jpg" src="/assets/images/20200713159461000481476-32ac0da11e543fad206fc3336e9640ce.jpg"></p><p>上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，</p><p><strong>(01)</strong> V1={A,B,C,D,E,F}。 V1表示由&quot;A,B,C,D,E,F&quot;几个顶点组成的集合。
<strong>(02)</strong> E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)...等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。</p><p><strong>2.2 有向图</strong></p><p><img alt="20200713159461003729867.jpg" src="/assets/images/20200713159461003729867-ca71d8a3b0421aa5aacb64b7b8b39296.jpg"></p><p>上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中，</p><p><strong>(01)</strong> V2={A,C,B,F,D,E,G}。 V2表示由&quot;A,B,C,D,E,F,G&quot;几个顶点组成的集合。
<strong>(02)</strong> A2={&lt;A,B&gt;,&lt;B,C&gt;,&lt;B,F&gt;,&lt;B,E&gt;,&lt;C,E&gt;,&lt;E,D&gt;,&lt;D,C&gt;,&lt;E,B&gt;,&lt;F,G&gt;}。 E1是由矢量&lt;A,B&gt;,矢量&lt;B,C&gt;...等等组成的集合。其中，矢量&lt;A,B)表示由&quot;顶点A&quot;指向&quot;顶点C&quot;的有向边。</p><p><strong>邻接点，入边和出边</strong></p><p>一条边上的两个顶点叫做邻接点。
<em>例如，上面无向图G0中的顶点A和顶点C就是邻接点。</em></p><p>在有向图中，除了邻接点之外；还有&quot;入边&quot;和&quot;出边&quot;的概念。
顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。
<em>例如，上面有向图G2中的B和E是邻接点；是B的出边，还是E的入边。</em></p><p><strong>度，入度和出度</strong></p><p>在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。
<em>例如，上面无向图G0中顶点A的度是2。</em></p><p>在有向图中，度还有&quot;入度&quot;和&quot;出度&quot;之分。
某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。
顶点的度=入度+出度。
<em>例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。</em></p><p><strong>路径</strong>：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。
<strong>路径长度</strong>：路径中&quot;边的数量&quot;。
<strong>简单路径</strong>：若一条路径上顶点不重复出现，则是简单路径。
<strong>回路</strong>：若路径的第一个顶点和最后一个顶点相同，则是回路。
<strong>简单回路</strong>：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。</p><p><strong>连通图</strong>：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。</p><p><strong>连通分量</strong>：非连通图中的各个连通子图称为该图的连通分量。</p><p>在学习&quot;哈夫曼树&quot;的时候，了解过&quot;权&quot;的概念。图中权的概念与此类似。</p><p><img alt="20200713159461119262420.jpg" src="/assets/images/20200713159461119262420-514932d13eaa7511fabf27c7e56cea89.jpg"></p><p>上面就是一个带权的图。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="图的存储结构"></a><strong>图的存储结构</strong><a class="hash-link" href="#图的存储结构" title="Direct link to heading">#</a></h3><p>上面了解了&quot;图的基本概念&quot;，下面开始介绍图的存储结构。图的存储结构，常用的是&quot;<strong>邻接矩阵</strong>&quot;和&quot;<strong>邻接表</strong>&quot;。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="1-邻接矩阵"></a><strong>1. 邻接矩阵</strong><a class="hash-link" href="#1-邻接矩阵" title="Direct link to heading">#</a></h4><p>邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。
假设图中顶点数为n，则邻接矩阵定义为：</p><p><img alt="20200713159461152124204.png" src="/assets/images/20200713159461152124204-ec2f554beaf3711b8e2a10162a1570a4.png"></p><p>下面通过示意图来进行解释。</p><p><img alt="20200713159461156990635.png" src="/assets/images/20200713159461156990635-667f5c901c07152fc9c7e9a2c1ad975d.png"></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p><img alt="20200713159461162361430.png" src="/assets/images/20200713159461162361430-85d36d34f83dbfc2fdc7ffdae4ce6bfe.png"></p><p>图中的G2是无有图和它对应的邻接矩阵。</p><p>通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。
邻接矩阵的缺点就是比较耗费空间。</p><p>注意：</p><p>往往需要将组成图的顶点，转化成对应的数组<strong>下标</strong>。（这个转换往往用hash表。）</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-邻接表"></a><strong>2. 邻接表</strong><a class="hash-link" href="#2-邻接表" title="Direct link to heading">#</a></h4><p>邻接表是图的一种链式存储表示方法。它是改进后的&quot;邻接矩阵&quot;，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。</p><p><img alt="20200713159461167234442.png" src="/assets/images/20200713159461167234442-62f96ae1861f7c763135e51d4a18a91e.png"></p><p>图中的G1是无向图和它对应的邻接矩阵。</p><p><img alt="20200713159461169982581.png" src="/assets/images/20200713159461169982581-5a314d7edf8263cf3450e11d168723b9.png"></p><p>图中的G2是有向图和它对应的邻接矩阵。</p><p>总结：</p><ul><li>邻接表适合稀疏图。</li><li>邻接矩阵适合稠密图。</li></ul><p>稀疏和稠密是顶点和边的相对关系。</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="dys-typora-open://mine/survival/docs/编程基础/数据结构与算法/数据结构.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/编程基础/数据结构与算法/数据结构与算法"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 数据结构与算法</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/编程基础/数据结构与算法/算法"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">算法 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#内存角度" class="table-of-contents__link">内存角度</a><ul><li><a href="#内存连续" class="table-of-contents__link">内存连续</a></li><li><a href="#内存不连续" class="table-of-contents__link">内存不连续</a></li></ul></li><li><a href="#高层数据结构抽象数据结构" class="table-of-contents__link">高层数据结构/抽象数据结构</a><ul><li><a href="#sequence-containers、序列容器、线性表" class="table-of-contents__link">Sequence containers、序列容器、线性表</a></li><li><a href="#associative-containers、关联容器" class="table-of-contents__link">Associative containers、关联容器</a></li><li><a href="#unordered-associative-containers、无序关联容器" class="table-of-contents__link">Unordered associative containers、无序关联容器</a></li><li><a href="#container-adaptors、容器适配器" class="table-of-contents__link">Container adaptors、容器适配器</a></li></ul></li><li><a href="#底层数据结构" class="table-of-contents__link">底层数据结构</a></li><li><a href="#线性结构" class="table-of-contents__link">线性结构</a><ul><li><a href="#数组" class="table-of-contents__link">数组</a></li><li><a href="#单链表" class="table-of-contents__link">单链表</a></li><li><a href="#双链表" class="table-of-contents__link">双链表</a></li><li><a href="#循环链表" class="table-of-contents__link">循环链表</a></li><li><a href="#数组链表" class="table-of-contents__link">数组链表</a></li><li><a href="#哈希表" class="table-of-contents__link">哈希表</a></li></ul></li><li><a href="#树形结构" class="table-of-contents__link">树形结构</a><ul><li><a href="#二叉查找树-bst" class="table-of-contents__link">二叉查找树-BST</a></li><li><a href="#二叉平衡树（avl树）" class="table-of-contents__link">二叉平衡树（AVL树）</a></li><li><a href="#伸展树" class="table-of-contents__link">伸展树</a></li><li><a href="#b树" class="table-of-contents__link">B树</a></li><li><a href="#2-3树" class="table-of-contents__link">2-3树</a></li><li><a href="#红黑树" class="table-of-contents__link">红黑树</a></li><li><a href="#伸展树-splay-tree" class="table-of-contents__link">伸展树-Splay Tree</a></li><li><a href="#trie-字典树-前缀树" class="table-of-contents__link">trie-字典树-前缀树</a></li><li><a href="#霍夫曼树带权路径" class="table-of-contents__link">霍夫曼树(带权路径)</a></li><li><a href="#二叉堆" class="table-of-contents__link">二叉堆</a></li><li><a href="#左倾堆" class="table-of-contents__link">左倾堆</a></li><li><a href="#斜堆" class="table-of-contents__link">斜堆</a></li><li><a href="#斐波那契堆" class="table-of-contents__link">斐波那契堆</a></li><li><a href="#并查集" class="table-of-contents__link">并查集</a></li><li><a href="#线段树" class="table-of-contents__link">线段树</a></li><li><a href="#kd树" class="table-of-contents__link">KD树</a></li><li><a href="#区间树" class="table-of-contents__link">区间树</a></li><li><a href="#哈夫曼树" class="table-of-contents__link">哈夫曼树</a></li></ul></li><li><a href="#图" class="table-of-contents__link">图</a><ul><li><a href="#图的存储结构" class="table-of-contents__link"><strong>图的存储结构</strong></a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.e736442d.js"></script>
<script src="/runtime~main.500606b1.js"></script>
<script src="/main.e34cadf8.js"></script>
<script src="/1.3353372a.js"></script>
<script src="/256.3f6603bc.js"></script>
<script src="/257.427a7301.js"></script>
<script src="/935f2afb.0ee8c40a.js"></script>
<script src="/255.24175022.js"></script>
<script src="/903e518c.84a82064.js"></script>
</body>
</html>