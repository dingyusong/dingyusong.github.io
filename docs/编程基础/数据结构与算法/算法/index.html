<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Blog Atom Feed"><title data-react-helmet="true">算法 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="算法 | My Site"><meta data-react-helmet="true" name="description" content="算法"><meta data-react-helmet="true" property="og:description" content="算法"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/编程基础/数据结构与算法/算法"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/编程基础/数据结构与算法/算法"><link rel="stylesheet" href="/styles.8cfbcdec.css">
<link rel="preload" href="/styles.e736442d.js" as="script">
<link rel="preload" href="/runtime~main.500606b1.js" as="script">
<link rel="preload" href="/main.e34cadf8.js" as="script">
<link rel="preload" href="/1.3353372a.js" as="script">
<link rel="preload" href="/256.3f6603bc.js" as="script">
<link rel="preload" href="/257.427a7301.js" as="script">
<link rel="preload" href="/935f2afb.0ee8c40a.js" as="script">
<link rel="preload" href="/255.24175022.js" as="script">
<link rel="preload" href="/d3e91d0c.b03a8b69.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/编程基础/编程基础/编程基础">编程基础</a><a class="navbar__item navbar__link" href="/docs/编程语言/编程语言">编程语言</a><a class="navbar__item navbar__link" href="/docs/工具/常用工具">工具</a><a class="navbar__item navbar__link" href="/docs/应用开发/应用开发">应用开发</a><a class="navbar__item navbar__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a><a class="navbar__item navbar__link" href="/docs/音视频/音视频">音视频</a><a class="navbar__item navbar__link" href="/docs/项目/项目">项目</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Search" aria-label="Search" class="navbar__search-input search-bar"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/编程基础/编程基础/编程基础">编程基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程语言/编程语言">编程语言</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/工具/常用工具">工具</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/应用开发/应用开发">应用开发</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/音视频/音视频">音视频</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/项目/项目">项目</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/编程基础/编程基础">编程基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/学习经验/学习经验">学习经验</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">数字电路</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数字电路/数字电路">数字电路</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">计算机组成原理</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机组成原理">计算机组成原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机是怎么跑起来的">计算机是怎么跑起来的</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机系统基础">计算机系统基础</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">操作系统</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/操作系统/操作系统">操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/操作系统/Unix系统管理">Unix系统管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/操作系统/Unix环境编程">Unix环境编程</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机网络/计算机网络">计算机网络</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机系统基础/计算机系统基础">计算机系统基础</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">编译链接调试</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/编译原理/编译原理">编译原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/编译原理/程序员的自我修养">程序员的自我修养</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">数据结构与算法</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/编程基础/数据结构与算法/数据结构与算法">数据结构与算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/编程基础/数据结构与算法/数据结构">数据结构</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/编程基础/数据结构与算法/算法">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/编程基础/数据结构与算法/算法面试">算法面试</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/设计模式/设计模式">设计模式</a></li></ul></div></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">算法</h1></header><div class="markdown"><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="算法"></a>算法<a class="hash-link" href="#算法" title="Direct link to heading">#</a></h1><p>[toc]</p><p>每个细分领域都是算法。</p><p>图形学，图像学，机器学习，人工智能，数据挖掘，操作系统，编译原理，网络安全，高性能计算。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第一章：当我们在讨论算法的时候，我们在讨论什么？"></a>第一章：当我们在讨论算法的时候，我们在讨论什么？<a class="hash-link" href="#第一章：当我们在讨论算法的时候，我们在讨论什么？" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="1-1-我们究竟为什么要学习算法"></a>1-1 我们究竟为什么要学习算法<a class="hash-link" href="#1-1-我们究竟为什么要学习算法" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第二章：排序基础"></a>第二章：排序基础<a class="hash-link" href="#第二章：排序基础" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-1-选择排序法"></a>2-1 选择排序法<a class="hash-link" href="#2-1-选择排序法" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-2-使用模板（泛型）编写算法"></a>2-2 使用模板（泛型）编写算法<a class="hash-link" href="#2-2-使用模板（泛型）编写算法" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-3-随机生成算法测试用例"></a>2-3 随机生成算法测试用例<a class="hash-link" href="#2-3-随机生成算法测试用例" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-4-测试算法的性能"></a>2-4 测试算法的性能<a class="hash-link" href="#2-4-测试算法的性能" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-5-插入排序法"></a>2-5 插入排序法<a class="hash-link" href="#2-5-插入排序法" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-6-插入排序法的改进"></a>2-6 插入排序法的改进<a class="hash-link" href="#2-6-插入排序法的改进" title="Direct link to heading">#</a></h3><p>提前终止内层循环。</p><p>近乎有序的。</p><p>例如： 出错了几个的系统日志。 </p><p>近乎有序的排序中，使用插入排序比较合适。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-7-更多关于o（n2）排序算法的思考"></a>2-7 更多关于O（n*2）排序算法的思考<a class="hash-link" href="#2-7-更多关于o（n2）排序算法的思考" title="Direct link to heading">#</a></h3><p>为什么要学习O(n^2)的排序算法？</p><p>编码简单 ，易于实现，是一些简单情景的首选</p><p>在一些特殊情况下，简单的排序算法更有效</p><p>简单的排序算法衍生出复杂的排序算法</p><p>作为子过程，改进更复杂的排序算法</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第三章：高级排序问题"></a>第三章：高级排序问题<a class="hash-link" href="#第三章：高级排序问题" title="Direct link to heading">#</a></h2><p>O(n*n)是排序算法的初级入门，不太好。</p><p>O(nlogn)是排序算法比较优的解。也算是最优的解。</p><p><img alt="image-20211005213657840" src="/assets/images/image-20211005213657840-68a7422ba99c6611b4c1745bc496f1a9.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-1-归并排序法"></a>3-1 归并排序法<a class="hash-link" href="#3-1-归并排序法" title="Direct link to heading">#</a></h3><p>需要用到辅助空间</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-2-归并排序法的实现"></a>3-2 归并排序法的实现<a class="hash-link" href="#3-2-归并排序法的实现" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-3-归并排序法的优化"></a>3-3 归并排序法的优化<a class="hash-link" href="#3-3-归并排序法的优化" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-4-自底向上的归并排序算法"></a>3-4 自底向上的归并排序算法<a class="hash-link" href="#3-4-自底向上的归并排序算法" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-5-快速排序法"></a>3-5 快速排序法<a class="hash-link" href="#3-5-快速排序法" title="Direct link to heading">#</a></h3><p><img alt="image-20211005213921257" src="/assets/images/image-20211005213921257-2c3a185da542b9248c915aef3b59013e.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-6-随机化快速排序法"></a>3-6 随机化快速排序法<a class="hash-link" href="#3-6-随机化快速排序法" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-7-双路快速排序法"></a>3-7 双路快速排序法<a class="hash-link" href="#3-7-双路快速排序法" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-8-三路快速排序法"></a>3-8 三路快速排序法<a class="hash-link" href="#3-8-三路快速排序法" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-9-归并排序和快速排序的衍生问题"></a>3-9 归并排序和快速排序的衍生问题<a class="hash-link" href="#3-9-归并排序和快速排序的衍生问题" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第四章：堆和堆排序"></a>第四章：堆和堆排序<a class="hash-link" href="#第四章：堆和堆排序" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-1-为什么使用堆"></a>4-1 为什么使用堆<a class="hash-link" href="#4-1-为什么使用堆" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-2-堆的基本存储"></a>4-2 堆的基本存储<a class="hash-link" href="#4-2-堆的基本存储" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-3-shift-up"></a>4-3 Shift Up<a class="hash-link" href="#4-3-shift-up" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-4-shift-down"></a>4-4 Shift Down<a class="hash-link" href="#4-4-shift-down" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-5-基础堆排序和heapify"></a>4-5 基础堆排序和Heapify<a class="hash-link" href="#4-5-基础堆排序和heapify" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-6-优化的堆排序"></a>4-6 优化的堆排序<a class="hash-link" href="#4-6-优化的堆排序" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-7-排序算法总结"></a>4-7 排序算法总结<a class="hash-link" href="#4-7-排序算法总结" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-8-索引堆"></a>4-8 索引堆<a class="hash-link" href="#4-8-索引堆" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-9-索引堆的优化"></a>4-9 索引堆的优化<a class="hash-link" href="#4-9-索引堆的优化" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-10-和堆相关的其他问题"></a>4-10 和堆相关的其他问题<a class="hash-link" href="#4-10-和堆相关的其他问题" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第五章：二分搜索树"></a>第五章：二分搜索树<a class="hash-link" href="#第五章：二分搜索树" title="Direct link to heading">#</a></h2><p>解决的是查找问题。计算机的查找问题是个大问题。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-1-二分查找法"></a>5-1 二分查找法<a class="hash-link" href="#5-1-二分查找法" title="Direct link to heading">#</a></h3><p>二分查找法要求序列是有序的。</p><p>对于有序序列才能使用二分查找法。所以前面的排序是基础。（为什么要排序呢？因为有序的序列要比无序的序列好处理的多）</p><p>62年才出现第一版没有bug的二分查找法</p><ul><li>注意边界</li><li>注意越界</li><li>循环和递归</li></ul><p>floor和ceil</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-2-二分搜索树基础"></a>5-2 二分搜索树基础<a class="hash-link" href="#5-2-二分搜索树基础" title="Direct link to heading">#</a></h3><p>应用：查找表/字典</p><p>查找，插入，删除 都是logn</p><p>画树的时候一般只画键。对应的值隐藏在节点中。</p><p>和堆的区别：底层实现的区别。</p><p>设立node节点，节点之间联系用指针或引用。</p><p>堆底层用数组，节点之间的联系用数组索引。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-3-二分搜索树的节点插入"></a>5-3 二分搜索树的节点插入<a class="hash-link" href="#5-3-二分搜索树的节点插入" title="Direct link to heading">#</a></h3><p>insert</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-4-二分搜索书的查找"></a>5-4 二分搜索书的查找<a class="hash-link" href="#5-4-二分搜索书的查找" title="Direct link to heading">#</a></h3><p>contain</p><p>search</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-5-二分搜索树的遍历（深度优先遍历）"></a>5-5 二分搜索树的遍历（深度优先遍历）<a class="hash-link" href="#5-5-二分搜索树的遍历（深度优先遍历）" title="Direct link to heading">#</a></h3><p>遍历：就是把所有的节点都访问一遍。</p><p>一眼看出前中后序遍历：三点法。</p><p>析构。后序遍历</p><p>归并排序，快速排序，本质是深度优先遍历。？？</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-6-层序遍历（广度优先遍历）"></a>5-6 层序遍历（广度优先遍历）<a class="hash-link" href="#5-6-层序遍历（广度优先遍历）" title="Direct link to heading">#</a></h3><p>队列</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-7-删除最大值，最小值"></a>5-7 删除最大值，最小值<a class="hash-link" href="#5-7-删除最大值，最小值" title="Direct link to heading">#</a></h3><p>最小值：一左到底</p><ol><li>叶子节点（右孩子替换）(右孩子为空)</li><li>包含右孩子的非叶子节点（右孩子替换）</li></ol><p>最大值：一右到底</p><ol><li>叶子节点（右孩子替换）(右孩子为空)</li><li>包含左孩子的非叶子节点（左孩子替换 ）</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-8-二分搜索树的删除"></a>5-8 二分搜索树的删除<a class="hash-link" href="#5-8-二分搜索树的删除" title="Direct link to heading">#</a></h3><ol><li>删除只有一个孩子的节点（和叶子节点操作统一，可以视为有一个空的孩子节点），那个唯一的孩子替换上。</li><li>删除有两个孩子的节点。（复杂一些）</li></ol><p>右子树的最小值。替换 s = min(d-&gt;right)</p><p>1962年： Hibbard提出 Hubbard Deletion</p><p>右孩子的最小值是后继。最小值函数可以抽出来。</p><p>也可以找前驱。（左子树最大值替换）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-9-二分搜索树的顺序性"></a>5-9 二分搜索树的顺序性<a class="hash-link" href="#5-9-二分搜索树的顺序性" title="Direct link to heading">#</a></h3><p>不仅能定位元素，还能回到很多和元素相关的问题。</p><ul><li>minimum</li><li>maximum</li><li>successor (元素得存在)</li><li>predecessor(元素得存在)</li><li>floor(元素不一定存在)</li><li>ceil(元素不一定存在)</li><li>rank 58的排名是多少？ 存阈值（树有多少节点）</li><li>select  排名第10的元素是谁？</li><li>支持重复元素：添加count属性</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-10-二分搜索树的局限性"></a>5-10 二分搜索树的局限性<a class="hash-link" href="#5-10-二分搜索树的局限性" title="Direct link to heading">#</a></h3><p>近乎有序的，退化成链表。对比二分查找法的退化。（随机选择）</p><p>解决方案： 平衡二叉树：红黑树</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-11-树形问题和更多树。"></a>5-11 树形问题和更多树。<a class="hash-link" href="#5-11-树形问题和更多树。" title="Direct link to heading">#</a></h3><p>树型问题：</p><p>归并排序：</p><p>分拆成子数组排序。</p><p><img alt="image-20210612111425662" src="/assets/images/image-20210612111425662-10ca2198b5f7bd7397a64c412d2c18f8.png"></p><p>快速排序：</p><p>确定标定点，将整个数组一分为2</p><p><img alt="image-20210612111523467" src="/assets/images/image-20210612111523467-01f05dd279f8ffb33d7aafcee14b1d96.png"></p><p>树形搜索、决策树：</p><p>8数码</p><p>8皇后</p><p>机器学习，人工智能</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第六章：并查集"></a>第六章：并查集<a class="hash-link" href="#第六章：并查集" title="Direct link to heading">#</a></h2><p>高效 解决连接问题。</p><p>图的基础。</p><p>网络节点的连接状态。</p><p>比如：Facebook用户。</p><p>比路径问题，做的多了。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="6-1-并查集基础"></a>6-1 并查集基础<a class="hash-link" href="#6-1-并查集基础" title="Direct link to heading">#</a></h3><p>操作：</p><p>union</p><p>find</p><p>用来回到一个问题：</p><p>isConnect(p,q)</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="6-2-qucik-find"></a>6-2 Qucik Find<a class="hash-link" href="#6-2-qucik-find" title="Direct link to heading">#</a></h3><p>查找很快。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="6-3-quick-union"></a>6-3 Quick Union<a class="hash-link" href="#6-3-quick-union" title="Direct link to heading">#</a></h3><p>合并很快。指向父节点的数。数组实现。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="6-4-基于size的优化"></a>6-4 基于size的优化<a class="hash-link" href="#6-4-基于size的优化" title="Direct link to heading">#</a></h3><p>合并的时候，节点少的指向节点多的。</p><p>优化union</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="6-5-基于rank的优化"></a>6-5 基于rank的优化<a class="hash-link" href="#6-5-基于rank的优化" title="Direct link to heading">#</a></h3><p>按照size，数的高度不一定最优。（可以避免极端情况）</p><p>合并的时候，数的高度尽量小。</p><p>优化union。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="6-6-路径压缩"></a>6-6 路径压缩<a class="hash-link" href="#6-6-路径压缩" title="Direct link to heading">#</a></h3><p>优化find。</p><p>一句话：</p><p>parent[p] = parent[parent[p]]</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第七章：图论"></a>第七章：图论<a class="hash-link" href="#第七章：图论" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="7-1-图论基础"></a>7-1 图论基础<a class="hash-link" href="#7-1-图论基础" title="Direct link to heading">#</a></h3><p>节点（Vertex）和边（edge）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="7-2-图的表示"></a>7-2 图的表示<a class="hash-link" href="#7-2-图的表示" title="Direct link to heading">#</a></h3><p>平行边问题。邻接矩阵自动处理。邻接表要处理得o(n)的复杂度。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="7-3-相邻点迭代器"></a>7-3 相邻点迭代器<a class="hash-link" href="#7-3-相邻点迭代器" title="Direct link to heading">#</a></h3><p> begin</p><p>next</p><p>end</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="7-4-图的算法框架"></a>7-4 图的算法框架<a class="hash-link" href="#7-4-图的算法框架" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="7-5-深度优先遍历和联通分量"></a>7-5 深度优先遍历和联通分量<a class="hash-link" href="#7-5-深度优先遍历和联通分量" title="Direct link to heading">#</a></h3><p>记录每个节点是否被遍历过。</p><p>联调分量：不互通的子图的个数。</p><p>并查集，查看两个节点是否相连。</p><p>深度优先搜索和广度优先搜索</p><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p><p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>显然，深度优先搜索是一个递归的过程。</p><p><strong>无向图的深度优先搜索</strong></p><p>下面以&quot;无向图&quot;为例，来对深度优先搜索进行演示。</p><p><img alt="20200717159496853187960.png" src="/assets/images/20200717159496853187960-3021837-a72c36202d050d1dd58faf224f97ebfe.png"></p><p>对上面的图G1进行深度优先遍历，从顶点A开始。</p><p><img alt="202007171594968550237.png" src="/assets/images/202007171594968550237-3021837-bd0195f734926d4f94275354a77f8ee8.png"></p><p><strong>第1步</strong>：访问A。
<strong>第2步</strong>：访问(A的邻接点)C。
在第1步访问A之后，接下来应该访问的是A的邻接点，即&quot;C,D,F&quot;中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在&quot;D和F&quot;的前面，因此，先访问C。
<strong>第3步</strong>：访问(C的邻接点)B。
在第2步访问C之后，接下来应该访问C的邻接点，即&quot;B和D&quot;中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。
<strong>第4步</strong>：访问(C的邻接点)D。
在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。
<strong>第5步</strong>：访问(A的邻接点)F。
前面已经访问了A，并且访问完了&quot;A的邻接点B的所有邻接点(包括递归的邻接点在内)&quot;；因此，此时返回到访问A的另一个邻接点F。
<strong>第6步</strong>：访问(F的邻接点)G。
<strong>第7步</strong>：访问(G的邻接点)E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p><p><strong>有向图的深度优先搜索</strong></p><p>下面以&quot;有向图&quot;为例，来对深度优先搜索进行演示。</p><p><img alt="20200717159496861913394.png" src="/assets/images/20200717159496861913394-3021837-05f878c26fc8d75b2553864c7bc489ac.png"></p><p>对上面的图G2进行深度优先遍历，从顶点A开始。</p><p><img alt="20200717159496863651434.png" src="/assets/images/20200717159496863651434-3021837-cdf5b1c7a60f922979793aa26e4bca5f.png"></p><p><strong>第1步</strong>：访问A。
<strong>第2步</strong>：访问B。
在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。
<strong>第3步</strong>：访问C。
在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。
<strong>第4步</strong>：访问E。
接下来访问C的出边的另一个顶点，即顶点E。
<strong>第5步</strong>：访问D。
接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。
<strong>第6步</strong>：访问F。
接下应该回溯&quot;访问A的出边的另一个顶点F&quot;。
<strong>第7步</strong>：访问G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="7-6-寻路"></a>7-6 寻路<a class="hash-link" href="#7-6-寻路" title="Direct link to heading">#</a></h3><p>或得一条路径，不一定是最短路径。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="7-7-广度优先遍历和最短路径"></a>7-7 广度优先遍历和最短路径<a class="hash-link" href="#7-7-广度优先遍历和最短路径" title="Direct link to heading">#</a></h3><p>层序遍历。</p><p>无权图的最短路径。</p><p>广度优先搜索算法(Breadth First Search)，又称为&quot;宽度优先搜索&quot;或&quot;横向优先搜索&quot;，简称BFS。</p><p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。</p><p><strong>无向图的广度优先搜索</strong></p><p>下面以&quot;无向图&quot;为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。</p><p><img alt="20200717159496872078336.png" src="/assets/images/20200717159496872078336-dca5e98897f7d32ba735ac5df46cdd91.png"></p><p><strong>第1步</strong>：访问A。
<strong>第2步</strong>：依次访问C,D,F。
在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在&quot;D和F&quot;的前面，因此，先访问C。再访问完C之后，再依次访问D,F。
<strong>第3步</strong>：依次访问B,G。
在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。
<strong>第4步</strong>：访问E。
在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p><p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p><p><strong>有向图的广度优先搜索</strong></p><p>下面以&quot;有向图&quot;为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。</p><p><img alt="20200717159496876987145.png" src="/assets/images/20200717159496876987145-1949f7dfd29b1775b7510ee62a83696a.png"></p><p><strong>第1步</strong>：访问A。
<strong>第2步</strong>：访问B。
<strong>第3步</strong>：依次访问C,E,F。
在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。
<strong>第4步</strong>：依次访问D,G。
在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="7-8-迷宫生成，ps抠图--更多无权图的应用"></a>7-8 迷宫生成，ps抠图--更多无权图的应用<a class="hash-link" href="#7-8-迷宫生成，ps抠图--更多无权图的应用" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第八章：最小生成树"></a>第八章：最小生成树<a class="hash-link" href="#第八章：最小生成树" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="8-1-有权图"></a>8-1 有权图<a class="hash-link" href="#8-1-有权图" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="8-2-最小生成树问题和切分定理"></a>8-2 最小生成树问题和切分定理<a class="hash-link" href="#8-2-最小生成树问题和切分定理" title="Direct link to heading">#</a></h3><p>v和顶点 v-1条边</p><p>顶点都联通，但是费用最少！</p><p>电缆布线设计</p><p>网络设计</p><p>电路设计</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="8-3-普里姆prim算法的第一个实现"></a>8-3 普里姆(Prim)算法的第一个实现<a class="hash-link" href="#8-3-普里姆prim算法的第一个实现" title="Direct link to heading">#</a></h3><p>普里姆(Prim)算法，和克鲁斯卡尔算法一样，是用来求加权连通图的<strong>最小生成树的算法</strong>。</p><p><strong>基本思想</strong>
对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。</p><p><img alt="20200717159496622559120.png" src="/assets/images/20200717159496622559120-cef8348c63003e4ea368b73f5f6b6071.png"></p><p>以上图G4为例，来对普里姆进行演示(从第一个顶点A开始通过普里姆算法生成最小生成树)。</p><p><img alt="20200717159496626135159.png" src="/assets/images/20200717159496626135159-6e7b51824c9fb17a81e70fcaf0c98aed.png"></p><p><strong>初始状态</strong>：V是所有顶点的集合，即V={A,B,C,D,E,F,G}；U和T都是空！
<strong>第1步</strong>：将顶点A加入到U中。
此时，U={A}。
<strong>第2步</strong>：将顶点B加入到U中。
上一步操作之后，U={A}, V-U={B,C,D,E,F,G}；因此，边(A,B)的权值最小。将顶点B添加到U中；此时，U={A,B}。
<strong>第3步</strong>：将顶点F加入到U中。
上一步操作之后，U={A,B}, V-U={C,D,E,F,G}；因此，边(B,F)的权值最小。将顶点F添加到U中；此时，U={A,B,F}。
<strong>第4步</strong>：将顶点E加入到U中。
上一步操作之后，U={A,B,F}, V-U={C,D,E,G}；因此，边(F,E)的权值最小。将顶点E添加到U中；此时，U={A,B,F,E}。
<strong>第5步</strong>：将顶点D加入到U中。
上一步操作之后，U={A,B,F,E}, V-U={C,D,G}；因此，边(E,D)的权值最小。将顶点D添加到U中；此时，U={A,B,F,E,D}。
<strong>第6步</strong>：将顶点C加入到U中。
上一步操作之后，U={A,B,F,E,D}, V-U={C,G}；因此，边(D,C)的权值最小。将顶点C添加到U中；此时，U={A,B,F,E,D,C}。
<strong>第7步</strong>：将顶点G加入到U中。
上一步操作之后，U={A,B,F,E,D,C}, V-U={G}；因此，边(F,G)的权值最小。将顶点G添加到U中；此时，U=V。</p><p>此时，最小生成树构造完成！它包括的顶点依次是：<strong>A B F E D C G</strong>。</p><p><strong>普里姆算法的代码说明</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="8-4-prim算法的优化"></a>8-4 Prim算法的优化<a class="hash-link" href="#8-4-prim算法的优化" title="Direct link to heading">#</a></h3><p>最小索引堆</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="8-5-优化后的prim算法的实现"></a>8-5 优化后的Prim算法的实现<a class="hash-link" href="#8-5-优化后的prim算法的实现" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="8-6-克鲁斯卡尔kruskal算法"></a>8-6 克鲁斯卡尔(Kruskal)算法<a class="hash-link" href="#8-6-克鲁斯卡尔kruskal算法" title="Direct link to heading">#</a></h3><p>排序：堆</p><p>环检测：并查集</p><p><strong>最小生成树算法</strong></p><p>在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。</p><p><img alt="20200713159463309582713.png" src="/assets/images/20200713159463309582713-b4f528d7baa420b640c42fe79473761a.png"></p><p>例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。</p><p><img alt="20200713159463314488466.png" src="/assets/images/20200713159463314488466-d241e46a8a38bf792c6f96f0c6796c9d.png"></p><p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</p><p><strong>基本思想</strong>：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。
<strong>具体做法</strong>：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。</p><p><strong>克鲁斯卡尔算法图解</strong></p><p><img alt="20200713159463336170511.png" src="/assets/images/20200713159463336170511-375051216aaf728b7fd64f9fdb8e21d1.png"></p><p><strong>第1步</strong>：将边&lt;E,F&gt;加入R中。
边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R中。
<strong>第2步</strong>：将边&lt;C,D&gt;加入R中。
上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R中。
<strong>第3步</strong>：将边&lt;D,E&gt;加入R中。
上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R中。
<strong>第4步</strong>：将边&lt;B,F&gt;加入R中。
上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R中。
<strong>第5步</strong>：将边&lt;E,G&gt;加入R中。
上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R中。
<strong>第6步</strong>：将边&lt;A,B&gt;加入R中。
上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R中。</p><p>此时，最小生成树构造完成！它包括的边依次是：<code>&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;</code>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="8-7-最小生成树算法的思考"></a>8-7 最小生成树算法的思考<a class="hash-link" href="#8-7-最小生成树算法的思考" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第九章：最短路径"></a>第九章：最短路径<a class="hash-link" href="#第九章：最短路径" title="Direct link to heading">#</a></h2><p><strong>最短路径算法</strong></p><p>地图应用，游戏应用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="9-1-最短路径问题和松弛操作"></a>9-1 最短路径问题和松弛操作<a class="hash-link" href="#9-1-最短路径问题和松弛操作" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="9-2-迪杰斯特拉dijkstra算法的思想"></a>9-2 迪杰斯特拉(Dijkstra)算法的思想<a class="hash-link" href="#9-2-迪杰斯特拉dijkstra算法的思想" title="Direct link to heading">#</a></h3><ul><li>松弛操作</li></ul><p>迪杰斯特拉(Dijkstra)算法是典型<strong>最短路径算法</strong>，用于计算一个节点到其他节点的最短路径。
它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><p><strong>基本思想</strong></p><p>   通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p><p>   此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p><p>   初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是&quot;起点s到该顶点的路径&quot;。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 ... 重复该操作，直到遍历完所有顶点。</p><p><strong>操作步骤</strong></p><p><strong>(1)</strong> 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为&quot;起点s到该顶点的距离&quot;[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</p><p><strong>(2)</strong> 从U中选出&quot;距离最短的顶点k&quot;，并将顶点k加入到S中；同时，从U中移除顶点k。</p><p><strong>(3)</strong> 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</p><p><strong>(4)</strong> 重复步骤(2)和(3)，直到遍历完所有顶点。</p><p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p><p><img alt="20200717159496622559120.png" src="/assets/images/20200717159496622559120-cef8348c63003e4ea368b73f5f6b6071.png"></p><p>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。</p><p><img alt="20200717159496722756589.png" src="/assets/images/20200717159496722756589-5194bb9c68caab7034e1b9c30753abdb.png"></p><p>注意：此处有误B应该是13，而非23。</p><p><strong>初始状态</strong>：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！
<strong>第1步</strong>：将顶点D加入到S中。
此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。   注:C(3)表示C到起点D的距离是3。</p><p><strong>第2步</strong>：将顶点C加入到S中。
上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。
此时，S={D(0),C(3)}, U={A(∞),B(13),E(4),F(9),G(∞)}。</p><p><strong>第3步</strong>：将顶点E加入到S中。
上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。
此时，S={D(0),C(3),E(4)}, U={A(∞),B(13),F(6),G(12)}。</p><p><strong>第4步</strong>：将顶点F加入到S中。
此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</p><p><strong>第5步</strong>：将顶点G加入到S中。
此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p><p><strong>第6步</strong>：将顶点B加入到S中。
此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p><p><strong>第7步</strong>：将顶点A加入到S中。
此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p><p>此时，起点D到各个顶点的最短距离就计算出来了：<strong>A(22) B(13) C(3) D(0) E(4) F(6) G(12)</strong>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="9-3-实现dijkstra算法"></a>9-3 实现Dijkstra算法<a class="hash-link" href="#9-3-实现dijkstra算法" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="9-4-负权边和bellman-ford算法"></a>9-4 负权边和Bellman-Ford算法<a class="hash-link" href="#9-4-负权边和bellman-ford算法" title="Direct link to heading">#</a></h3><p>o ve</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="9-5-实现bellman-ford算法"></a>9-5 实现Bellman-Ford算法<a class="hash-link" href="#9-5-实现bellman-ford算法" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="9-6-更多和最短路径相关的思考"></a>9-6 更多和最短路径相关的思考<a class="hash-link" href="#9-6-更多和最短路径相关的思考" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="拓扑排序"></a>拓扑排序<a class="hash-link" href="#拓扑排序" title="Direct link to heading">#</a></h3><p>拓扑排序(Topological Order)是指，将一个<strong>有向无环图</strong>(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的<strong>线性序列</strong>。</p><p>自我总结：梳理依赖关系，确定节点顺序。</p><p>拓扑排序算法的基本步骤：</p><blockquote><p><strong>1.</strong> 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)； <strong>2.</strong> 把所有没有依赖顶点的节点放入Q； <strong>3.</strong> 当Q还有顶点的时候，执行下面步骤： <strong>3.1</strong> 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)； <strong>3.2</strong> 对n每一个邻接点m(n是起点，m是终点)； <strong>3.2.1</strong> 去掉边&lt;n,m&gt;; <strong>3.2.2</strong> 如果m没有依赖顶点，则把m放入Q; <em>注：顶点A没有依赖顶点，是指不存在以A为终点的边。</em></p><p><img src="file:///Users/dingyusong/mine/survival/docs/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95.assets/20200813159731605362640.png?lastModify=1623489198" alt="20200813159731605362640.png"></p><p><img src="file:///Users/dingyusong/mine/survival/docs/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95.assets/20200813159731607989241.png?lastModify=1623489198" alt="20200813159731607989241.png"></p><p>应用：</p><p>在工程实践中,一个工程项目往往由若干个子项⽬目组成。这些子项目间往往有两种关系:</p><p><strong>1</strong>  先后关系,即必须在某个项 ⽬完成后才能开始实施另一个子项目;</p><p><strong>2</strong>  子项⽬目间无关系,即两个子项目可以同时进行,互不影响。</p><p>研发项目管理也一样。</p><p><a href="https://blog.csdn.net/u014634338/article/details/40857015" target="_blank" rel="noopener noreferrer">图论--拓扑排序及其应用</a></p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="第十章：总结"></a>第十章：总结<a class="hash-link" href="#第十章：总结" title="Direct link to heading">#</a></h2></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="dys-typora-open://mine/survival/docs/编程基础/数据结构与算法/算法.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/编程基础/数据结构与算法/数据结构"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 数据结构</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/编程基础/数据结构与算法/算法面试"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">算法面试 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#第一章：当我们在讨论算法的时候，我们在讨论什么？" class="table-of-contents__link">第一章：当我们在讨论算法的时候，我们在讨论什么？</a></li><li><a href="#1-1-我们究竟为什么要学习算法" class="table-of-contents__link">1-1 我们究竟为什么要学习算法</a></li><li><a href="#第二章：排序基础" class="table-of-contents__link">第二章：排序基础</a><ul><li><a href="#2-1-选择排序法" class="table-of-contents__link">2-1 选择排序法</a></li><li><a href="#2-2-使用模板（泛型）编写算法" class="table-of-contents__link">2-2 使用模板（泛型）编写算法</a></li><li><a href="#2-3-随机生成算法测试用例" class="table-of-contents__link">2-3 随机生成算法测试用例</a></li><li><a href="#2-4-测试算法的性能" class="table-of-contents__link">2-4 测试算法的性能</a></li><li><a href="#2-5-插入排序法" class="table-of-contents__link">2-5 插入排序法</a></li><li><a href="#2-6-插入排序法的改进" class="table-of-contents__link">2-6 插入排序法的改进</a></li><li><a href="#2-7-更多关于o（n2）排序算法的思考" class="table-of-contents__link">2-7 更多关于O（n*2）排序算法的思考</a></li></ul></li><li><a href="#第三章：高级排序问题" class="table-of-contents__link">第三章：高级排序问题</a><ul><li><a href="#3-1-归并排序法" class="table-of-contents__link">3-1 归并排序法</a></li><li><a href="#3-2-归并排序法的实现" class="table-of-contents__link">3-2 归并排序法的实现</a></li><li><a href="#3-3-归并排序法的优化" class="table-of-contents__link">3-3 归并排序法的优化</a></li><li><a href="#3-4-自底向上的归并排序算法" class="table-of-contents__link">3-4 自底向上的归并排序算法</a></li><li><a href="#3-5-快速排序法" class="table-of-contents__link">3-5 快速排序法</a></li><li><a href="#3-6-随机化快速排序法" class="table-of-contents__link">3-6 随机化快速排序法</a></li><li><a href="#3-7-双路快速排序法" class="table-of-contents__link">3-7 双路快速排序法</a></li><li><a href="#3-8-三路快速排序法" class="table-of-contents__link">3-8 三路快速排序法</a></li><li><a href="#3-9-归并排序和快速排序的衍生问题" class="table-of-contents__link">3-9 归并排序和快速排序的衍生问题</a></li></ul></li><li><a href="#第四章：堆和堆排序" class="table-of-contents__link">第四章：堆和堆排序</a><ul><li><a href="#4-1-为什么使用堆" class="table-of-contents__link">4-1 为什么使用堆</a></li><li><a href="#4-2-堆的基本存储" class="table-of-contents__link">4-2 堆的基本存储</a></li><li><a href="#4-3-shift-up" class="table-of-contents__link">4-3 Shift Up</a></li><li><a href="#4-4-shift-down" class="table-of-contents__link">4-4 Shift Down</a></li><li><a href="#4-5-基础堆排序和heapify" class="table-of-contents__link">4-5 基础堆排序和Heapify</a></li><li><a href="#4-6-优化的堆排序" class="table-of-contents__link">4-6 优化的堆排序</a></li><li><a href="#4-7-排序算法总结" class="table-of-contents__link">4-7 排序算法总结</a></li><li><a href="#4-8-索引堆" class="table-of-contents__link">4-8 索引堆</a></li><li><a href="#4-9-索引堆的优化" class="table-of-contents__link">4-9 索引堆的优化</a></li><li><a href="#4-10-和堆相关的其他问题" class="table-of-contents__link">4-10 和堆相关的其他问题</a></li></ul></li><li><a href="#第五章：二分搜索树" class="table-of-contents__link">第五章：二分搜索树</a><ul><li><a href="#5-1-二分查找法" class="table-of-contents__link">5-1 二分查找法</a></li><li><a href="#5-2-二分搜索树基础" class="table-of-contents__link">5-2 二分搜索树基础</a></li><li><a href="#5-3-二分搜索树的节点插入" class="table-of-contents__link">5-3 二分搜索树的节点插入</a></li><li><a href="#5-4-二分搜索书的查找" class="table-of-contents__link">5-4 二分搜索书的查找</a></li><li><a href="#5-5-二分搜索树的遍历（深度优先遍历）" class="table-of-contents__link">5-5 二分搜索树的遍历（深度优先遍历）</a></li><li><a href="#5-6-层序遍历（广度优先遍历）" class="table-of-contents__link">5-6 层序遍历（广度优先遍历）</a></li><li><a href="#5-7-删除最大值，最小值" class="table-of-contents__link">5-7 删除最大值，最小值</a></li><li><a href="#5-8-二分搜索树的删除" class="table-of-contents__link">5-8 二分搜索树的删除</a></li><li><a href="#5-9-二分搜索树的顺序性" class="table-of-contents__link">5-9 二分搜索树的顺序性</a></li><li><a href="#5-10-二分搜索树的局限性" class="table-of-contents__link">5-10 二分搜索树的局限性</a></li><li><a href="#5-11-树形问题和更多树。" class="table-of-contents__link">5-11 树形问题和更多树。</a></li></ul></li><li><a href="#第六章：并查集" class="table-of-contents__link">第六章：并查集</a><ul><li><a href="#6-1-并查集基础" class="table-of-contents__link">6-1 并查集基础</a></li><li><a href="#6-2-qucik-find" class="table-of-contents__link">6-2 Qucik Find</a></li><li><a href="#6-3-quick-union" class="table-of-contents__link">6-3 Quick Union</a></li><li><a href="#6-4-基于size的优化" class="table-of-contents__link">6-4 基于size的优化</a></li><li><a href="#6-5-基于rank的优化" class="table-of-contents__link">6-5 基于rank的优化</a></li><li><a href="#6-6-路径压缩" class="table-of-contents__link">6-6 路径压缩</a></li></ul></li><li><a href="#第七章：图论" class="table-of-contents__link">第七章：图论</a><ul><li><a href="#7-1-图论基础" class="table-of-contents__link">7-1 图论基础</a></li><li><a href="#7-2-图的表示" class="table-of-contents__link">7-2 图的表示</a></li><li><a href="#7-3-相邻点迭代器" class="table-of-contents__link">7-3 相邻点迭代器</a></li><li><a href="#7-4-图的算法框架" class="table-of-contents__link">7-4 图的算法框架</a></li><li><a href="#7-5-深度优先遍历和联通分量" class="table-of-contents__link">7-5 深度优先遍历和联通分量</a></li><li><a href="#7-6-寻路" class="table-of-contents__link">7-6 寻路</a></li><li><a href="#7-7-广度优先遍历和最短路径" class="table-of-contents__link">7-7 广度优先遍历和最短路径</a></li><li><a href="#7-8-迷宫生成，ps抠图--更多无权图的应用" class="table-of-contents__link">7-8 迷宫生成，ps抠图--更多无权图的应用</a></li></ul></li><li><a href="#第八章：最小生成树" class="table-of-contents__link">第八章：最小生成树</a><ul><li><a href="#8-1-有权图" class="table-of-contents__link">8-1 有权图</a></li><li><a href="#8-2-最小生成树问题和切分定理" class="table-of-contents__link">8-2 最小生成树问题和切分定理</a></li><li><a href="#8-3-普里姆prim算法的第一个实现" class="table-of-contents__link">8-3 普里姆(Prim)算法的第一个实现</a></li><li><a href="#8-4-prim算法的优化" class="table-of-contents__link">8-4 Prim算法的优化</a></li><li><a href="#8-5-优化后的prim算法的实现" class="table-of-contents__link">8-5 优化后的Prim算法的实现</a></li><li><a href="#8-6-克鲁斯卡尔kruskal算法" class="table-of-contents__link">8-6 克鲁斯卡尔(Kruskal)算法</a></li><li><a href="#8-7-最小生成树算法的思考" class="table-of-contents__link">8-7 最小生成树算法的思考</a></li></ul></li><li><a href="#第九章：最短路径" class="table-of-contents__link">第九章：最短路径</a><ul><li><a href="#9-1-最短路径问题和松弛操作" class="table-of-contents__link">9-1 最短路径问题和松弛操作</a></li><li><a href="#9-2-迪杰斯特拉dijkstra算法的思想" class="table-of-contents__link">9-2 迪杰斯特拉(Dijkstra)算法的思想</a></li><li><a href="#9-3-实现dijkstra算法" class="table-of-contents__link">9-3 实现Dijkstra算法</a></li><li><a href="#9-4-负权边和bellman-ford算法" class="table-of-contents__link">9-4 负权边和Bellman-Ford算法</a></li><li><a href="#9-5-实现bellman-ford算法" class="table-of-contents__link">9-5 实现Bellman-Ford算法</a></li><li><a href="#9-6-更多和最短路径相关的思考" class="table-of-contents__link">9-6 更多和最短路径相关的思考</a></li><li><a href="#拓扑排序" class="table-of-contents__link">拓扑排序</a></li></ul></li><li><a href="#第十章：总结" class="table-of-contents__link">第十章：总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.e736442d.js"></script>
<script src="/runtime~main.500606b1.js"></script>
<script src="/main.e34cadf8.js"></script>
<script src="/1.3353372a.js"></script>
<script src="/256.3f6603bc.js"></script>
<script src="/257.427a7301.js"></script>
<script src="/935f2afb.0ee8c40a.js"></script>
<script src="/255.24175022.js"></script>
<script src="/d3e91d0c.b03a8b69.js"></script>
</body>
</html>