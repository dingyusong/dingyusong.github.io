<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Blog Atom Feed"><title data-react-helmet="true">极客训练营过遍数 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="极客训练营过遍数 | My Site"><meta data-react-helmet="true" name="description" content="极客训练营过遍数"><meta data-react-helmet="true" property="og:description" content="极客训练营过遍数"><meta data-react-helmet="true" property="og:url" content="http://localhost:9999//docs/编程基础/数据结构与算法/练习/极客训练营过遍数"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="http://localhost:9999//docs/编程基础/数据结构与算法/练习/极客训练营过遍数"><link rel="stylesheet" href="/styles.8cfbcdec.css">
<link rel="preload" href="/styles.65a50636.js" as="script">
<link rel="preload" href="/runtime~main.b175e2de.js" as="script">
<link rel="preload" href="/main.777b260c.js" as="script">
<link rel="preload" href="/1.5f7a006f.js" as="script">
<link rel="preload" href="/260.fc337f83.js" as="script">
<link rel="preload" href="/261.cd474b1f.js" as="script">
<link rel="preload" href="/935f2afb.42cf00cb.js" as="script">
<link rel="preload" href="/259.fa9b4b3b.js" as="script">
<link rel="preload" href="/090f2256.7ba91d97.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">基础</a><a class="navbar__item navbar__link" href="/docs/编程语言/编程语言">语言</a><a class="navbar__item navbar__link" href="/docs/工具/常用工具">工具</a><a class="navbar__item navbar__link" href="/docs/应用开发/应用开发">应用开发</a><a class="navbar__item navbar__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a><a class="navbar__item navbar__link" href="/docs/音视频/音视频">音视频</a><a class="navbar__item navbar__link" href="/docs/项目/项目">项目</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Search" aria-label="Search" class="navbar__search-input search-bar"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程语言/编程语言">语言</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/工具/常用工具">工具</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/应用开发/应用开发">应用开发</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/音视频/音视频">音视频</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/项目/项目">项目</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">极客训练营过遍数</h1></header><div class="markdown"><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="极客训练营过遍数"></a>极客训练营过遍数<a class="hash-link" href="#极客训练营过遍数" title="Direct link to heading">#</a></h1><p>[toc]</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="理论"></a>理论<a class="hash-link" href="#理论" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="精通一个领域"></a><strong>精通一个领域</strong><a class="hash-link" href="#精通一个领域" title="Direct link to heading">#</a></h3><ul><li>Chunk it up 切碎知识点 </li><li>Deliberate Practicing 刻意练习 </li><li>Feedback 反馈</li></ul><hr><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="chunk-it-up"></a><strong>Chunk it up</strong><a class="hash-link" href="#chunk-it-up" title="Direct link to heading">#</a></h3><ul><li>庖丁解牛 </li><li>脉络连接</li></ul><p>形成树形结构的脑图，并记忆下来！</p><hr><p><strong>数据结构</strong></p><p>• 一维:
• 基础:数组 array (string), 链表 linked list
• 高级:栈 stack, 队列 queue, 双端队列 deque, 集合 set, 映射 map (hash or map), etc</p><p>• 二维:
• 基础:树 tree, 图 graph
• 高级:二叉搜索树 binary search tree (red-black tree, AVL), 堆 heap, 并查集 disjoint set, 字典树 Trie, etc</p><p>• 特殊:
• 位运算 Bitwise, 布隆过滤器 BloomFilter • LRU Cache</p><p>注意:了解每个数据结构的原理和代码框架</p><p>数据结构脑图</p><p><a href="http://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c" target="_blank" rel="noopener noreferrer">http://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c</a></p><hr><p>算法</p><ul><li><p>If-else, switch —&gt; branch</p></li><li><p>for, while loop —&gt; Iteration</p></li><li><p>递归 Recursion (Divide &amp; Conquer, Backtrace)</p></li><li><p>搜索 Search: 深度优先搜索 Depth first search, 广度优先搜索 Breadth first search, A*, etc</p></li><li><p>动态规划 Dynamic Programming</p></li><li><p>二分查找 Binary Search</p></li><li><p>贪心 Greedy</p></li><li><p>数学 Math , 几何 Geometry  </p></li></ul><p>注意:在头脑中回忆上面每种算法的思想和代码模板</p><p>算法脑图</p><p><a href="http://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec" target="_blank" rel="noopener noreferrer">http://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="deliberate-practicing"></a>Deliberate Practicing<a class="hash-link" href="#deliberate-practicing" title="Direct link to heading">#</a></h3><p>职业化运动</p><p>• 基本功是区别业余和职业选手的根本
• 基础动作的分解训练和反复练习 —&gt; 最大的误区</p><p>• 乒乓球 </p><p>• 台球
• 滑雪</p><hr><p>刻意练习 — 过遍数(五毒神掌)
• 练习缺陷、弱点地方
• 不舒服、不爽、枯燥
• 生活中例子:乒乓球、台球、游戏等等</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="feedback"></a>Feedback<a class="hash-link" href="#feedback" title="Direct link to heading">#</a></h3><p>• 即时反馈
• 主动型反馈(自己去找)</p><p>• 高手代码 (GitHub, LeetCode, etc.)</p><p>• 第一视角直播
• 被动式反馈(高手给你指点)</p><p>• code review
• 教练看你打，给你反馈</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="切题四件套"></a>切题四件套<a class="hash-link" href="#切题四件套" title="Direct link to heading">#</a></h3><p>• Clarification
• Possible solutions</p><p>• compare (time/space)</p><p>• optimal(加强) • Coding(多写)
• Test cases</p><p>对应leecode上的题解</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="五步刷题法-五毒神掌"></a>五步刷题法 五毒神掌<a class="hash-link" href="#五步刷题法-五毒神掌" title="Direct link to heading">#</a></h3><p>刷题第一遍</p><ul><li>5分钟:读题 + 思考</li><li>直接看解法:注意!多解法，比较解法优劣</li><li>背诵、默写好的解法</li></ul><p>刷题第二遍</p><ul><li>马上自己写 —&gt; LeetCode 提交 </li><li>多种解法比较、体会 —&gt; 优化!</li></ul><p>刷题第三遍</p><ul><li>过了一天后，再重复做题</li><li>不同解法的熟练程度 —&gt; 专项练习</li></ul><p>刷题第四遍</p><ul><li>过了一周:反复回来练习相同题目</li></ul><p>刷题第五遍</p><ul><li>面试前一周恢复性训练</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="⾃自顶向下的编程⽅方式"></a>⾃自顶向下的编程⽅方式<a class="hash-link" href="#⾃自顶向下的编程⽅方式" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="125-验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener noreferrer">125. 验证回文串</a><a class="hash-link" href="#125-验证回文串" title="Direct link to heading">#</a></h4><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" disabled=""> 第一遍：理解，背诵，提交通过（2021-11-18）</li><li class="task-list-item"><input type="checkbox" disabled=""> 第二遍：自己写（2021-11-18）</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数组，链表，跳表"></a>数组，链表，跳表<a class="hash-link" href="#数组，链表，跳表" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="数组"></a>数组<a class="hash-link" href="#数组" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="11-盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener noreferrer">11. 盛最多水的容器</a><a class="hash-link" href="#11-盛最多水的容器" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="283-移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener noreferrer">283. 移动零</a><a class="hash-link" href="#283-移动零" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="70-爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">70. 爬楼梯</a><a class="hash-link" href="#70-爬楼梯" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="15-三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener noreferrer">15. 三数之和</a><a class="hash-link" href="#15-三数之和" title="Direct link to heading">#</a></h4><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="链表"></a>链表<a class="hash-link" href="#链表" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="206-反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener noreferrer">206. 反转链表</a><a class="hash-link" href="#206-反转链表" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="146-lru-缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener noreferrer">146. LRU 缓存机制</a><a class="hash-link" href="#146-lru-缓存机制" title="Direct link to heading">#</a></h4><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="跳表"></a>跳表<a class="hash-link" href="#跳表" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="深度优先搜索"></a>深度优先搜索<a class="hash-link" href="#深度优先搜索" title="Direct link to heading">#</a></h2><p>处理树或者图的问题。一般需要借助递归。（递归回溯，动态规划的递归写法，都使用了深度优先搜索的思想）</p><p>重要：<strong>代码模板</strong></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">//递归写法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">vector visited = set();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void dfs(node, visited){</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //终止条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //处理当前层逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //遍历下层节点(2叉树就是两个，多叉树就是多个，n叉树就是for-loop n个)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for(auto next_node: node.nexts) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dfs(next_node, visited);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//非递归写法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def DFS(self, tree):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if tree.root is None:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return []</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    visited, stack = [], [tree.root]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    while stack:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       node = stack.pop()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       visited.add(node)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       process (node)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       nodes = generate_related_nodes(node)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       stack.push(nodes)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # other processing work</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="102-二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">102. 二叉树的层序遍历</a><a class="hash-link" href="#102-二叉树的层序遍历" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * Definition for a binary tree node.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * struct TreeNode {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     int val;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode *left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode *right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dfs(0, root);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void dfs(int level, TreeNode *node) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //终止条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!node) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //当我们转到新的一层的时候就需要新增一个数组</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(level &gt;= ret.size()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ret.push_back(vector&lt;int&gt;());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //处理当前层逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ret[level].push_back(node-&gt;val);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //下探</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dfs(level + 1, node-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dfs(level + 1, node-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>非递归写法</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * Definition for a binary tree node.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * struct TreeNode {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     int val;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode *left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode *right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //异常判断</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!root) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        stack&lt;TreeNode *&gt; sk1,sk2;  //sk1存放当前层的内容，sk2是过渡存储sk1到sk2.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        sk1.push(root);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        while(!sk1.empty()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            vector&lt;int&gt; levelRet;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //拿出栈1的内容，并且将其出队push到栈2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            while(!sk1.empty()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                TreeNode *node = sk1.top();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                sk1.pop();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                levelRet.push_back(node-&gt;val);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                sk2.push(node);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ret.push_back(levelRet);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            while(!sk2.empty()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                TreeNode *node = sk2.top();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                sk2.pop();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if(node-&gt;left) sk1.push(node-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if(node-&gt;right) sk1.push(node-&gt;right);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="515-在每个树行中找最大值"></a><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener noreferrer">515. 在每个树行中找最大值</a><a class="hash-link" href="#515-在每个树行中找最大值" title="Direct link to heading">#</a></h4><p>一次过。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="广度优先搜索"></a>广度优先搜索<a class="hash-link" href="#广度优先搜索" title="Direct link to heading">#</a></h2><p>处理树或者图的问题。一般需要借助queue这种数据结构。一般是求最短问题。</p><p>重要：<strong>代码模板</strong></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">queue&lt;int&gt; que;//建立辅助数据结构</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">que.push(root);//添加初始数据</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">while(!que.empty()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //1. 出队：处理当前层逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Node *node = que.front()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    que.pop();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //2. 入队：下一层节点入队</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for(auto subNode : node-&gt;nexts) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    que.push(subNode);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="127-单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener noreferrer">127. 单词接龙</a><a class="hash-link" href="#127-单词接龙" title="Direct link to heading">#</a></h3><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过（2021-11-23）</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写（2021-11-23）</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; g;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    unordered_map&lt;string, int&gt; vertex_index;//将string 映射为int</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int wordNum = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void addVertex(string word) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!vertex_index.count(word)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            vertex_index[word] = wordNum++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            g.push_back(vector&lt;int&gt;());//这个正好和索引index相对应。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void addEdge(string word) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        addVertex(word);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int v1 = vertex_index[word];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(char &amp;it: word) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            char tmp = it;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            it = &#x27;*&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            addVertex(word);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            int v2 = vertex_index[word];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            g[v1].push_back(v2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            g[v2].push_back(v1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            it = tmp;//将其还原</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //1. 创建邻接表</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(string word:wordList) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            addEdge(word);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //判断endword是否在里面。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!vertex_index.count(endWord)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //将beginWord也加入到图中</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        addEdge(beginWord);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //2. 广度优先搜索得到*最短*转换序列</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        queue&lt;int&gt; que;//辅助数据结构</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int beginV = vertex_index[beginWord], endV = vertex_index[endWord];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        que.push(beginV);//重复体之前的初始条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                vector&lt;int&gt; dis(wordNum,INT_MAX);//距离数组        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dis[beginV] = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        while(!que.empty()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            int x = que.front();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            que.pop();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(x == endV) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return dis[endV]/2 + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }                    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            for(int v : g[x]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if(dis[v] == INT_MAX) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    dis[v] = dis[x] + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    que.push(v);//入队</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="126-单词接龙-ii"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener noreferrer">126. 单词接龙 II</a><a class="hash-link" href="#126-单词接龙-ii" title="Direct link to heading">#</a></h3><p>TODO: 未做出来</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; g;//邻接表</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    unordered_map&lt;string, int&gt; v_indexs;//将字符串隐射为索引</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    unordered_map&lt;int, string&gt; i_v;//将字符串隐射为索引，方便dfs的时候直接通过索引找到字符串</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int v_num = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;string&gt;&gt; ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void addToMap(string &amp;str) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!v_indexs.count(str)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            v_indexs[str] = v_num;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            i_v[v_num] = str;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            v_num++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            g.push_back(vector&lt;int&gt;());//邻接表添加一行，这一行的索引正好和v_num相等，这就是我们要要的效果</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void addVertex(string &amp;str) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        addToMap(str);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int v1 = v_indexs[str];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(char &amp;ch: str) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            char tmp = ch;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ch = &#x27;*&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            addToMap(str);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            int v2 = v_indexs[str];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            g[v1].push_back(v2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            g[v2].push_back(v1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ch = tmp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void dfs(int level, int length, vector&lt;string&gt;&amp; ans, int v_end, int v) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(level &gt; length) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(v == v_end) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ret.push_back(ans);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int p : g[v]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //当前level是奇数，下一层level是偶数，偶数是非生成树</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(level%2 == 1) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                ans.push_back(i_v[p]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            dfs(level + 1, length,ans ,v_end,p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(level%2 == 1) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                ans.pop_back();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //1.创建邻接表</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(string &amp;str: wordList) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            addVertex(str);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!v_indexs.count(endWord)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //begin如果不在里面则添加</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!v_indexs.count(beginWord)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            addVertex(beginWord);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //2.广度优先搜索（得到最短路径长度）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int v_begin = v_indexs[beginWord], v_end = v_indexs[endWord];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        queue&lt;int&gt; que;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        que.push(v_begin);      //创建辅助数据结构并设置好初始值！</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        vector&lt;int&gt; dis(v_num,INT_MAX);//辅助记录是否访问过</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dis[v_begin] = 0;       //创建辅助数据结构并设置好初始值！</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int short_length = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        while(!que.empty()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            int x = que.front();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            que.pop();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(x == v_end) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                short_length = dis[v_end];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            for(int &amp;v: g[x]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if(dis[v] == INT_MAX) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    dis[v] = dis[x] + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    que.push(v);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //2.深度优先搜索（得到最短路径）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        vector&lt;string&gt; ans;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ans.push_back(beginWord);//设置初始值</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dfs(0, short_length, ans,v_end,v_begin);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="102-二叉树的层序遍历-1"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">102. 二叉树的层序遍历</a><a class="hash-link" href="#102-二叉树的层序遍历-1" title="Direct link to heading">#</a></h3><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过（2021-11-23）</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写（2021-11-23）</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * Definition for a binary tree node.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * struct TreeNode {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     int val;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode *left;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode *right;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        vector&lt;vector&lt;int&gt;&gt; ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        // 异常判断(异常判断不能少)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!root) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //添加辅助数据结构que，并设置初始条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        queue&lt;TreeNode *&gt; que;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        que.push(root);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        while(!que.empty()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            vector&lt;int&gt; tmpRet;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            queue&lt;TreeNode *&gt; tmpque;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            while(!que.empty()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                TreeNode *node = que.front();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                tmpRet.push_back(node-&gt;val);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                que.pop();            </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if(node-&gt;left) tmpque.push(node-&gt;left);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if(node-&gt;right) tmpque.push(node-&gt;right);                </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            que = tmpque;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ret.push_back(tmpRet);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="433-最小基因变化"></a><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener noreferrer">433. 最小基因变化</a><a class="hash-link" href="#433-最小基因变化" title="Direct link to heading">#</a></h3><p>注意树和图的差别。</p><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过（2021-11-23）</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写（2021-11-23）</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;int&gt;&gt; g;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    unordered_map&lt;string, int&gt; v_indexs;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int vNum = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void addStr(string &amp;str) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!v_indexs.count(str)){</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            v_indexs[str] = vNum++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            g.push_back(vector&lt;int&gt;());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void addVertex(string &amp;str) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        addStr(str);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int v1 = v_indexs[str];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(char &amp;ch: str) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            char tmp = ch;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ch = &#x27;*&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            addStr(str);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            int v2 = v_indexs[str];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            g[v1].push_back(v2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            g[v2].push_back(v1);   </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ch = tmp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int minMutation(string start, string end, vector&lt;string&gt;&amp; bank) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //创建出一个图结构，两点之间变化相差1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(string str: bank) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            addVertex(str);        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //判断end是否在其中</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!v_indexs.count(end)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return -1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //将start加入图</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        addVertex(start);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //广度优先遍历，找出最短的路径（下面这段几乎是固定写法，请牢记）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        queue&lt;int&gt; que;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int startV = v_indexs[start] , endV = v_indexs[end];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        que.push(startV);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        vector&lt;int&gt; dis(vNum, INT_MAX);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dis[startV] = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        while(!que.empty()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            int v = que.front();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(v == endV) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return dis[endV]/2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            que.pop();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            for(int t:g[v]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if(dis[t] == INT_MAX) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    que.push(t);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    dis[t] = dis[v] + 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return -1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="trie-字典树-前缀树"></a>trie-字典树-前缀树<a class="hash-link" href="#trie-字典树-前缀树" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="208-实现-trie-前缀树"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener noreferrer">208. 实现 Trie (前缀树)</a><a class="hash-link" href="#208-实现-trie-前缀树" title="Direct link to heading">#</a></h3><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过（2021-11-18）</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写（2021-11-18）</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="212-单词搜索-ii"></a><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener noreferrer">212. 单词搜索 II</a><a class="hash-link" href="#212-单词搜索-ii" title="Direct link to heading">#</a></h3><p>（2021-11-18）</p><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="并查集-union"></a>并查集-union<a class="hash-link" href="#并查集-union" title="Direct link to heading">#</a></h2><p> <a href="https://leetcode.com/problems/number-of-provinces/" target="_blank" rel="noopener noreferrer">547.Number of Provinces</a> </p><p>朋友圈数量</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener noreferrer">岛屿数量</a><a class="hash-link" href="#岛屿数量" title="Direct link to heading">#</a></h3><p><a href="https://leetcode-cn.com/problems/bLyHh0/" target="_blank" rel="noopener noreferrer">剑指 Offer II 116. 省份数量</a></p><p>（2021-11-18）</p><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class UnionFind {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;int&gt; parent;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //创建的时候代表有n个孤立的集合</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    UnionFind(int n):count(n),parent(n) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int i = 0; i &lt; n; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            parent[i] = i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //找到他所属的结合(p和q的含义是下标，parent[p]代表其所属的集合的标识)(圆圈代表p,q,箭头指向代表parent[p])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int Find(int p){</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int root = p;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        while(root != parent[root]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //让p的parent网上走一步，指向爷爷</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            parent[root] = parent[parent[root]];//p的parent网上走了一步</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            root = parent[root];                  //p走到了他爷爷那里</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //路径压缩</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        while(parent[p] != p) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            int x = p;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            p = parent[p];// i往上走</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            parent[x] = root;//将x指向根：root</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return root;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //合并两个集合(p和q的含义是下标，parent[p],parent[q]是数组的内容，代表其所属的集合)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void Union(int p, int q){ </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int rootp = Find(p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int rootq = Find(q);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(rootp == rootq) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        parent[rootq] = rootp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        count --;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        /*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        a:二维数组的行数或者列数N代表各自独立的集合。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        b:遍历关系矩阵M：M[i][j] -&gt; 合并</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        c:查看有多少个孤立的集合</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        UnionFind unionFind(isConnected.size());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int i = 0; i &lt; isConnected.size(); i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            for(int j = 0; j &lt; isConnected[0].size(); j++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if(isConnected[i][j]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    unionFind.Union(i,j);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return unionFind.count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="高级搜索"></a>高级搜索<a class="hash-link" href="#高级搜索" title="Direct link to heading">#</a></h2><ol><li><p>朴素搜索</p></li><li><p>优化方式:不重复(fibonacci)、剪枝(生成括号问题)</p></li><li><p>搜索方向:
DFS: depth first search 深度优先搜索 BFS: breadth first search 广度优先搜索</p><p>双向搜索、启发式搜索</p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="不重复记忆剪枝回溯"></a>不重复/记忆+剪枝/回溯<a class="hash-link" href="#不重复记忆剪枝回溯" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="70-爬楼梯-1"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">70. 爬楼梯</a><a class="hash-link" href="#70-爬楼梯-1" title="Direct link to heading">#</a></h4><p>（2021-11-18）</p><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><p>分治</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int climbStairs(int n) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        /*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            1: 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            2: 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            3: 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            f(n) = f(n-1) + f(n-2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(n &lt; 3) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return n;            </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //1.初始条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int dp_pre1 = 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int dp_pre2 = 1;        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //2.重复体结束条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int i = 3; i &lt;= n ; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //处理当前层逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            int dp = dp_pre1 + dp_pre2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //为进入下一层做准备</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            dp_pre2 = dp_pre1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            dp_pre1 = dp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return dp_pre1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>递归是从后往前推。迭代是从前往后推。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    map&lt;int, int&gt; memo;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int climbStairs(int n) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return dfs(n);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int dfs(int level) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //结束条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(level &lt;= 2) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return level;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //处理当前层逻辑(利用缓存进行剪枝，空间换时间)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(memo[level] == 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //drill down</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            memo[level] = dfs(level-1) + dfs(level-2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return memo[level];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="22-括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener noreferrer">22. 括号生成</a><a class="hash-link" href="#22-括号生成" title="Direct link to heading">#</a></h4><p>（2021-11-18）</p><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过</li><li class="task-list-item"><input type="checkbox" disabled=""> 第二遍：自己写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><p>回溯法</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;string&gt; ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;string&gt; generateParenthesis(int n) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        /*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        寻找重复性，在重复的过程中处理逻辑。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        注意重复的开始条件，结束条件，和重复推进逻辑（状态转移方程）。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        重复的开始条件：</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        1. 递归，递归调用的时候用参数传入</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        2. 循环，循环进入前，设置好局部变量</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        重复结束条件：</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        1. 递归，层级的结束，确定好最大层，如果是递减，则相对简单，大于0是结束条件。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        2. 循环，设置好循环的结束条件。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        重复推进逻辑（状态转移方程）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        1. 递归：某些条件下放弃递归。（不调用递归），某些条件下调用递归。（这叫分治或者剪枝）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        2. 循环：好像不太好整，循环条件i++好像少不了</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dfs(n,n,&quot;&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //分治+回溯+剪枝（从单线程的角度来看，确实是深度优先遍历）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void dfs(int left, int right, string ans) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //1. 结束条件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(left == 0 &amp;&amp; right == 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            ret.push_back(ans);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //2. 处理逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //剪枝:如果剩下的左括号比右括号还多，那就没得玩了，可以剪枝</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (left == right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //如果相等，只能添加左括号</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            dfs(left-1, right ,ans+&quot;(&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        else if (left &lt; right) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //如果左比右少（左大于0的时候可以添加左括号也可以添加右括号）（左等于0的时候只能添加右括号）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if (left &gt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                dfs(left-1, right ,ans+&quot;(&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            dfs(left, right-1 ,ans+&quot;)&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>TODO：动态规划（不理解）</p><p><a href="https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/</a></p><p>动态规划重点在于数学归纳法，再搞出前几个看一看，然后再递推！状态转移方程。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">(())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">()()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">((()))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">(()())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">(())()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">()(())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">()()()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">核心的思想是，考虑 i=n 时相比 n-1 组括号增加的那一组括号的位置。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">我们考虑整个括号排列中最左边的括号。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 &quot;( )&quot;，我们认为这一组是相比 n-1 增加进来的括号。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">作者：yuyu-13</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">链接：https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">来源：力扣（LeetCode）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;string&gt; generateParenthesis(int n) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(n == 0) return {};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(n == 1) return {&quot;()&quot;};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //组成括号的状态数组</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        vector&lt;vector&lt;string&gt;&gt; dp(n+1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dp[0] = {&quot;&quot;};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dp[1] = {&quot;()&quot;};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int i = 2; i &lt;= n; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            for(int j = 0; j &lt; i; j++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                for(string p : dp[j]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    for(string q : dp[i-j-1]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        string str = &quot;(&quot; + p + &quot;)&quot; + q;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        dp[i].push_back(str);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return dp[n];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="51-n-皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener noreferrer">51. N 皇后</a><a class="hash-link" href="#51-n-皇后" title="Direct link to heading">#</a></h4><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><p>回溯</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //存所有的结果</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;string&gt;&gt; res;             </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //存中间的某个结果</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//      TODO:设置初始值，这块不熟</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        vector&lt;string&gt;ans(n, string(n, &#x27;.&#x27;));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        /*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        从第0行开始，递归回溯。ans相当于在层级穿越时携带的袋子。用来装在每个房间找到的线索。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        暂时找到了就将其装到袋子里。ans[row][col] = &#x27;Q&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        然后进入下一层寻找，直到到达最后一层，表明找到一个结果。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        找</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dfs(0,n,ans);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return res;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //对于地址不变的变量，我们传引用就行</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    void dfs(int row, int &amp;n, std::vector&lt;std::string&gt; &amp;ans) {        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(row == n) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //找到了一个结果，返回</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            res.push_back(ans);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int col = 0; col &lt; n; col++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //看看这个皇后安排在哪里好</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(isValid(ans, row, col, n)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                ans[row][col] = &#x27;Q&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                //这一层的皇后已经安排好，进入下一层</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                dfs(row + 1, n, ans);//钻入下一层并返回。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                //回溯：从下层回来之后，要去遍历其他可能性，状态还原,进入同层的下个分支循环。（同层的换个房间试一试，并且把同层的上个房间生成的临时结果给清理干净）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                ans[row][col] = &#x27;.&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            //这个循环结束后，就进入了同层的下个房间，继续探索</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      //一个循环完了代表一层所有的房间都试过了！</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    /*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ans: 当前的排放结果</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    row: 要排放的行</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    col: 要排放的列</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bool isValid(std::vector&lt;std::string&gt; &amp;ans, int row, int col, int n) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //判断对应的列是否冲突（只和上面的比较就行）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int i = 0; i &lt; row; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(ans[i][col] == &#x27;Q&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //判断pie线是否冲突（只和上面的比较就行）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(ans[i][j] == &#x27;Q&#x27;) </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //判断na线是否冲突（只和上面的比较就行）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(ans[i][j] == &#x27;Q&#x27;) </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        //都不冲突</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="36-有效的数独"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener noreferrer">36. 有效的数独</a><a class="hash-link" href="#36-有效的数独" title="Direct link to heading">#</a></h4><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c++ codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Solution {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for(int i = 0; i &lt; 9; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            for(int j = 0; j &lt; 9; j++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                char ch = board[i][j];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if(ch != &#x27;.&#x27;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    //行</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    for(int col = 0; col &lt; 9; col++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        if(col != j &amp;&amp; ch == board[i][col]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                            return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    //列</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    for(int row = 0; row &lt; 9; row++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        if(row != i &amp;&amp; ch == board[row][j]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                            return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    //3*3方格(方格定位)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    int row_l = i/3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    int col_l = j/3;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    for(int i_k = row_l*3; i_k &lt; (row_l+1)*3; i_k++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        for(int j_k = col_l*3; j_k &lt; (col_l+1)*3; j_k++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                            if(j_k != j &amp;&amp; i_k != i &amp;&amp; board[i_k][j_k] == ch) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="37-解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener noreferrer">37. 解数独</a><a class="hash-link" href="#37-解数独" title="Direct link to heading">#</a></h4><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="双向bfs"></a>双向BFS<a class="hash-link" href="#双向bfs" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="127-单词接龙-1"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener noreferrer">127. 单词接龙</a><a class="hash-link" href="#127-单词接龙-1" title="Direct link to heading">#</a></h4><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第一遍：理解，背诵，提交通过</li><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 第二遍：自己写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第三遍：过一天后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第四遍：过一周后写</li><li class="task-list-item"><input type="checkbox" disabled=""> 第五遍：面试前恢复训练</li></ul><div class="mdxCodeBlock_1zKU"><code></code></div><p><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener noreferrer">433. 最小基因变化</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="启发式搜索（a）"></a>启发式搜索（A*）<a class="hash-link" href="#启发式搜索（a）" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="排序"></a>排序<a class="hash-link" href="#排序" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="1122-数组的相对排序"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener noreferrer">1122. 数组的相对排序</a><a class="hash-link" href="#1122-数组的相对排序" title="Direct link to heading">#</a></h3></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="dys-typora-open://mine/survival/docs/编程基础/数据结构与算法/练习/极客训练营过遍数.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#理论" class="table-of-contents__link">理论</a><ul><li><a href="#精通一个领域" class="table-of-contents__link"><strong>精通一个领域</strong></a></li><li><a href="#chunk-it-up" class="table-of-contents__link"><strong>Chunk it up</strong></a></li><li><a href="#deliberate-practicing" class="table-of-contents__link">Deliberate Practicing</a></li><li><a href="#feedback" class="table-of-contents__link">Feedback</a></li><li><a href="#切题四件套" class="table-of-contents__link">切题四件套</a></li><li><a href="#五步刷题法-五毒神掌" class="table-of-contents__link">五步刷题法 五毒神掌</a></li><li><a href="#⾃自顶向下的编程⽅方式" class="table-of-contents__link">⾃自顶向下的编程⽅方式</a></li></ul></li><li><a href="#数组，链表，跳表" class="table-of-contents__link">数组，链表，跳表</a><ul><li><a href="#数组" class="table-of-contents__link">数组</a></li><li><a href="#链表" class="table-of-contents__link">链表</a></li><li><a href="#跳表" class="table-of-contents__link">跳表</a></li></ul></li><li><a href="#深度优先搜索" class="table-of-contents__link">深度优先搜索</a><ul><li><a href="#102-二叉树的层序遍历" class="table-of-contents__link">102. 二叉树的层序遍历</a></li></ul></li><li><a href="#广度优先搜索" class="table-of-contents__link">广度优先搜索</a><ul><li><a href="#127-单词接龙" class="table-of-contents__link">127. 单词接龙</a></li><li><a href="#126-单词接龙-ii" class="table-of-contents__link">126. 单词接龙 II</a></li><li><a href="#102-二叉树的层序遍历-1" class="table-of-contents__link">102. 二叉树的层序遍历</a></li><li><a href="#433-最小基因变化" class="table-of-contents__link">433. 最小基因变化</a></li></ul></li><li><a href="#trie-字典树-前缀树" class="table-of-contents__link">trie-字典树-前缀树</a><ul><li><a href="#208-实现-trie-前缀树" class="table-of-contents__link">208. 实现 Trie (前缀树)</a></li><li><a href="#212-单词搜索-ii" class="table-of-contents__link">212. 单词搜索 II</a></li></ul></li><li><a href="#并查集-union" class="table-of-contents__link">并查集-union</a><ul><li><a href="#岛屿数量" class="table-of-contents__link">岛屿数量</a></li></ul></li><li><a href="#高级搜索" class="table-of-contents__link">高级搜索</a><ul><li><a href="#不重复记忆剪枝回溯" class="table-of-contents__link">不重复/记忆+剪枝/回溯</a></li><li><a href="#双向bfs" class="table-of-contents__link">双向BFS</a></li><li><a href="#启发式搜索（a）" class="table-of-contents__link">启发式搜索（A*）</a></li></ul></li><li><a href="#排序" class="table-of-contents__link">排序</a><ul><li><a href="#1122-数组的相对排序" class="table-of-contents__link">1122. 数组的相对排序</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.65a50636.js"></script>
<script src="/runtime~main.b175e2de.js"></script>
<script src="/main.777b260c.js"></script>
<script src="/1.5f7a006f.js"></script>
<script src="/260.fc337f83.js"></script>
<script src="/261.cd474b1f.js"></script>
<script src="/935f2afb.42cf00cb.js"></script>
<script src="/259.fa9b4b3b.js"></script>
<script src="/090f2256.7ba91d97.js"></script>
</body>
</html>