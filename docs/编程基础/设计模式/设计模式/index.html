<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Blog Atom Feed"><title data-react-helmet="true">设计模式 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="设计模式 | My Site"><meta data-react-helmet="true" name="description" content="title: 设计模式探析"><meta data-react-helmet="true" property="og:description" content="title: 设计模式探析"><meta data-react-helmet="true" property="og:url" content="http://localhost:9999//docs/编程基础/设计模式/设计模式"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="http://localhost:9999//docs/编程基础/设计模式/设计模式"><link rel="stylesheet" href="/styles.8cfbcdec.css">
<link rel="preload" href="/styles.1004da7c.js" as="script">
<link rel="preload" href="/runtime~main.74d3fe56.js" as="script">
<link rel="preload" href="/main.b81ad7fb.js" as="script">
<link rel="preload" href="/1.2fe752e0.js" as="script">
<link rel="preload" href="/259.96e24fb8.js" as="script">
<link rel="preload" href="/260.8c75c7b8.js" as="script">
<link rel="preload" href="/935f2afb.8492b0e9.js" as="script">
<link rel="preload" href="/258.d78093f4.js" as="script">
<link rel="preload" href="/e91d5df7.daa37b00.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">基础</a><a class="navbar__item navbar__link" href="/docs/编程语言/编程语言">语言</a><a class="navbar__item navbar__link" href="/docs/工具/常用工具">工具</a><a class="navbar__item navbar__link" href="/docs/应用开发/应用开发">应用开发</a><a class="navbar__item navbar__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a><a class="navbar__item navbar__link" href="/docs/音视频/音视频">音视频</a><a class="navbar__item navbar__link" href="/docs/项目/项目">项目</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Search" aria-label="Search" class="navbar__search-input search-bar"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程语言/编程语言">语言</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/工具/常用工具">工具</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/应用开发/应用开发">应用开发</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/音视频/音视频">音视频</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/项目/项目">项目</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">编程基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/学习经验/学习经验">学习经验</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/数字电路/数字电路">数字电路</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机组成原理/计算机组成原理">计算机组成原理</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/操作系统/操作系统">操作系统</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机网络/计算机网络">计算机网络</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机系统基础/计算机系统基础">计算机系统基础</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">编译链接调试</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/编译原理/编译原理">编译原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/编译原理/程序员的自我修养">程序员的自我修养</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">数据结构与算法</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/数据结构与算法">数据结构与算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/数据结构">数据结构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/算法">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/算法面试">算法面试</a></li></ul></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" href="/docs/编程基础/设计模式/设计模式">设计模式</a></li></ul></div></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">设计模式</h1></header><div class="markdown"><p>title: 设计模式探析
toc: true
date: 2018-10-24 12:46:58
tags:
categories: [编程基础]</p><hr><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="前言"></a>前言<a class="hash-link" href="#前言" title="Direct link to heading">#</a></h2><p>解决： 稳定中有变化的问题。</p><p>稳定的部分是抽象。</p><p>设计模式是为了解决特定环境下人们解决某类重复出现的问题的一套成功或有效的解决方案。</p><p>每个模式都描述了在我们的环境中不断出现的问题，然后描述了解决方案的核心，通过这种方式，我们可以无数次重用那些已有的成功的解决方案，无需在重复相同的工作。</p><p>设计模式是为了解决问题而产生的。碰到某个问题，按照某个套路来是最方便的。比如 对象的创建，我们通过工厂方法模式，将对象的创建封装起来，解决了对象的复杂性，可以简化对象的创建工作。</p><p>“在一定的环境下，用固定的套路去解决问题！”</p><p>GOF提出的设计模式有23个。</p><p>面向对象编程的三大特性：封装，继承，多态。经常说这三大特性，却从来都没有去认真考虑过为什么会有这三大特性？（所以说啊在学习一个新知识的时候多问问为什么？能加深我们对知识的理解）</p><p>先说说编程中会出现的问题：</p><ol><li><p>维护简单-----修改一段程序尽量少的产生影响，这就需要用到封装-单一职责原则，一个类只负责一件事情，对外提供接口，好维护，对该类的修改不对或少对外界产生影响。</p></li><li><p>容易扩展-----新增功能用扩展，对原有的类尽量少的产生影响，（因为你如果修改原有的类，原有的类可能在很多地方有使用，一但出bug，影响比较大，为了保持稳定，新增功能尽量不要修改原类）。怎么用扩展，继承抽象基类，抽象基类负责定义接口，子类负责实现，这也就是多态。实例化的时候是子类实例化，调用的时候是基类的方法（开闭原则和里氏替换原则）。</p></li><li><p>方便复用-----一个功能写过了，下次用的时候直接拿过来使，提高效率。对应封装特性。解耦合的方法也是封装，通过api进行交互，比如类的创建，工厂模式。</p></li><li><p>灵活性好</p></li></ol><p>由以上需求和想达到的目的便很容易得出为什么会有封装，继承，多态，三大特性了。掌握这三大特性，要写出优美的程序，就要借助设计模式了。</p><p>本质上是使类的增加，修改和使用更加顺畅。如果这个做不到就要考虑是不是设计模式的问题。</p><p>开闭原则的核心是：对扩展开放，对修改关闭。白话意思就是我们改变一个软件时（比如扩展其他功能），应该通过扩展的方式来达到软件的改变，而不应该修改原有的代码来实现变化。</p><p>面向对象软件开发需要如下3步。</p><ul><li>OOA面向对象分析</li><li>OOD面向对象设计</li><li>OOP面向对象编程</li></ul><p>[toc]</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="设计模式概述"></a>设计模式概述<a class="hash-link" href="#设计模式概述" title="Direct link to heading">#</a></h2><p>设计模式的基础是：多态！</p><p>简单来说就是父类指针可以指向子类对象。</p><p>设计模式是站在一个软件工程的角度来思考问题，而不是站在一个功能如何实现的角度。注意：角度要变化。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="设计模式原则"></a>设计模式原则<a class="hash-link" href="#设计模式原则" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="单一职责原则"></a>单一职责原则<a class="hash-link" href="#单一职责原则" title="Direct link to heading">#</a></h3><p>就一个类而言，应该仅有一个引起他变化的原因。</p><p><strong>界面表示逻辑，说白了就是根据数据进行绘制的逻辑</strong></p><p><strong>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离</strong> 这是一种能力。</p><p>判断是否需要分离出类来，其实就是如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。</p><p>对设计-复用而言。</p><p>“对于单一职责原则，我的建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books. </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="开放-封闭原则"></a>开放-封闭原则<a class="hash-link" href="#开放-封闭原则" title="Direct link to heading">#</a></h3><p>对修改关闭，对扩展开放。</p><p>一个国家，两种制度。不能修改，但是可以扩展。</p><p>举个例子：对工作时间和业绩成效修改关闭，但是对时间制度扩展开发。</p><ol><li>尽量让这个类足够好，写好了就不去修改了，新需求来增加一个类，原来的代码能不动则不动。</li><li>类是不可能完全封闭的，所以设计类的时候，应该猜测最有可能变化的地方，然后构造抽象来隔离那些变化。</li><li>最初写代码时，假设不会发生变化，当变化发生的时候，我们就创建抽象类来隔离以后发生的同类变化。</li></ol><p>面向对象的核心所在。遵循此原则，可写出可维护，可扩展，可复用，灵活性好的代码。</p><p>对修改而言。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="依赖倒转原则"></a>依赖倒转原则<a class="hash-link" href="#依赖倒转原则" title="Direct link to heading">#</a></h3><p>定义</p><ul><li><p>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的</p></li><li><p>接口或抽象类不依赖于实现类；</p></li><li><p>实现类依赖接口或抽象类。</p></li></ul><p>强内聚，松耦合。intel。</p><p>高层模块不应该依赖低层模块。两个都依赖抽象。</p><p>抽象不应该依赖细节，细节却依赖抽象。--- 针对接口编程，不要对实现编程。</p><p>举例：主板，cpu，内存，硬盘都是针对接口设计的。如果针对实现设计那就是针对某个品牌的的设计，这样就不统一，电脑维修起来也就没有现在这么容易了。</p><p>倒转：正常是高层模块依赖低层模块。现在不依赖了，都依赖抽象-标准。</p><p>比如正常来说一个黄金钱包的banner实现，依赖黄金钱包的数据结构，同样白金钱包的banner依赖白钱包的数据结构，这叫高层模块依赖底层模块。这样banner就得对每个平台做定制。不想做定制的话，banner就不能依赖具体平台实现的细节，而是依赖一个抽象的协议接口。然后每个平台根据协议接口提供数据即可。这样高层模块就依赖于抽象，独立于每一个平台，这样就可以复用了。</p><p>对设计-复用而言。</p><p>“那到底什么是“倒置”呢？我们先说“正置”是什么意思，依赖正置就是类间的依赖是实实在在的实现类间的依赖，也就是面向实现编程，这也是正常人的思维方式，我要开奔驰车就依赖奔驰车，我要使用笔记本电脑就直接依赖笔记本电脑，而编写程序需要的是对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维中的事物间的依赖，“倒置”就是从这里产生的”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books. </p><p>大家只要记住是“面向接口编程”就基本上抓住了依赖倒置原则的核心。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="几个规则"></a>几个规则<a class="hash-link" href="#几个规则" title="Direct link to heading">#</a></h4><ol><li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</li></ol><ol start="2"><li>变量的表面类型尽量是接口或者是抽象类</li></ol><p>表面类型也就是编译类型。</p><ol start="3"><li>任何类都不应该从具体类派生</li></ol><ol start="4"><li>尽量不要覆写基类的方法</li></ol><ol start="5"><li>结合里氏替换原则使用</li></ol><p>切记凡事无绝对，要审时度势，具体问题具体分析，必须要依赖具体类的实现细节的时候，就不能墨守成规不知变通啦。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="里氏替换原则"></a>里氏替换原则<a class="hash-link" href="#里氏替换原则" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="定义"></a>定义<a class="hash-link" href="#定义" title="Direct link to heading">#</a></h4><p>所有引用基类的地方必须能透明地使用其子类的对象</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4层含义"></a>4层含义<a class="hash-link" href="#4层含义" title="Direct link to heading">#</a></h4><p>“1.子类必须完全实现父类的方法”</p><p>“2.子类可以有自己的个性”</p><p>“3.覆盖或实现父类的方法时输入参数可以被放大”</p><p>“4. 覆写或实现父类的方法时输出结果可以被缩小”</p><p>子类型必须能够替换掉他们的父类型。</p><p>编程世界里面，企鹅不能继承鸟类。</p><p>重要： <strong>高层模块和低层模块都依赖于接口或者抽象类。</strong></p><p>依赖倒转是面向对象设计的标志。编写时考虑的都应该是针对抽象编程，而不是针对细节编程。程序中多有的依赖关系都是终止于抽象类或者接口，那就是面向对象设计，反之就是面向过程的设计了。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="迪米特法则"></a>迪米特法则<a class="hash-link" href="#迪米特法则" title="Direct link to heading">#</a></h3><p>也叫：“最少知识原则”</p><p>“一个对象应该对其他对象有最少的了解。”</p><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>一个软件实体应当尽可能少地与其他实体发生相互作用。</p><p>应该多和抽象发生相互作用，少和实体发生作用。</p><p>实体去实现抽象，替代抽象。可以解耦合。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">-(void)loadData:(id&lt;CVGBannerItemAdapterProtocol&gt;)adapterData{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    self.adapterData = adapterData;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //图片加载</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SDImageCache *adImageCache = [SDWebImageManager sharedManager].imageCache;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSURL * imageUrl = [NSURL URLWithString:[adapterData imageUrlString]];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    UIImage * shareImage = [adImageCache imageFromDiskCacheForKey:[adapterData imageUrlString]];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (shareImage) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        self.imageView.image = shareImage;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        [[SDWebImagePrefetcher sharedImagePrefetcher] prefetchURLs:@[imageUrl]];// 再去静默下载一次</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }else{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        [self.imageView sd_setImageWithURL:imageUrl placeholderImage:[UIImage imageNamed:[self.adapterData placeHolderImageName]]];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>例如：adapterData 就是抽象，而不是实体。这样任何继承<code>CVGBannerItemAdapterProtocol</code>协议的对象都可以适配此方法。</p><p>抽象也是指可替代。</p><p>如果两个类不必直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>类之间的松耦合。</p><p>耦合越弱，越有利于复用。</p><p>耦合的朋友类：</p><p>“朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类，”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books. </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="合成聚合复用原则"></a>合成/聚合复用原则<a class="hash-link" href="#合成聚合复用原则" title="Direct link to heading">#</a></h3><p>（大话设计模式）</p><p>合成-composition</p><p>聚合-aggregation</p><p>CARP-合成/聚合复用原则 尽量使用合成聚合，尽量不要使用类继承。</p><p>和单一职责原则有相通之处。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="接口隔离原则"></a>接口隔离原则<a class="hash-link" href="#接口隔离原则" title="Direct link to heading">#</a></h3><p>（设计模式之禅）</p><p>以上把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，让星探AbstractSearcher依赖两个专用的接口比依赖一个综合的接口要灵活。接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。</p><ul><li><p>Clients should not be forced to depend upon interfaces that they don&#x27;t use.（客户端不应该依赖它不需要的接口。）</p></li><li><p>The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）”</p></li></ul><p>4层含义：</p><ol><li>接口要尽量小</li><li>接口要高内聚</li><li>定制服务</li><li>接口设计是有限度的</li></ol><p>几个规则来衡量：</p><p>● 一个接口只服务于一个子模块或业务逻辑；</p><p>● 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；</p><p>● 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；</p><p>● 了解环境，拒绝盲从。</p><ul><li>封装：</li></ul><p>单一职责原则</p><p>迪米特法则</p><p>合成聚合原则</p><p>接口隔离原则</p><ul><li>继承、多态：</li></ul><p>开放封闭原则</p><p>依赖倒置原则</p><p>里式替换原则</p><p>总结：继承多发生在接口/抽象类 和 实体类之间，两个实体类之间少用继承。  封装多发生在功能实现方面。整体原则，多用封装，少用继承。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="设计模式"></a>设计模式<a class="hash-link" href="#设计模式" title="Direct link to heading">#</a></h2><p><img alt="0_1315383177t29F" src="/assets/images/0_1315383177t29F-97cf13111c2848096b983e90b37a7e90.gif"></p><p><img alt="2799767-5a0e372d3b886348" src="/assets/images/2799767-5a0e372d3b886348-7a0d5e619fceedaaca91dd9bf89dd58b.jpeg"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="对象创建"></a>对象创建<a class="hash-link" href="#对象创建" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="原型模式"></a>原型模式<a class="hash-link" href="#原型模式" title="Direct link to heading">#</a></h4><p>创建一个新对象是，不在重新创建，而是从原型那里拷贝一个过来，改一改就行。</p><p>比如paastest的用户上线的cellmodel。</p><p>类似的iOS中的原型模式有</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@protocol NSCopying</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)copyWithZone:(nullable NSZone *)zone;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@protocol NSMutableCopying</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)mutableCopyWithZone:(nullable NSZone *)zone;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@implementation DYSStudent2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (instancetype)initWithName:(NSString *)name age:(NSInteger)age grade:(NSInteger)grade {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    self = [super init];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (self) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        _name = name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        _age = age;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        _grade = grade;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return self;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (id)copyWithZone:(NSZone *)zone {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    DYSStudent2 *student = [[[self class] allocWithZone:zone] initWithName:self.name age:self.age grade:self.grade];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return student;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>demo：<a href="https://github.com/DingYusong/PrototypePattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/PrototypePattern</a></p><p>类似工厂方法的合并了。</p><p>保存当前状态。 保留中间状态。</p><p>C++的拷贝构造函数。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="简单工厂模式"></a>简单工厂模式<a class="hash-link" href="#简单工厂模式" title="Direct link to heading">#</a></h4><ol><li><p>体现了里氏替换原则：任何基类可以出现的地方，子类一定可以实现。</p></li><li><p>利用了面向对象的三大特性（封装继承多态）。</p></li><li><p>解决了对象创建问题。</p></li></ol><p>好处是，封装了选择类的细节。</p><p>demo：<a href="https://github.com/DingYusong/SimpleFactory" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/SimpleFactory</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="工厂方法模式"></a>工厂方法模式<a class="hash-link" href="#工厂方法模式" title="Direct link to heading">#</a></h4><p>demo：<a href="https://github.com/DingYusong/FactoryMethod" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/FactoryMethod</a></p><p><code>NSArray/NSDictionary/NSSet</code>都有下面一个方法，返回<code>NSEnumerator</code>对象，此为工厂方法模式。抽象工厂是工厂类有一个抽象，或是接口，或是抽象基类。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (NSEnumerator&lt;ObjectType&gt; *)objectEnumerator;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="抽象工厂模式"></a>抽象工厂模式<a class="hash-link" href="#抽象工厂模式" title="Direct link to heading">#</a></h4><p>关键点在于一系列。一系列有相关性，相关性就放在一起。 关联性。family factory。家族工厂。</p><p>提供一个创建一系列相关或相互依赖的接口，而无需指定他们具体的类。</p><p><code>反射</code>和<code>依赖注入</code>。</p><p>demo：<a href="https://github.com/DingYusong/AbstractFactory" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/AbstractFactory</a></p><blockquote><p>简单工厂、工厂方法和抽象工厂都是创建型的设计模式。</p><p>三者的<strong>共同点</strong>是：</p><p>1、都有两种作用不同的类：产品类和工厂类。其中，工厂类在自己的方法中实例化产品类（即使用new命令生成产品类的对象），并将生成的产品类的对象提供给外部使用。</p><p>2、创建的过程，都是类似的：工厂类得到一个标志（可以由程序输入，也可以读取配置文件中的内容），返回一个产品对象。 </p><p>三者的<strong>不同点</strong>：</p><p>1、简单工厂</p><p>简单工厂方法中，包括一个“抽象产品类”（该类可以是接口Interface，也可以是实际的类Class），所有需要的产品类都是该“抽象产品类”的子类（如果是接口的话，那么就是说所有产品类都继承了该接口）。</p><p>简单工厂一般只包含一个具体的工厂类，由该工厂类生成所有的产品类的对象。生成产品类的方法，其内部一般是类似于switch的结构，根据输入的标志，选择创建不同类型的对象。由于不知道创建的对象到底是哪个类的，所以方法的返回值的类型是“抽象产品类”。</p><p>2、工厂方法</p><p>抽象工厂中，包括“抽象工厂类”和“抽象产品类”，同时包含不只一个工厂类。所有的工厂类都必须是“抽象工厂类”的子类，所有的产品都必须是“抽象产品类”的子类。</p><p>和简单工厂比起来，工厂方法一般是从抽象工厂开始的。一般都是在抽象工厂类中提供一个静态方法，由该方法根据输入的标志，生成不同的具体工厂类，然后由具体的产品类生成具体的产品。注意，一个具体工厂类只能生成一种具体的产品类的对象，不同的具体工厂生成不同的产品，而不是像简单工厂中那样，一个工厂类可以生成多种不同产品类的对象。可以这么理解，在选择不同的具体工厂类的时候，就选择了生成的产品，相对于简单工厂，相当于将选择产品的动作提前了。</p><p>因为不知道创建的具体工厂类到底是哪一个，所以生成具体工厂类的静态方法的返回值的类型是“抽象工厂类”。具体工厂类生成产品类的方法，返回值的类型也要求是“抽象产品类”（因为前端调用的时候，需要使用同样的代码来访问）。 </p><p>3、抽象工厂</p><p>抽象工厂和工厂方法很类似，区别如下： </p><p>工厂方法模式：
一个抽象产品类，可以派生出多个具体产品类。<br>
一个抽象工厂类，可以派生出多个具体工厂类。<br>
每个具体工厂类只能创建一个具体产品类的实例。 </p><p>抽象工厂模式：
多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。<br>
一个抽象工厂类，可以派生出多个具体工厂类。<br>
每个具体工厂类可以创建多个具体产品类的实例。<br>
区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。<br>
工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="建造者模式"></a>建造者模式<a class="hash-link" href="#建造者模式" title="Direct link to heading">#</a></h4><p>讲一个复杂对象的创建和他的表示分离，使得同样的构建过程，可以创建不同的表示。</p><p>过程定义类。</p><p>指挥者类。</p><p>画小人。</p><p>demo: <a href="https://github.com/DingYusong/BuilderModel" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/BuilderModel</a></p><p>创建一个复杂的组合对象。</p><p>如果一个类组合对象非常复杂，那么可以把，这个组合对象类的构建抽象出来，分布解决。</p><p>engine对象的创建和enginebase对象的创建，可以用建造者模式。</p><p>C++不能再析构函数里调用。</p><p>建造过程抽出来：导演类。</p><p>复杂就拆，简单就合并。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="单例模式"></a>单例模式<a class="hash-link" href="#单例模式" title="Direct link to heading">#</a></h4><p><strong>使用的原因/场景</strong></p><p>我们只需要一个全局的对象。</p><p>比如<code>UIApplication</code> 一个应用程序只能有一个。</p><p><strong>维护/修改</strong></p><p>修改的话，是修改唯一的实例。</p><p>保证一个类有且仅有一个实例，并提供一个访问他的全局访问点。</p><p>全局只有一个</p><p>demo： <a href="https://github.com/DingYusong/Singleton" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/Singleton</a></p><p>ios中的使用场景：</p><p>参考：iOS中究竟用到了哪些设计模式 ：<a href="https://juejin.cn/post/6844904098144190477" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904098144190477</a></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">整个应用程序需要共享一份资源的时候，可以考虑使用单列</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">[UIApplication sharedApplication];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">[NSNotificationCenter defaultCenter];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">[NSFileManager defaultManager];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">[NSUserDefaults standardUserDefaults];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">[NSURLCache sharedURLCache];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">[NSHTTPCookieStorage sharedHTTPCookieStorage];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">作者：老郑的技术杂货铺</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">链接：https://juejin.cn/post/6844904098144190477</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">来源：掘金</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><img alt="image-20210310141743547" src="/assets/images/image-20210310141743547-cc7461d50d4d38c21910a1ebe6f6611a.png"></p><p>对象性能。</p><p>虚函数。</p><p>线程安全。</p><p>普通加锁。效率不高</p><p>双检查锁。内存读写reorder不安全。指令序列有可能和我们的代码不一样。构造指令。只是分配了一个内存，而没有初始化。</p><p>​	关键字：volatile</p><p>​	</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="接口隔离"></a>接口隔离<a class="hash-link" href="#接口隔离" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="适配器模式"></a>适配器模式<a class="hash-link" href="#适配器模式" title="Direct link to heading">#</a></h4><p>将一个类的接口转换成客户希望的另外一个接口。使得原来接口不兼容而不能一起工作的类，可以一起工作。</p><p>新建一个类，继承原来的类，然后在添加一个新的接口。  修改的是对象的接口。</p><p>通过：新增一个子对象，和一个接口解决问题。不改变原有的类。</p><p>比如RZEngineKit 和 rtcEngine。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> @interface RZRtcEngineKit : NSObject</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>RZEngineKit 不继承 rtcEngine，而是以依赖的方式，引用rtcEngine，对其进行封装。</p><p>类比电源适配器。</p><p>继承需要适配的类，复写需要适配的方法，保持接口不变。</p><p>一般用来对以往的坑进行修补。修改已经存在的类。</p><p>Demo： <a href="https://github.com/DingYusong/AdapterPattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/AdapterPattern</a></p><p>涉及的对象：</p><ol><li>被适配的类（能提供功能，但是接口不符合要求）（不需要任何改变）</li><li>适配器类（将被适配的类接口转接一下，从而对外界提供功能）（满足需求：实现接口和抽象类）</li><li>客户端（知道自己需要什么）（从需求出发：定义接口和抽象类-抽象适配器）</li><li>抽象类或者接口。（被客户端依赖的抽象类或者接口，需要被适配器类实现）</li></ol><p>使用场景：原来有客户端（原来存在），知道自己要什么接口的客户端，也有客户端依赖的抽象类或者接口（原来存在），要使用一个原来存在的被适配类（原来存在），所以要增加一个适配器类（新增的）来粘合客户端和被适配类。</p><p>设计模式原则：</p><p>1.单一职责原则。</p><p>2.开放封闭原则：没有修改被适配类，而是扩展了他。</p><p>3.依赖倒置原则：客户端依赖的是抽象适配器类/接口。</p><p>4.理氏替换原则：当实体适配器类发生变化的时候，客户端，只需要修改适配器类的子类实例化即可。</p><p>5.合成聚合原则：被适配的类和适配器类是合成关系。</p><p>6.接口隔离原则：抽象适配器类可以有多个以满足接口粒度细化。</p><p>7.迪米特法则：如果这个类是外界传进来的，则依赖抽象而不是具体的类。</p><p>例如：电源适配器</p><p>手机需要的电压是5V，而家庭电压是220V，家庭电压就是被适配的类（adaptee），而充电器则充当了适配器类（adapter）的角色。</p><p>类适配器-&gt;不灵活。没有动态性。</p><p>接口适配器</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="桥接模式"></a>桥接模式<a class="hash-link" href="#桥接模式" title="Direct link to heading">#</a></h4><p>理解：这个桥，是通过成员变量，也就是聚合的关系来组织的。这个桥依赖的也是抽象。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@protocol DYSAbstractHandsetBrandProtocol &lt;NSObject&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@property (nonatomic, weak) id&lt;DYSHandsetSoftProtocol&gt; soft;//相当于是一个bridge。抽象依赖实现的抽象</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)run;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>抽象化(Abstraction)与实现化(Implementation)脱耦。抽象调用实现的抽象。</p><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。 怎么分离呢？实现也抽象化。抽象依赖实现的抽象。</p><p>如何从实现中把抽象分离出来⽽又要让它们联系在一起。</p><p>桥接模式是把⼀个接口适配到不同接⼝的⼀种方式。</p><p>直观的认识：</p><p>两个抽象类链接成一个桥。</p><p>手机品牌抽象类和手机软件抽象类，组成桥接模式。</p><p>桥接模式用了合成/聚合模式。没有用类继承。正常思考是手机运行app的基类，然后子类复写运行方法。但是这样是一种强耦合，想一想变化的点在于运行这个动作，使用合成将运行这个动作抽象出来，要比子类复写要灵活的多！</p><p>涉及的对象：</p><ol><li>抽象方法类。（被聚合类，例如手机软件接口类）</li><li>抽象主类。（聚合 抽象方法类，知道自己需要的功能，给被聚合类提供接口）</li><li>抽象方法的实体类。</li><li>抽象主类的实体类。</li></ol><p>使用场景：当一个类变化较大，且其方法或者属性变化也比较大的时候，适用桥接模式。</p><p>设计模式原则：</p><ol><li>单一职责原则。被聚合类属于被分离的单一职责类。</li><li>开放封闭原则。没有修改原来的类，而是使用实体类去扩展了他们。</li><li>依赖倒置原则。主体抽象类依赖抽象方法类。</li><li>理氏替换原则。对于被适配类的调用使用了父类指向子类。</li><li>合成聚合原则。很显然是符合聚合原则。</li><li>接口隔离原则。</li><li>迪米特法则。两个实体类没有直接交互，主类依赖的是抽象类。</li></ol><p>Demo: <a href="https://github.com/DingYusong/BridgePattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/BridgePattern</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="外观模式-facade"></a>外观模式-Facade<a class="hash-link" href="#外观模式-facade" title="Direct link to heading">#</a></h4><p>封装接口，迪米特法则，依赖倒转原则</p><p>为系统中的⼀组接口提供一个统一的接口。外观定义一个高层接口，让子统更更易于使用。</p><p>为子系统的一组接口提供简化的接口。</p><p>直观的认识：对外界暴露一个高度抽象的功能接口，而不没必要暴露细节。</p><p>比如封装OpenSSL功能，给OC提供功能。</p><p>涉及的类</p><ol><li>外观类。需要增加的类，调用子系统的其他接口。给客户端提供一个统一的接口。</li></ol><p>设计模式原则：</p><ol><li>迪米特法则。客户端和子系统的类不必直接交互。</li><li>依赖倒转原则。客户端依赖抽象的接口。</li></ol><p>DEMO: <a href="https://github.com/DingYusong/FacadePattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/FacadePattern</a></p><p>网络请求库的封装。网络请求框架的变化不影响网络请求的功能。简化接口。</p><p>架构层级。 </p><p>相互耦合关系比较大的一系列组件。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="代理模式"></a>代理模式<a class="hash-link" href="#代理模式" title="Direct link to heading">#</a></h4><p>我主动要求的他人的承诺（我提供protocol，其他的类来实现，那么实现protocol的类可以为我所用，而那些实现我的要求的类，则成为代理）。如果不是我要求的承诺（角色转换），而是我主动提供的承诺，那叫接口。</p><p>代理模式有被动性，接口则有主动性。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="对象去耦合"></a>对象去耦合<a class="hash-link" href="#对象去耦合" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="中介者模式"></a>中介者模式<a class="hash-link" href="#中介者模式" title="Direct link to heading">#</a></h4><p>MediatorPattern</p><p>用一个对象来封装⼀系列对象的交互方式。中介者使各对象<strong>不需要显式地相互引用</strong>（编译时依赖-&gt;运行时依赖），从而使其藕合松散，而且可以独立地改变它们之间的交互。</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="ios项目应用"></a>iOS项目应用<a class="hash-link" href="#ios项目应用" title="Direct link to heading">#</a></h5><ol><li>MVC模式中的Controller。model和View不直接交互。通过控制器来交互。</li><li>页面路由解耦。页面路由为中介者，页面之间的交互都通过路由来处理，页面之间不直接交互。</li></ol><p>Demo地址：<a href="https://github.com/DingYusong/MediatorPattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/MediatorPattern</a></p><p>新增时不需要修改原有代码。符合开闭原则。</p><p>解耦系统内。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="观察者模式"></a>观察者模式<a class="hash-link" href="#观察者模式" title="Direct link to heading">#</a></h4><p>发布订阅模式。</p><p>开闭原则，继承和多态。</p><p>依赖倒置原则-面向接口编程。</p><p>demo：<a href="https://github.com/DingYusong/ObserverPattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/ObserverPattern</a></p><p><strong>观察者模式(Observer Pattern)</strong>： 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p><p>观察者模式是一种<strong>对象行为型模式</strong>。</p><p>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><p>细究的话，发布订阅和观察者有些不同，可以理解成发布订阅模式属于广义上的观察者模式。</p><p>作者：贾不假
链接：<a href="https://juejin.cn/post/6844904100459446285" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904100459446285</a>
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="抽象集合"></a>抽象集合<a class="hash-link" href="#抽象集合" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="组合模式"></a>组合模式<a class="hash-link" href="#组合模式" title="Direct link to heading">#</a></h4><p>树形结构</p><p>demo： <a href="https://github.com/DingYusong/CompositePattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/CompositePattern</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="迭代器模式"></a>迭代器模式<a class="hash-link" href="#迭代器模式" title="Direct link to heading">#</a></h4><p>提供一种方法，顺序访问一个聚合对象的各个元素，而又不暴露对象的内部表示。</p><p>循环遍历。</p><p>迭代器器提供了了⼀一种顺序访问聚合对象（集合）中元素的⽅方法，⽽而⽆无需暴暴露露结构的底层表示</p><p>细节</p><p>指针。</p><p>demo：<a href="https://github.com/DingYusong/IteratorPattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/IteratorPattern</a></p><p>C++有泛型迭代器（编译时多态）更高效。其他语言倒也有。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="行为拓展"></a>行为拓展<a class="hash-link" href="#行为拓展" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="访问者模式-visitor"></a>访问者模式-visitor<a class="hash-link" href="#访问者模式-visitor" title="Direct link to heading">#</a></h4><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类(男人，女人)的前提下定义作用于这些元素的新操作(喜怒哀乐)。他把数据结构(男人，女人)和作用于数据结构之上的操作(喜怒哀乐)之间的耦合解脱开，使得操作集合可以相对自由地演化。</p><p>访问者模式的目的：把处理从数据处理从数据结构中分离出来。比较稳定的数据结构和易于变化的操作。访问者模式的优点是增加操作和方便。</p><p>设计的类：</p><ol><li>访问者类 - 定义针对元素的新操作</li><li>元素类 - 露出一个针对访问者抽象类的接口</li></ol><p>demo：<a href="https://github.com/DingYusong/VisitorPattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/VisitorPattern</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="装饰模式"></a>装饰模式<a class="hash-link" href="#装饰模式" title="Direct link to heading">#</a></h4><p>动态的给一个类增加额外的职责。就增加功能来说，装饰模式比子类更加灵活。</p><p>优点： 把类的装饰功能从类中搬移去除，这样可以简化原有的类。</p><p>优点：有效的把类的核心职责和装饰功能分开了。而且可以去除相关类中的重复装饰逻辑。</p><p>装饰模式要注意装饰顺序。</p><p>比如说要拿到合适的格式的数据，可能是为了持久化，一开始只是做了简单的过滤，后来需要增加错误数据的纠正逻辑，则可以用装饰模式。</p><p>用了继承和多态。</p><p>注意：装饰类之间是平级的，他们的组合不是通过继承，而是通过组合。这是核心所在。好处在于，组装的灵活性。</p><p>用继承也行，但是在多个装饰出现的时候，就得增加低级别的子类，很麻烦，且不够零活。</p><p>demo:<a href="https://github.com/DingYusong/DecoratorPattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/DecoratorPattern</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="职责链模式"></a>职责链模式<a class="hash-link" href="#职责链模式" title="Direct link to heading">#</a></h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>   职责链模式：实际上是在应对处理一个或者一类问题上的结构性优化。是多个管理者在处理一个问题上森严的等级关系。每个管理者，都只有能处理或者不能处理两种情况。那么，管理者或者说等级关系可能是不稳定的。职责链的本质是，不同的类对同一个问题的反应。</p><ol><li>单一职责原则 （链中的对象不需要知道链中的结构，只需要好好处理自己这一环就行。）不需要知道所有的候选者，只要保持一个后继者的引用即可。</li></ol><p><a href="https://github.com/DingYusong/ResponseChainPattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/ResponseChainPattern</a></p><p>链表结构。</p><p>举例：</p><ol><li>古代妇女的枷锁。--设计模式之禅第二版</li></ol><ol start="2"><li>请假。 oc编程之道</li></ol><p>3天假，经理批准。5天假期需要部门主管批准。30天假得老板批准。 处理不了就网上抛。</p><p>ios的事件响应机制。</p><p>1.责任链设计模式使用的是非常广泛的，iOS中的事件响应机制也是此设计模式的应用。之前有个登录完后要弹多个协议，那时候拿if.else判断，也是搞的头痛不已。最大的好处就是使用的时候省去了判断，不用担心给谁处理。</p><p>作者：某非著名程序员
链接：<a href="https://www.jianshu.com/p/a2ea6e8ee0e7" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/a2ea6e8ee0e7</a>
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>史上最详细的iOS之事件的传递和响应机制-原理篇： <a href="https://www.jianshu.com/p/2e074db792ba" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/2e074db792ba</a></p><p>链表</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="状态模式"></a>状态模式<a class="hash-link" href="#状态模式" title="Direct link to heading">#</a></h4><p>把分支想办法变成一个一个的类，增加时不会影响其他类，状态的变化在各自类中完成。不同的状态，不同的响应。</p><p>状态类</p><p>和</p><p>控制类。</p><p>状态类继承状态抽象类，根据控制类的数据实现状态方法。</p><p>控制类调用状态类方法。</p><p>抽象类，继承，多肽。</p><p>   状态模式：实际上子状态是从单个类中独立出去的，因此其整体的功能是一个完整的类的功能。只不过我们把这个类对不同情况的响应写在了一个类中，致使其扩展性不好。所以我们，才把它的不同响应行为独立成状态子类，以赋予它良好的对新需求的扩展性。其本质是，一个类对不同状态的多种不同响应。</p><p><a href="https://blog.csdn.net/zhuojiajin/article/details/17138061" target="_blank" rel="noopener noreferrer">状态模式 VS 职责链模式</a></p><p>demo: <a href="https://github.com/DingYusong/StatePattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/StatePattern</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="算法封装"></a>算法封装<a class="hash-link" href="#算法封装" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="模板方法模式"></a>模板方法模式<a class="hash-link" href="#模板方法模式" title="Direct link to heading">#</a></h4><p><a href="https://github.com/DingYusong/TemplateMethodPattern" target="_blank" rel="noopener noreferrer">https://github.com/DingYusong/TemplateMethodPattern</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="策略模式"></a>策略模式<a class="hash-link" href="#策略模式" title="Direct link to heading">#</a></h4><p>封装变化点。</p><p>继承有助于析取这些算法中的公共功能。</p><p>策略模式和简单工厂模式结合解耦。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="命令模式"></a>命令模式<a class="hash-link" href="#命令模式" title="Direct link to heading">#</a></h4><p>命令模式3要素：</p><ol><li><p>命令接受者</p></li><li><p>命令</p></li><li><p>命令执行者</p></li></ol><p>（不同的类，写在外面，作为一个参数传入）</p><p> 将⼀个请求封装为⼀个对象，从而使你可⽤不同的请求对客户进行参数化;对请求排队或记录日志，以及支持可撤销的操作。</p><p>“我不管你们内部怎么安排，你就给我找个接头负责人，我告诉他怎么做，删除页面，增加功能，你们内部怎么处理我不管，我就告诉他我要干什么就成了……”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books. </p><p>“完美的项目也与此类似，客户发送一个删除页面的命令，接头负责人Invoker接收到命令后，立刻执行DeletePageCommand的execute方法。”</p><p>摘录来自: . “设计模式之禅（第2版）（华章原创精品）。” Apple Books. </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="性能"></a>性能<a class="hash-link" href="#性能" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="享元模式"></a>享元模式<a class="hash-link" href="#享元模式" title="Direct link to heading">#</a></h4><p>节约内存。</p><p>运用共享技术有效地支持大量细粒度对象的复用。--《设计模式》GoF</p><p>字符串。</p><p>字符串池。</p><p>文字的字体对象的解决。</p><p><strong>iOS的使用场景</strong></p><p>cell的复用。</p><p><strong>单例和享元的区别：</strong></p><p>你要先理解创建实例和实例变化的区别：</p><ul><li>创建实例：var s = new StringBuilder();</li><li>实例变化：s.append(&quot;changed&quot;);</li><li>实例不能变化：String s = &quot;cannot-change&quot;;</li></ul><p>单例不是不变，是不允许创建新实例。</p><p>享元要求实例不变，所以才能把“应该创建一个新实例”的操作给优化成“直接返回一个缓存的实例”</p><p>使用的必要性评估。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="单例模式-1"></a>单例模式<a class="hash-link" href="#单例模式-1" title="Direct link to heading">#</a></h4><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="对象状态"></a>对象状态<a class="hash-link" href="#对象状态" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="备忘录模式"></a>备忘录模式<a class="hash-link" href="#备忘录模式" title="Direct link to heading">#</a></h4><p>对象内部的信息保存在对象之外的地方。</p><p>发起人类</p><p>备忘录类</p><p>管理者类</p><p>对象序列化。现代语言特性支持，弱化了。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="解释器模式"></a>解释器模式<a class="hash-link" href="#解释器模式" title="Direct link to heading">#</a></h4><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="模式分组"></a>模式分组<a class="hash-link" href="#模式分组" title="Direct link to heading">#</a></h2><p>概念</p><p>创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑</p><p>结构型模式是为解决怎样组装现有的类，设计他们的交互方式，从而达到实现一定的功能的目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）封装性（适配器，桥接）</p><p>行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为型模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式1.行为模式使用继承机制在类间分派行为2.行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。</p><p>第一是目的准则，即模式是用来完成什么工作的。模式依据其目的可分为创建型（ Creational）、结构型( Structural)、或行为型( Behavioral )三种。创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。</p><p>第二是范围准则，指定模式主要是用于类还是用于对象。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。从某种意义上来说，几乎所有模式都使用继承机制，所以“类模式”只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。</p><p>创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的任务。</p><p>还有其他组织模式的方式。有些模式经常会被绑在一起使用，例如， Composite（组合模式）常和Iterator（迭代器模式）或Visitor（访问者模式）一起使用；有些模式是可替代的，例如， Prototype（原型模式）常用来替代Abstract Factory（抽象工厂模式）；有些模式尽管使用意图不同，但产生的设计结果是很相似的，例如， Composite（组合模式）和Decorator（装饰模式）的结构图是相似的。
还有一种方式是根据模式的“相关模式”部分所描述的它们怎样互相引用来组织设计模式。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="创建型模式"></a>创建型模式<a class="hash-link" href="#创建型模式" title="Direct link to heading">#</a></h3><p>简单工厂模式(不符合开放封闭原则)</p><p>工厂方法模式</p><p>抽象工厂模式</p><p>单例模式</p><p>建造者模式</p><p>原型模式</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="结构型模式"></a>结构型模式<a class="hash-link" href="#结构型模式" title="Direct link to heading">#</a></h3><p>适配器模式</p><p>装饰模式</p><p>桥接模式</p><p>组合模式</p><p>享元模式</p><p>代理模式</p><p>外观模式</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="行为型模式"></a>行为型模式<a class="hash-link" href="#行为型模式" title="Direct link to heading">#</a></h3><p>观察者模式</p><p>模板方法模式</p><p>命令模式</p><p>状态模式</p><p>职责链模式</p><p>解释器模式</p><p>中介者模式</p><p>访问者模式</p><p>策略模式</p><p>备忘录模式</p><p>迭代器模式</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="cocoa和cocoatouch设计模式"></a>Cocoa和CocoaTouch设计模式<a class="hash-link" href="#cocoa和cocoatouch设计模式" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://github.com/huang303513/Design-Pattern-For-iOS" target="_blank" rel="noopener noreferrer">https://github.com/huang303513/Design-Pattern-For-iOS</a></p></li><li><p><a href="https://github.com/skyming/Trip-to-iOS-Design-Patterns" target="_blank" rel="noopener noreferrer">https://github.com/skyming/Trip-to-iOS-Design-Patterns</a></p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="mvc"></a>mvc<a class="hash-link" href="#mvc" title="Direct link to heading">#</a></h3><p>Cocoa (Touch）的MVC⽤用到的模式有：组合（Composite)、命令（Command)、中介者</p><p>策略略（Strategy）和观察者</p><ul><li>组合组合（第13章）——视图对象之间以协作的⽅方式构成⼀一个视图层次体系，其中既可以有</li></ul><p>复合视图（⽐比如表格视图），也可以有独⽴立视图（⽐比如⽂文本框或按钮）。每个层次的</p><p>视图节点都可以响应⽤用户的操作并把⾃自⼰己绘制到</p><ul><li>命令命令（第20章）⼀一——之是⼀一种“⽬目标⼀一动作”机制，视图对象可以推迟其他对象（⽐比如</li></ul><p>制器器）的执⾏行行，让其他对象等到发⽣生了了某些事件后再执⾏行行。这⼀一机制构成了了命令</p><p>⼝口中介者（第11章）～制器器对象起着中间⼈人的作⽤用，⽽而这个中间⼈人则采⽤用了了中介者模</p><p>式，它构成了了在模型和视图对象之间传递数据的双向通道。应⽤用程序的控制器器对象将模</p><p>型的变更更传达给视图</p><p>①原⽂文为concrete, concrete class指既不不继承其他类也不不被其他类继承，没有虚函数的类。——译者</p><ul><li>策略模式 州空制器器可以是视图对象的⼀一个“ 策略略”。视图对象将⾃自身隔离，以期</li></ul><p>维持其作为数据展示器器的唯⼀一职责，⽽而将⼀一切应⽤用程序特有的界⾯面⾏行行为的决定委派给它</p><p>的 “策略略”对象（即控制器器）。</p><ul><li>观察者模式（第12章）——模型对象向它所关注的控制器器等对象发出内部状态变化的通知。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="练习"></a>练习<a class="hash-link" href="#练习" title="Direct link to heading">#</a></h2><p><a href="https://github.com/dingyusong/DesignPattern" target="_blank" rel="noopener noreferrer">https://github.com/dingyusong/DesignPattern</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="参考文档"></a>参考文档<a class="hash-link" href="#参考文档" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://toutiao.io/posts/xxr604/preview" target="_blank" rel="noopener noreferrer">8 种模式帮你告别 Massive View Controller</a></p></li><li><p><a href="http://khanlou.com/2015/12/massive-view-controller/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener noreferrer">http://khanlou.com/2015/12/massive-view-controller/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/13lNlBqDalOK2AddpAGajQ" target="_blank" rel="noopener noreferrer">经典永不过时！重温设计模式</a></p></li><li><p>推荐一个经典学习网站: <a href="https://refactoringguru.cn/" target="_blank" rel="noopener noreferrer">https://refactoringguru.cn/</a></p></li><li><p><a href="https://github.com/skyming/Trip-to-iOS-Design-Patterns" target="_blank" rel="noopener noreferrer">https://github.com/skyming/Trip-to-iOS-Design-Patterns</a></p></li></ul><hr><p>原创文章，转载请保留原文链接，未经授权拒绝转载，谢谢。</p><p>联系作者：<a href="mailto:dys90@qq.com" target="_blank" rel="noopener noreferrer">dys90@qq.com</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="dys-typora-open://mine/survival/docs/编程基础/设计模式/设计模式.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/编程基础/数据结构与算法/算法面试"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 算法面试</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前言" class="table-of-contents__link">前言</a></li><li><a href="#设计模式概述" class="table-of-contents__link">设计模式概述</a></li><li><a href="#设计模式原则" class="table-of-contents__link">设计模式原则</a><ul><li><a href="#单一职责原则" class="table-of-contents__link">单一职责原则</a></li><li><a href="#开放-封闭原则" class="table-of-contents__link">开放-封闭原则</a></li><li><a href="#依赖倒转原则" class="table-of-contents__link">依赖倒转原则</a></li><li><a href="#里氏替换原则" class="table-of-contents__link">里氏替换原则</a></li><li><a href="#迪米特法则" class="table-of-contents__link">迪米特法则</a></li><li><a href="#合成聚合复用原则" class="table-of-contents__link">合成/聚合复用原则</a></li><li><a href="#接口隔离原则" class="table-of-contents__link">接口隔离原则</a></li></ul></li><li><a href="#设计模式" class="table-of-contents__link">设计模式</a><ul><li><a href="#对象创建" class="table-of-contents__link">对象创建</a></li><li><a href="#接口隔离" class="table-of-contents__link">接口隔离</a></li><li><a href="#对象去耦合" class="table-of-contents__link">对象去耦合</a></li><li><a href="#抽象集合" class="table-of-contents__link">抽象集合</a></li><li><a href="#行为拓展" class="table-of-contents__link">行为拓展</a></li><li><a href="#算法封装" class="table-of-contents__link">算法封装</a></li><li><a href="#性能" class="table-of-contents__link">性能</a></li><li><a href="#对象状态" class="table-of-contents__link">对象状态</a></li></ul></li><li><a href="#模式分组" class="table-of-contents__link">模式分组</a><ul><li><a href="#创建型模式" class="table-of-contents__link">创建型模式</a></li><li><a href="#结构型模式" class="table-of-contents__link">结构型模式</a></li><li><a href="#行为型模式" class="table-of-contents__link">行为型模式</a></li></ul></li><li><a href="#cocoa和cocoatouch设计模式" class="table-of-contents__link">Cocoa和CocoaTouch设计模式</a><ul><li><a href="#mvc" class="table-of-contents__link">mvc</a></li></ul></li><li><a href="#练习" class="table-of-contents__link">练习</a></li><li><a href="#参考文档" class="table-of-contents__link">参考文档</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.1004da7c.js"></script>
<script src="/runtime~main.74d3fe56.js"></script>
<script src="/main.b81ad7fb.js"></script>
<script src="/1.2fe752e0.js"></script>
<script src="/259.96e24fb8.js"></script>
<script src="/260.8c75c7b8.js"></script>
<script src="/935f2afb.8492b0e9.js"></script>
<script src="/258.d78093f4.js"></script>
<script src="/e91d5df7.daa37b00.js"></script>
</body>
</html>