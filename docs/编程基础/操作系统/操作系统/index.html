<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Blog Atom Feed"><title data-react-helmet="true">操作系统 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="操作系统 | My Site"><meta data-react-helmet="true" name="description" content="操作系统"><meta data-react-helmet="true" property="og:description" content="操作系统"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/编程基础/操作系统/操作系统"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/编程基础/操作系统/操作系统"><link rel="stylesheet" href="/styles.8cfbcdec.css">
<link rel="preload" href="/styles.e736442d.js" as="script">
<link rel="preload" href="/runtime~main.500606b1.js" as="script">
<link rel="preload" href="/main.e34cadf8.js" as="script">
<link rel="preload" href="/1.3353372a.js" as="script">
<link rel="preload" href="/256.3f6603bc.js" as="script">
<link rel="preload" href="/257.427a7301.js" as="script">
<link rel="preload" href="/935f2afb.0ee8c40a.js" as="script">
<link rel="preload" href="/255.24175022.js" as="script">
<link rel="preload" href="/fa2f39ef.46b97fd2.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/编程基础/编程基础/编程基础">编程基础</a><a class="navbar__item navbar__link" href="/docs/编程语言/编程语言">编程语言</a><a class="navbar__item navbar__link" href="/docs/工具/常用工具">工具</a><a class="navbar__item navbar__link" href="/docs/应用开发/应用开发">应用开发</a><a class="navbar__item navbar__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a><a class="navbar__item navbar__link" href="/docs/音视频/音视频">音视频</a><a class="navbar__item navbar__link" href="/docs/项目/项目">项目</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Search" aria-label="Search" class="navbar__search-input search-bar"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/编程基础/编程基础/编程基础">编程基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程语言/编程语言">编程语言</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/工具/常用工具">工具</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/应用开发/应用开发">应用开发</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/音视频/音视频">音视频</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/项目/项目">项目</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/编程基础/编程基础">编程基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/学习经验/学习经验">学习经验</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">数字电路</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数字电路/数字电路">数字电路</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">计算机组成原理</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机组成原理">计算机组成原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机是怎么跑起来的">计算机是怎么跑起来的</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机系统基础">计算机系统基础</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">操作系统</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/编程基础/操作系统/操作系统">操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/编程基础/操作系统/Unix系统管理">Unix系统管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/编程基础/操作系统/Unix环境编程">Unix环境编程</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机网络/计算机网络">计算机网络</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机系统基础/计算机系统基础">计算机系统基础</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">编译链接调试</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/编译原理/编译原理">编译原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/编译原理/程序员的自我修养">程序员的自我修养</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">数据结构与算法</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/数据结构与算法">数据结构与算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/数据结构">数据结构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/算法">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/算法面试">算法面试</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/设计模式/设计模式">设计模式</a></li></ul></div></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">操作系统</h1></header><div class="markdown"><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="操作系统"></a>操作系统<a class="hash-link" href="#操作系统" title="Direct link to heading">#</a></h1><p>[toc]</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="linux学习路线"></a>Linux学习路线<a class="hash-link" href="#linux学习路线" title="Direct link to heading">#</a></h2><p>大体可以分为3个阶段</p><ol><li>用起来</li><li>在他上面编程</li><li>理解并实现它</li></ol><p>![下载 (3)](操作系统.assets/下载 (3)-6320146.jpeg)</p><p><strong>第一个坡</strong></p><ul><li>《鸟哥的Linux私房菜》</li><li>《linux系统管理技术手册》</li></ul><p><strong>第二个坡</strong></p><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" checked="" disabled=""> 《Unix/Linux编程实践教程》</li><li class="task-list-item"><input type="checkbox" disabled=""> <a href="https://book.douban.com/subject/24722611/" target="_blank" rel="noopener noreferrer">高性能服务器编程</a></li><li class="task-list-item"><input type="checkbox" disabled=""> 《Unix环境高级编程》</li><li class="task-list-item"><input type="checkbox" disabled=""> 深入理解计算机系统</li></ul><p>参考：</p><ul><li><a href="https://github.com/swusking/linux_programming" target="_blank" rel="noopener noreferrer">https://github.com/swusking/linux_programming</a></li><li><a href="https://github.com/wuduozhi/unix-coding%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89" target="_blank" rel="noopener noreferrer">https://github.com/wuduozhi/unix-coding（推荐）</a></li><li><a href="https://gist.github.com/fffaraz/2b86cf1f1a1f9564c51b" target="_blank" rel="noopener noreferrer">https://gist.github.com/fffaraz/2b86cf1f1a1f9564c51b</a></li><li><a href="https://zhuanlan.zhihu.com/p/51597529" target="_blank" rel="noopener noreferrer">学习 Linux/*BSD/Unix 的 30 个最佳在线文档</a></li><li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml" target="_blank" rel="noopener noreferrer">http://cb.vu/unixtoolbox_zh_CN.xhtml</a></li><li><a href="https://docs.freebsd.org/en/books/handbook/" target="_blank" rel="noopener noreferrer">https://docs.freebsd.org/en/books/handbook/</a></li></ul><p><strong>第三个坡</strong></p><ul><li>《庖丁解牛Linux内核分析》</li><li>《深入理解Linux内核》</li></ul><p><strong>第四个坡</strong></p><ul><li>《Linux内核源代码情景分析》</li></ul><p><strong>第五个坡</strong></p><ul><li>定制Linux组件</li><li>编写操作系统</li></ul><p>第六个坡</p><ul><li>面向现实，灵活运用</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="操作系统发展史"></a><a href="/docs/编程基础/操作系统/操作系统发展史">操作系统发展史</a><a class="hash-link" href="#操作系统发展史" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="现代操作系统原理"></a><a href="/docs/编程基础/操作系统/现代操作系统原理.md">现代操作系统原理</a><a class="hash-link" href="#现代操作系统原理" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="unix环境编程"></a><a href="/docs/编程基础/操作系统/Unix环境编程">Unix环境编程</a><a class="hash-link" href="#unix环境编程" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="unix系统管理"></a><a href="/docs/编程基础/操作系统/Unix系统管理">Unix系统管理</a><a class="hash-link" href="#unix系统管理" title="Direct link to heading">#</a></h2><p><a href="/docs/编程基础/操作系统/实践/计算机系统基础课程实验">计算机系统基础</a></p><p><a href="/docs/编程基础/操作系统/实践/南京大学操作系统">南京大学操作系统</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="基本特征"></a>基本特征<a class="hash-link" href="#基本特征" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="并发"></a>并发<a class="hash-link" href="#并发" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="共享"></a>共享<a class="hash-link" href="#共享" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="虚拟"></a>虚拟<a class="hash-link" href="#虚拟" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="异步"></a>异步<a class="hash-link" href="#异步" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="基本功能"></a>基本功能<a class="hash-link" href="#基本功能" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="进程管理"></a>进程管理<a class="hash-link" href="#进程管理" title="Direct link to heading">#</a></h3><p>从 Linux 内核的角度来说，其实它并没有线程的概念。Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了 task_struct 中。线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别。线程创建的时候，加上了 CLONE_VM 标记，这样 线程的内存描述符 将直接指向 父进程的内存描述符。</p><ul><li><p><a href="https://www.cnblogs.com/sky-heaven/p/7112006.html" target="_blank" rel="noopener noreferrer">Linux虚拟地址空间布局以及进程栈和线程栈总结【转】</a></p></li><li><p>linux 线程栈的默认大小为 8M，除了线程栈的内存，每个线程还会额外多 4k 的 guard 区域防止栈溢出</p></li></ul><p><a href="https://network.51cto.com/art/202006/619565.htm" target="_blank" rel="noopener noreferrer">https://network.51cto.com/art/202006/619565.htm</a></p><p><img alt="下载" src="/assets/images/下载-307b05f57e815da82534ab0b5aa74525.jpeg"></p><p>从上可以看出地址空间分为：代码和数据。</p><p>栈的作用：<strong>函数调用和多任务支持。</strong></p><p><a href="https://www.jianshu.com/p/091b54740979" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/091b54740979</a></p><p>栈相当于一个临时的作业区，处理完成拿到结果就返回了。</p><p><a href="https://www.cnblogs.com/sky-heaven/p/7112006.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/sky-heaven/p/7112006.html</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="内存管理"></a>内存管理<a class="hash-link" href="#内存管理" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="进程的内存布局"></a>进程的内存布局<a class="hash-link" href="#进程的内存布局" title="Direct link to heading">#</a></h4><ul><li>32位</li></ul><p>32 位系统：3G 用户态, 1G 内核态</p><p>8位16进制数</p><p>用户态：0x0000 0000 - 0xC000 0000</p><p>内核态：0xC000 0000- 0xFFFF FFFF</p><p>![下载 (1)](操作系统.assets/下载 (1).jpeg)</p><ul><li>64位</li></ul><p>64 位系统(只利用 48 bit 地址): 128T 用户态; 128T 内核态</p><p>16位16进制数。</p><p>用户态的虚拟地址只使用了 48 位。 也就是12位16进制数。</p><p>感性认识：</p><p>栈空间l_a的地址:0x7ffeefbff3ac</p><p>堆空间a的地址:0x100548b20</p><p>一看到7ff开头的，有12位16进制的地址，就应该联想到他是栈空间的局部变量。</p><p>一看到10开头的且是9位，一般立即联想到是堆空间。</p><p>![下载 (2)](操作系统.assets/下载 (2).jpeg)</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> |------栈------|</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> |------mmap内存隐射区------|</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> |------堆------|</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> |------BSS------|</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> |------Data------|</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> |------Text------|</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> Text Segment 是存放二进制可执行代码的位置，Data Segment 存放静态常量，BSS Segment 存放未初始化的静态变量。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> //MARK: 代码段地址最小，从4位16进制开始开始  地址特性比较明显：9位16进制，0x10+最低4位16进制，中间填充0。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 内存布局`main:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     0x100002a00 &lt;+0&gt;:    pushq  %rbp</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     0x100002a01 &lt;+1&gt;:    movq   %rsp, %rbp</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     0x100002a04 &lt;+4&gt;:    subq   $0xa0, %rsp</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     0x100002a0b &lt;+11&gt;:   movq   0x15ee(%rip), %rdi        ; (void *)0x00007fff807e81d0: std::__1::cout</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     0x100002a12 &lt;+18&gt;:   movl   $0xa, -0x4(%rbp)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> //MARK:静态常量 字符串常量 在最前面。  地址特性比较明显：9位16进制，0x10+最低4位16进制，中间填充0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 字符串常量地址为： 0x100003f2d</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 字符串常量地址为： 0x100003f39</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> //MARK:静态常量</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 静态部常量s_c_l_a的地址:        0x100003f48</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 静态局部常量s_c_l_b的地址:      0x100003f4c</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 全局常量c_g_a的地址:              0x100003f50</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 全局常量c_g_b的地址:              0x100003f54</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 静态全局常量s_c_g_a的地址:0x100003f58</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 静态全局常量s_c_g_b的地址:0x100003f5c</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> //MARK:静态变量。 地址特性比较明显：9位16进制，0x10+最低4位16进制，中间填充0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 全局变量g_a的地址:0x1000080a8</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 全局变量g_b的地址:0x1000080ac</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 静态局部变量s_l_a的地址:0x1000080b0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 静态局部变量s_l_b的地址:0x1000080b4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 静态全局变量s_g_a的地址:0x1000080b8</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 静态局部变量s_g_b的地址:0x1000080bc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> //MARK:堆空间，往高地址。地址特性比较明显：9位16进制，从左往右，至少第二或者第三位就有值了，开发中非常常见。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 堆空间heap_a的地址:0x105323050</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 堆空间heap_b的地址:0x105321cb0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> //MARK: 栈空间往低地址走。地址特性比较明显：12位16进制，0x7f开头</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 局部变量l_a的地址:0x7ffeefbff3dc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 局部变量l_b的地址:0x7ffeefbff3d8</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 局部常量c_l_a的地址:0x7ffeefbff3d4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> 局部常量c_l_b的地址:0x7ffeefbff3d0</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p> 查内存增长，一般只堆。因为堆是程序员负责开辟和释放的。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多线程栈空间模型"></a>多线程栈空间模型<a class="hash-link" href="#多线程栈空间模型" title="Direct link to heading">#</a></h4><p>Linux 内核中，多线程栈空间模型是怎样的？：<a href="https://www.zhihu.com/question/323415592" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/323415592</a></p><p>对任何一个进程，它里面存在如下几个静态内存区域：</p><p>1、常量区</p><p>2、全局变量区</p><p>3、静态变量区</p><p>4、代码区</p><p>这几个区域是在执行单元载入时静态分配的，位置、大小均固定。</p><p>当进程运行起来后，产生另外两个动态区域，这就是堆和栈。</p><p>所谓“新开一条线程”，实质上就是另外申请了一块内存，然后把这块内存当作堆栈，维护另外一条调用链。</p><p>而所谓“线程获得执行权”呢，实质上就是把对应线程的栈顶指针等信息载入CPU的栈指示器，使得它沿着这条调用链继续执行下去——执行一段时间，把它的栈顶指针等信息找个地方保存、然后载入另一个线程的栈顶指针等信息，这就是所谓的“线程切换”。</p><p>线程有两种。</p><p>如果维护调用链（以及执行现场）的任务全部放在用户空间，不让操作系统知道，这就叫“用户态线程”。</p><p>反之，如果操作系统自己提供了开辟新线程以及维护它的调用链的一整套方法，这就叫“内核态线程”。</p><p>两者的差别就是后者是操作系统管理的，可以得到多CPU之类的直接支持。</p><p>线程和进程的区别就在于，线程只有调用链，而进程还包含常量区、全局变量区等其他区域，同时还有各种资源的所有权。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="文件管理"></a>文件管理<a class="hash-link" href="#文件管理" title="Direct link to heading">#</a></h3><ul><li><a href="https://zhuanlan.zhihu.com/p/73453720" target="_blank" rel="noopener noreferrer">浅谈内存映射</a></li></ul><p>往对应的内存区域写数据，映射的文件也会被修改。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="设备管理"></a>设备管理<a class="hash-link" href="#设备管理" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="系统调用"></a>系统调用<a class="hash-link" href="#系统调用" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="宏内核和微内核"></a>宏内核和微内核<a class="hash-link" href="#宏内核和微内核" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="宏内核"></a>宏内核<a class="hash-link" href="#宏内核" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="微内核"></a>微内核<a class="hash-link" href="#微内核" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="中断分类"></a>中断分类<a class="hash-link" href="#中断分类" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="外中断"></a>外中断<a class="hash-link" href="#外中断" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="异常"></a>异常<a class="hash-link" href="#异常" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="陷入"></a>陷入<a class="hash-link" href="#陷入" title="Direct link to heading">#</a></h3><p><img alt="image-20210228145826245" src="/assets/images/image-20210228145826245-ff81019fbf1fd516d9edfdc5d37ab473.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="操作系统实例"></a>操作系统实例<a class="hash-link" href="#操作系统实例" title="Direct link to heading">#</a></h2><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="unix-家族："></a>Unix 家族：<a class="hash-link" href="#unix-家族：" title="Direct link to heading">#</a></h4><p><img alt="UNIX简史图" src="/assets/images/UNIX简史图-280ebb9667c0c63eae3180463fcb5d4f.png"></p><p>UNIX BSD</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="macos"></a>macOS<a class="hash-link" href="#macos" title="Direct link to heading">#</a></h5><p><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/OSX_Technology_Overview/About/About.html" target="_blank" rel="noopener noreferrer">https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/OSX_Technology_Overview/About/About.html</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="linux家族："></a>Linux家族：<a class="hash-link" href="#linux家族：" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="windows家族："></a>Windows家族：<a class="hash-link" href="#windows家族：" title="Direct link to heading">#</a></h4><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="参考："></a>参考：<a class="hash-link" href="#参考：" title="Direct link to heading">#</a></h2><ul><li>操作系统_清华大学(向勇、陈渝) <a href="https://www.bilibili.com/video/BV1js411b7vg" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1js411b7vg</a></li></ul><p>强烈建议大家去把配套的实验做一遍！实验简直是这里面的精华！
老师讲的好，看完理论课视频没难度，但这配套实验做起来是真的难。理论课上老师照顾大多数人，娓娓道来；到了实验的时候就得从汇编搞起一行一行代码啃，实验指导书反复的看，把学的东西碾碎了吸收了才能做的出来。真的是听课一小时，代码啃一天。但闷头捣鼓半天，把实验做出来后长吐一口气，那种对整个系统流程了熟于心的成就感简直爽爆了！
附上常用的资料：
课程信息发布页：<a href="http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring" target="_blank" rel="noopener noreferrer">http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring</a>
向勇老师写的参考书：<a href="https://www.bookstack.cn/read/simple_os_book/README.md" target="_blank" rel="noopener noreferrer">https://www.bookstack.cn/read/simple_os_book/README.md</a></p><p><a href="https://github.com/chyyuu/os_course_info" target="_blank" rel="noopener noreferrer">https://github.com/chyyuu/os_course_info</a></p><p>资源：</p><p>学堂在线： <a href="https://www.xuetangx.com/" target="_blank" rel="noopener noreferrer">https://www.xuetangx.com/</a></p><ul><li><p>顶级会议</p><p>SOSP（每两年）</p><p>USENIX（每两年）</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="镜像加载"></a>镜像加载<a class="hash-link" href="#镜像加载" title="Direct link to heading">#</a></h2><p>创建软盘镜像首先需要一个汇编器，将汇编源代码编译成二进制文件，其实软盘镜像的真身也是二进制文件，例如只是编译bootsect.asm文件，那么生成的二进制文件可以直接在虚拟机里面运行，由于现在软驱已经基本绝迹了所以才需要使用镜像文件来启动操作系统，使用bochs虚拟机需要有一个对镜像文件的配置表，在windows中这个配置表是一个以bsxr结尾的文件，配置好这个文件之后双击运行就能启动自制的操作系统了</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="启动过程"></a>启动过程<a class="hash-link" href="#启动过程" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="加电-启动bios"></a>加电-启动BIOS<a class="hash-link" href="#加电-启动bios" title="Direct link to heading">#</a></h3><p>当电脑刚加电的时候，会做一些重置的工作，将 CS 设置为 0xFFFF，将 IP 设置为 0x0000，所以第一条指令就会指向 0xFFFF0，正是在 ROM 的范围内。在这里，有一个 JMP 命令会跳到 ROM 中做初始化工作的代码，于是，BIOS 开始进行初始化的工作。</p><p>相关寄存器重置了了一个地址，然后去哪个地址取指令执行。这就是起点。第一个地址是写死的，内容也是固定到room的。</p><p>从room到硬盘</p><p>从实模式切换到保护模式</p><p>计算机的运行过程及其简单：<strong>取指=&gt;执行</strong> 不停循环</p><p><img alt="img" src="/assets/images/337-3d6aae4cfb7dbaf3817fc74554322b59.jpeg"></p><p> CS 设置为 0xFFFF，将 IP 设置为 0x0000，所以第一条指令就会指向 0xFFFF0。</p><p>CS::IP 初始入口。</p><p>在 x86 系统中，将 1M 空间最上面的 0xF0000 到 0xFFFFF 这 64K 映射给 ROM，也就是说，到这部分地址访问的时候，会访问 ROM。</p><p>此时会访问rom，而rom是提前写好的程序。</p><p>![下载 (3)](操作系统.assets/下载 (3).jpeg)</p><p>给存储介质一字节一字节得划好了地址，cpu编地址有两种方式，一种是统一编址，比如我在内存中划出一块区域专门作为与外设交互的地址，一个超明显的例子就是显存，以Intel的x86架构为例，0xB8000就是显存的地址，你往这个地址下写字符就是能在显示器上显示出来，从这个地址开始，每<strong>两个字节</strong>被解释为显示在屏幕上的一个字符，这第一个字节表示要显示字符的字模码，就是一个字符的像素点应该怎么点出来，第二个字节用于表示这个字符的前景色和背景色。具体如下</p><p><img alt="image-20210630215852789" src="/assets/images/image-20210630215852789-7572dd493566f53b59d71f0c74c5cd49.png"></p><p>显示的内容容量总是比已安装的内存条小上一点，原因就是将地址总线能访问的一部分划给内存条之外的其他存储空间。</p><p>这个阶段的任务：</p><ol><li><p>检验外设，初始化硬件。</p><p>BIOS 要检查一下系统的硬件是不是都好着</p></li><li><p>建立一个中断向量表和中断服务程序，因为现在你还要用键盘和鼠标，这些都要通过中断进行的。</p></li></ol><p>0x000~0x3ff处建立终端向量表，并填写中断历程。</p><ol start="3"><li><p>基本的I/O功能。</p><p>因为此时用户需要和BIOS交互。</p></li></ol><p>完成之后，跳转到下一步：MBR</p><p>解释：BIOS的最后一项工作就是检验启动盘，0盘，0道，1扇区(CHS表示法)，或者0盘，0道，0扇区（LBA表示法），如果此扇区末尾的两个字节是0x55和0xaa,则表示此扇区存在可执行的程序(MBR), 随后将其加载到0x7c00处，在跳转到此处运行，此时接力棒就交给了MBR。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="bootloader时期"></a>bootloader时期<a class="hash-link" href="#bootloader时期" title="Direct link to heading">#</a></h3><p><strong>MBR</strong>: main boot record. 主引导记录，位于硬盘最开始的扇区。</p><p>这个扇区是硬盘上的，也就是我们可以自己写的。一般在linux下我们用grub2来写进入，或者叫安装，或者叫配置。</p><p>一般扇区大小为512字节。MBR引导扇区的内容为：</p><ol><li>446字节的引导程序和参数</li><li>64字节的分区表</li><li>最后两字节0x55和0xaa</li></ol><p><strong>Grub2</strong> 在这个扇区安装了什么呢？第一个要安装的就是 boot.img。它由 boot.S 编译而成，一共 512 字节，正式安装到启动盘的第一个扇区。这个扇区通常称为<strong>MBR</strong>（Master Boot Record，主引导记录 / 扇区）。</p><p>bootloader</p><p>boot.img 做不了太多事情。因为比较小。它能做的最重要的一个事情就是加载 grub2 的另一个镜像 core.img。</p><p>![下载 (4)](操作系统.assets/下载 (4).jpeg)</p><p>boot.img 先加载的是 core.img 的第一个扇区。如果从硬盘启动的话，这个扇区里面是 diskboot.img，对应的代码是 diskboot.S。</p><p>boot.img 将控制权交给 diskboot.img 后，diskboot.img 的任务就是将 core.img 的其他部分加载进来，先是解压缩程序 lzma_decompress.img，再往下是 kernel.img，最后是各个模块 module 对应的映像。这里需要注意，它不是 Linux 的内核，而是 grub 的内核。</p><p>lzma_decompress.img 对应的代码是 startup_raw.S，本来 kernel.img 是压缩过的，现在执行的时候，需要解压缩。</p><p><strong>实模式-&gt;保护模式</strong></p><p>在这之前，我们所有遇到过的程序都非常非常小，完全可以在实模式下运行，但是随着我们加载的东西越来越大，实模式这 1M 的地址空间实在放不下了，所以在真正的解压缩之前，lzma_decompress.img 做了一个重要的决定，就是调用 real_to_prot，切换到保护模式，这样就能在更大的寻址空间里面，加载更多的东西。</p><p>切换到保护模式要干很多工作，大部分工作都与内存的访问方式有关。</p><p>第一项是<strong>启用分段</strong>，就是在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。</p><p>第二项是<strong>启动分页</strong>。能够管理的内存变大了，就需要将内存分成相等大小的块，</p><p>打开 Gate A20，也就是第 21 根地址线的控制线。切换保护模式的函数 DATA32 call real_to_prot 会打开 Gate A20，也就是第 21 根地址线的控制线。</p><p>现在好了，有的是空间了。接下来我们要对压缩过的 kernel.img 进行解压缩，然后跳转到 kernel.img 开始运行。</p><p>kernel.img 对应的代码是 startup.S 以及一堆 c 文件，在 startup.S 中会调用 grub_main，这是 grub kernel 的主函数。</p><p>在这个函数里面，grub_load_config() 开始解析，我们上面写的那个 grub.conf 文件里的配置信息。</p><p>如果是正常启动，grub_main 最后会调用 grub_command_execute (“normal”, 0, 0)，最终会调用 grub_normal_execute() 函数。在这个函数里面，grub_show_menu() 会显示出让你选择的那个操作系统的列表。</p><p><img alt="下载" src="/assets/images/下载-b422cd09990cf3aa8558cf28d7e2a6b4.png"></p><p>一旦，你选定了某个宝典，启动某个操作系统，就要开始调用 grub_menu_execute_entry() ，开始解析并执行你选择的那一项。接下来你的经营企业之路就此打开了。</p><p>例如里面的 linux16 命令，表示装载指定的内核文件，并传递内核启动参数。于是 grub_cmd_linux() 函数会被调用，它会首先读取 Linux 内核镜像头部的一些数据结构，放到内存中的数据结构来，进行检查。如果检查通过，则会读取整个 Linux 内核镜像到内存。</p><p>如果配置文件里面还有 initrd 命令，用于为即将启动的内核传递 init ramdisk 路径。于是 grub_cmd_initrd() 函数会被调用，将 initramfs 加载到内存中来。</p><p>当这些事情做完之后，grub_command_execute (“boot”, 0, 0) 才开始真正地启动内核。</p><p>![下载 (5)](操作系统.assets/下载 (5).jpeg)</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="内核启动"></a>内核启动<a class="hash-link" href="#内核启动" title="Direct link to heading">#</a></h3><p>内核的启动从入口函数 start_kernel() 开始。在 init/main.c 文件中，start_kernel 相当于内核的 main 函数。打开这个函数，你会发现，里面是各种各样初始化函数 XXXX_init。</p><p>![下载 (6)](操作系统.assets/下载 (6).jpeg)</p><ol><li>创建0号进程。</li></ol><p>在操作系统里面，先要有个创始进程，有一行指令 set_task_stack_end_magic(&amp;init_task)。这里面有一个参数 init_task，它的定义是 struct task_struct init_task = INIT_TASK(init_task)。它是系统创建的第一个进程，我们称为<strong>0 号进程</strong>。这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个。</p><ol start="2"><li>启动中断服务</li></ol><p>这里面对应的函数是 trap_init()，里面设置了很多<strong>中断门</strong>（Interrupt Gate），用于处理各种中断。其中有一个 set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)，这是系统调用的中断门。系统调用也是通过发送中断的方式进行的。</p><ol start="3"><li>启动内存管理系统</li></ol><p>对应的，mm_init() 就是用来初始化内存管理模块。项目需要项目管理进行调度，需要执行一定的调度策略。sched_init() 就是用于初始化调度模块。</p><ol start="4"><li>启动文件系统</li></ol><p>vfs_caches_init() 会用来初始化基于内存的文件系统 rootfs。在这个函数里面，会调用 mnt_init()-&gt;init_rootfs()。这里面有一行代码，register_filesystem(&amp;rootfs_fs_type)。在 VFS 虚拟文件系统里面注册了一种类型，我们定义为 struct file_system_type rootfs_fs_type。</p><p>文件系统是我们的项目资料库，为了兼容各种各样的文件系统，我们需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的接口，这个抽象层就是 VFS（Virtual File System），虚拟文件系统。</p><ol start="5"><li>启动1号进程和2号进程</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="系统调用-1"></a>系统调用<a class="hash-link" href="#系统调用-1" title="Direct link to heading">#</a></h2><p>有三组常见 API 可为应用程序员所用：适用于 Windows 系统的 Windows API、适用于 POSIX 系统的 POSIX API（这包括几乎所有版本的 UNIX、Linux 和 Mac OS X）以及适用于 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener noreferrer">Java</a> 虚拟机的 Java API。程序员通过操作系统提供的函数库来调用 API。对运行于 UNIX 和 Linux 的用 C 语言编写的程序，该库名为 libc。</p><p><a href="http://c.biancheng.net/view/1195.html" target="_blank" rel="noopener noreferrer">http://c.biancheng.net/view/1195.html</a></p><p><a href="https://www.jianshu.com/p/8e89b13fac7d" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/8e89b13fac7d</a></p><p>从下到上看一个完整的计算机系统：物理硬件-&gt;OS内核-&gt;OS服务-&gt;应用程序。这里的OS内核起到了“承上启下”的关键作用，向下管理物理硬件，向上为操作系统服务和应用程序提供接口，这里的接口就是系统调用了。</p><p>应用程序的进程通常在user模式下运行，当它调用一个系统调用时，进程进入kernel模式，执行的是kernel内部的代码，从而具有执行特权指令的权限，完成特定的功能。换句话说，系统调用是应用程序主动进入操作系统内核的入口。</p><p>操作系统管理: CPU，内存，I/O 对着些资源的管理，对应的就是进程管理系统，内存管理系统，文件系统，输入输出系统，底层最直接的就是系统调用。高层有一些动态库函数提供服务。例如：在Linux中，malloc、calloc和free三个库函数底层都是调用brk系统调用完成的。</p><p>库函数的调用是语言或者应用程序的一部分，而系统调用则是操作系统的一部分。</p><p><strong>系统调用是一种特殊的中断类型(软中断)</strong>。</p><p>在x86的机器中，用一个8bit的数字（0~255）来区分各种中断，这个数字被称为<strong>中断向量</strong>（vector）。其中一个中断向量，即128 （0x80），专门被用于执行系统调用。</p><p>在Linux系统中，存有一个系统表，叫做Interrupt DescriptorTable，简称IDT。<strong>IDT</strong>表共有256项，存放了从中断向量到相应处理例程（interrupt or exceptionhandler）的映射关系。当某个中断发生时，CPU从IDT表中查找到相应的处理例程的地址来执行。</p><p>当系统调用发生时，通过中断机制，系统调用例程system_call被调用。它的执行过程大概分为4个步骤：</p><ol><li>从寄存器中取出系统调用号和输入参数，然后将这些寄存器的值压入kernel栈中。</li><li>根据系统调用号查找系统调用分派表（system call dispatch table），找到系统调用服务例程（一个内核函数）。</li><li>调用查到的系统调用服务例程。</li><li>将系统调用服务例程的返回值出栈，重新保存在寄存器中。</li></ol><p><a href="https://bbs.51cto.com/thread-636651-1.html" target="_blank" rel="noopener noreferrer">https://bbs.51cto.com/thread-636651-1.html</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="书籍"></a>书籍<a class="hash-link" href="#书籍" title="Direct link to heading">#</a></h2><ul><li><p>计算机是怎么跑起来的</p></li><li><p>鸟哥的Linux私房菜</p></li><li><p>Linux 系统管理技术手册</p></li><li><p>Unix/Linux编程实践教程</p></li><li><p>UNIX 环境高级编程</p></li><li><p>深入理解 LINUX 内核</p></li><li><p>庖丁解牛Linux内核分析</p></li><li><p>LINUX 内核源代码情景分析</p></li><li><p>linux内核0.11完全注释：<a href="http://www.oldlinux.org/download/clk011c-3.0.pdf" target="_blank" rel="noopener noreferrer">http://www.oldlinux.org/download/clk011c-3.0.pdf</a></p></li><li><p>Advanced Programming in the UNIX® Environment, Third Edition <a href="http://www.apuebook.com/code3e.html" target="_blank" rel="noopener noreferrer">http://www.apuebook.com/code3e.html</a></p><p>the code： <a href="https://gitee.com/dingyusong/apue.3e" target="_blank" rel="noopener noreferrer">https://gitee.com/dingyusong/apue.3e</a></p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="网站"></a>网站<a class="hash-link" href="#网站" title="Direct link to heading">#</a></h2><p><a href="http://oldlinux.org/" target="_blank" rel="noopener noreferrer">http://oldlinux.org/</a></p><p><a href="http://tinylab.org/linux-0.11-lab/" target="_blank" rel="noopener noreferrer">http://tinylab.org/linux-0.11-lab/</a></p><p><a href="https://cloud.tencent.com/developer/user/1281010/inventories" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/user/1281010/inventories</a></p><p><strong>linux源码分析</strong>：<a href="https://cloud.tencent.com/developer/inventory/10227" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/inventory/10227</a></p><p>老linux内核源码： <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/old-versions/" target="_blank" rel="noopener noreferrer">https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/old-versions/</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="代码是如何控制硬件的"></a>代码是如何控制硬件的?<a class="hash-link" href="#代码是如何控制硬件的" title="Direct link to heading">#</a></h2><p>作者：知乎用户
链接：<a href="https://www.zhihu.com/question/30710170/answer/49140097" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/30710170/answer/49140097</a>
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>其实这个问题是个伪问题。并没有所谓的区别于硬件的 “软件”，或者说没有所谓的区别于物理世界的 “虚拟世界”。问题中讨论的所有过程，其实从来都只是在电路层面上运行的，并没有什么所谓的 &quot;代码层面&quot;。</p><p>1、代码的产生在我们开始编写代码时，我们每按下一个按键，都会触发这个按键对应的开关，从而产生一个电平，这个电平被物理电路处理后，转换成一个电平序列，然后存储到寄存器上。比如我要写一个串代码：</p><p><code>int a = 0;</code></p><p>在我按下第一个字母 i 时，由于 i 对应的键盘开关被触发，最终导致了一串电平存进入了寄存器。所有的代码都是这样被保存了下来。看到没，在产生代码这一关，跟本就没有所谓的软件，所有的代码，其实就是我们按下的键的不同组合。有的同学会说，我的代码可能是copy过来的啊，我并没有按键啊，其实copy的时候，代码已经是在电路层了，copy的时候，还是电平的处理过程。而且就连copy的这个行为，也是你按下键盘ctrl+c , ctrl+v之后触发的电路行为。</p><p>2、写完上面的代码后，我们开始编译，我们按下鼠标左键，触发了一个电平，这个电平（类似于开关）触发电路对之前的寄存器中的电平按照一定规则进行“转换”（所谓的编译），比如从001000变成111000，然后再次存入寄存器中。看，这一步还是在电路层面进行的。</p><p>3、编译好了以后，我们双击执行，双击这个动作再次产生了一个（或两个）电平，触发了电路开始接收之前寄存器中的电平序列，通过数以亿计的三极管产生了相应的结果电平，这些结果电平触发了相应的门电路，通过与显卡驱动（注意：这里的显卡驱动也是在电路层面，存储在寄存器上的）的内容进行与或非运算，从而得到屏幕的明暗信号，显示了出来。（其他输出方法类似）综上，所有的过程都是在电路层面上进行的。所有的代码，都是我们一个个按键的不同序列构成的，这些序列包括编译软件的代码序列、操作系统的代码序列、各种驱动的代码序列。序列中的每一位，就是一个按键开关。所以为什么代码可以控制电平，因为代码就是电平本身。</p><p>我们以为自己是在写代码，然后硬件识别代码执行，实际上是我们写代码的动作是对硬件的操控~！！！</p><p>这个其实就是：</p><p>数字电路 逻辑电路 汇编语言的基础了</p><p><a href="https://www.zhihu.com/question/20492284?rf=19929541" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/20492284?rf=19929541</a></p><p>看了这么多评论，大多解释的跑题了。至于为什么虚拟的代码会驱动实实在在的硬件。你只要想明白一件事情就行：没有软件，一切都是硬件，你敲的一行行的代码实际是键盘按钮按下的一个个开关。软件只是硬件的反映，就好比意识是物质世界的反映。存储的一行行代码实际是有序的高低电平的集合，编译出来的结果还是电脑存储的有序高低电压。没有软件，只有硬件！</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编译后的内核镜像-及其执行"></a>编译后的内核镜像 及其执行<a class="hash-link" href="#编译后的内核镜像-及其执行" title="Direct link to heading">#</a></h2><ul><li><p><a href="https://www.cnblogs.com/cxj2011/p/13430960.html" target="_blank" rel="noopener noreferrer">谈谈Linux内核镜像</a></p></li><li><p><a href="https://blog.csdn.net/dashen2259/article/details/101995793" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/dashen2259/article/details/101995793</a></p></li><li><p>Linux kernel 分析之一:内核镜像<a href="https://blog.csdn.net/vanquishedzxl/article/details/46958785" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/vanquishedzxl/article/details/46958785</a></p></li><li><p><a href="https://blog.csdn.net/nsdhy/article/details/38683107" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/nsdhy/article/details/38683107</a></p></li><li><p>制作linux启动盘</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="教学操作系统"></a>教学操作系统<a class="hash-link" href="#教学操作系统" title="Direct link to heading">#</a></h2><ul><li><strong>xv6</strong></li></ul><p><a href="https://pdos.csail.mit.edu/6.828/2020/xv6.html" target="_blank" rel="noopener noreferrer">https://pdos.csail.mit.edu/6.828/2020/xv6.html</a></p><p><a href="https://pdos.csail.mit.edu/6.828/2020/xv6.html" target="_blank" rel="noopener noreferrer">教学操作系统 xv6</a>，它一共有 21 个系统调用，就可以启动完整的 Shell (<code>user.h</code>)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="问题"></a>问题<a class="hash-link" href="#问题" title="Direct link to heading">#</a></h2><p>操作系统是怎么跑起来的？</p><p>取指-&gt;译码-&gt;执行-&gt;更新pc</p><p>计算机不断地重复上述四个步骤, 不断地执行指令, 直到永远.</p><p>参考：<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/2.1.html" target="_blank" rel="noopener noreferrer">https://nju-projectn.github.io/ics-pa-gitbook/ics2020/2.1.html</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="理解"></a>理解<a class="hash-link" href="#理解" title="Direct link to heading">#</a></h2><p>操作系统是一个有限状态机，加电之后用不停歇的状态转换。本质是寄存器和内存上一堆的二进制的组合，虚拟机的原理是，用内存中的二进制模拟真机中的寄存器和内存。在此之上，进行何种处理。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="学习资料"></a>学习资料<a class="hash-link" href="#学习资料" title="Direct link to heading">#</a></h2><ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters" target="_blank" rel="noopener noreferrer">Operating Systems: Three Easy Pieces</a></li><li><a href="https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/chinese" target="_blank" rel="noopener noreferrer">OSTEP (Chinese Version)</a></li><li>南京大学操作系统实验：<a href="https://github.com/triumphalLiu/OSLabs" target="_blank" rel="noopener noreferrer">https://github.com/triumphalLiu/OSLabs</a></li><li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/" target="_blank" rel="noopener noreferrer">南京大学 计算机科学与技术系 计算机系统基础 课程实验 2020</a></li><li><a href="http://blog.sciencenet.cn/blog-414166-562616.html" target="_blank" rel="noopener noreferrer">系统设计黄金法则：简单之美</a></li><li><a href="https://zhuanlan.zhihu.com/p/266871840" target="_blank" rel="noopener noreferrer">世界上最牛气的操作系统教材是什么？</a></li><li><a href="http://jyywiki.cn/" target="_blank" rel="noopener noreferrer">http://jyywiki.cn/</a></li><li>计算机系统基础习题课 (2020 秋季学期):<a href="http://jyywiki.cn/ICS/2020/" target="_blank" rel="noopener noreferrer">http://jyywiki.cn/ICS/2020/</a></li><li>操作系统：设计与实现 (2021 春季学期)<a href="http://jyywiki.cn/OS/2021/" target="_blank" rel="noopener noreferrer">http://jyywiki.cn/OS/2021/</a></li><li><a href="https://missing.csail.mit.edu/" target="_blank" rel="noopener noreferrer">https://missing.csail.mit.edu/</a></li><li><a href="https://missing-semester-cn.github.io/" target="_blank" rel="noopener noreferrer">https://missing-semester-cn.github.io/</a></li><li><a href="https://web.mit.edu/~simsong/www/ugh.pdf" target="_blank" rel="noopener noreferrer">The UNIX-Hater&#x27;s Handbook</a> </li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="dys-typora-open://mine/survival/docs/编程基础/操作系统/操作系统.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/编程基础/计算机组成原理/计算机系统基础"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 计算机系统基础</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/编程基础/操作系统/Unix系统管理"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Unix系统管理 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#linux学习路线" class="table-of-contents__link">Linux学习路线</a></li><li><a href="#操作系统发展史" class="table-of-contents__link">操作系统发展史</a></li><li><a href="#现代操作系统原理" class="table-of-contents__link">现代操作系统原理</a></li><li><a href="#unix环境编程" class="table-of-contents__link">Unix环境编程</a></li><li><a href="#unix系统管理" class="table-of-contents__link">Unix系统管理</a></li><li><a href="#基本特征" class="table-of-contents__link">基本特征</a><ul><li><a href="#并发" class="table-of-contents__link">并发</a></li><li><a href="#共享" class="table-of-contents__link">共享</a></li><li><a href="#虚拟" class="table-of-contents__link">虚拟</a></li><li><a href="#异步" class="table-of-contents__link">异步</a></li></ul></li><li><a href="#基本功能" class="table-of-contents__link">基本功能</a><ul><li><a href="#进程管理" class="table-of-contents__link">进程管理</a></li><li><a href="#内存管理" class="table-of-contents__link">内存管理</a></li><li><a href="#文件管理" class="table-of-contents__link">文件管理</a></li><li><a href="#设备管理" class="table-of-contents__link">设备管理</a></li></ul></li><li><a href="#系统调用" class="table-of-contents__link">系统调用</a></li><li><a href="#宏内核和微内核" class="table-of-contents__link">宏内核和微内核</a><ul><li><a href="#宏内核" class="table-of-contents__link">宏内核</a></li><li><a href="#微内核" class="table-of-contents__link">微内核</a></li></ul></li><li><a href="#中断分类" class="table-of-contents__link">中断分类</a><ul><li><a href="#外中断" class="table-of-contents__link">外中断</a></li><li><a href="#异常" class="table-of-contents__link">异常</a></li><li><a href="#陷入" class="table-of-contents__link">陷入</a></li></ul></li><li><a href="#操作系统实例" class="table-of-contents__link">操作系统实例</a></li><li><a href="#参考：" class="table-of-contents__link">参考：</a></li><li><a href="#镜像加载" class="table-of-contents__link">镜像加载</a></li><li><a href="#启动过程" class="table-of-contents__link">启动过程</a><ul><li><a href="#加电-启动bios" class="table-of-contents__link">加电-启动BIOS</a></li><li><a href="#bootloader时期" class="table-of-contents__link">bootloader时期</a></li><li><a href="#内核启动" class="table-of-contents__link">内核启动</a></li></ul></li><li><a href="#系统调用-1" class="table-of-contents__link">系统调用</a></li><li><a href="#书籍" class="table-of-contents__link">书籍</a></li><li><a href="#网站" class="table-of-contents__link">网站</a></li><li><a href="#代码是如何控制硬件的" class="table-of-contents__link">代码是如何控制硬件的?</a></li><li><a href="#编译后的内核镜像-及其执行" class="table-of-contents__link">编译后的内核镜像 及其执行</a></li><li><a href="#教学操作系统" class="table-of-contents__link">教学操作系统</a></li><li><a href="#问题" class="table-of-contents__link">问题</a></li><li><a href="#理解" class="table-of-contents__link">理解</a></li><li><a href="#学习资料" class="table-of-contents__link">学习资料</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.e736442d.js"></script>
<script src="/runtime~main.500606b1.js"></script>
<script src="/main.e34cadf8.js"></script>
<script src="/1.3353372a.js"></script>
<script src="/256.3f6603bc.js"></script>
<script src="/257.427a7301.js"></script>
<script src="/935f2afb.0ee8c40a.js"></script>
<script src="/255.24175022.js"></script>
<script src="/fa2f39ef.46b97fd2.js"></script>
</body>
</html>