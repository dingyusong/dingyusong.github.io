<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Blog Atom Feed"><title data-react-helmet="true">编译原理 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="编译原理 | My Site"><meta data-react-helmet="true" name="description" content="编译原理"><meta data-react-helmet="true" property="og:description" content="编译原理"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/编程基础/编译原理/编译原理"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/编程基础/编译原理/编译原理"><link rel="stylesheet" href="/styles.8cfbcdec.css">
<link rel="preload" href="/styles.9888532b.js" as="script">
<link rel="preload" href="/runtime~main.73fb2e0e.js" as="script">
<link rel="preload" href="/main.a2e30791.js" as="script">
<link rel="preload" href="/1.fa235d9f.js" as="script">
<link rel="preload" href="/2.8423217f.js" as="script">
<link rel="preload" href="/257.8905f2ed.js" as="script">
<link rel="preload" href="/258.3860215e.js" as="script">
<link rel="preload" href="/935f2afb.ce536a1e.js" as="script">
<link rel="preload" href="/17896441.d8a5f7af.js" as="script">
<link rel="preload" href="/07bc5dd7.67eb6c76.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/编程基础/编程基础/编程基础">编程基础</a><a class="navbar__item navbar__link" href="/docs/编程语言/编程语言">编程语言</a><a class="navbar__item navbar__link" href="/docs/工具/常用工具">工具</a><a class="navbar__item navbar__link" href="/docs/应用开发/应用开发">应用开发</a><a class="navbar__item navbar__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a><a class="navbar__item navbar__link" href="/docs/音视频/音视频">音视频</a><a class="navbar__item navbar__link" href="/docs/项目/项目">项目</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Search" aria-label="Search" class="navbar__search-input search-bar"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/编程基础/编程基础/编程基础">编程基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程语言/编程语言">编程语言</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/工具/常用工具">工具</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/应用开发/应用开发">应用开发</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/Apple/iOS开发/iOS开发">Apple</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/音视频/音视频">音视频</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/项目/项目">项目</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/编程基础/编程基础">编程基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/学习经验/学习经验">学习经验</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">数字电路</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数字电路/数字电路">数字电路</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">计算机组成原理</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机组成原理">计算机组成原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机是怎么跑起来的">计算机是怎么跑起来的</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/计算机组成原理/计算机系统基础">计算机系统基础</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">操作系统</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/操作系统/操作系统">操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/操作系统/Unix系统管理">Unix系统管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/操作系统/Unix环境编程">Unix环境编程</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机网络/计算机网络">计算机网络</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/计算机系统基础/计算机系统基础">计算机系统基础</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">编译链接调试</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/编程基础/编译原理/编译原理">编译原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/编程基础/编译原理/程序员的自我修养">程序员的自我修养</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">数据结构与算法</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/数据结构与算法">数据结构与算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/数据结构">数据结构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/算法">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/编程基础/数据结构与算法/算法面试">算法面试</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程基础/设计模式/设计模式">设计模式</a></li></ul></div></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">编译原理</h1></header><div class="markdown"><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编译原理"></a>编译原理<a class="hash-link" href="#编译原理" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="简介"></a>简介<a class="hash-link" href="#简介" title="Direct link to heading">#</a></h2><p><strong>编译器的作用是把源文件翻译成目标文件。</strong></p><p>问题1：为什么要编译？或者是为什么要有编译器？</p><p>机器硬件只识别01二进制码，最开始的时候工程师是用打孔纸带，标识01二进制码，来进行输入，<strong>效率太低</strong>，表示7得用3为二进制111，效率怎么提升一点呢 ？搞个8进制，8进制的一位标识二进制的3位，</p><p>我们要把程序员写的语言翻译成机器能够识别的语言，这个过程叫编译。</p><p>问题2：他是怎么把源文件翻译成目标文件的？</p><p>两个部分：分析部分和综合部分。</p><p>分析部分：把源程序分解成多个组成要素，并在这些要素之上加上语法结构。然后它使用这个结构来创建源程序的一个中间表示。如果分析部分检查出源程序没有按照正确的语法构成，或者语义上不一致，他就必须提供有用的信息，使得用户可以按此进行改正。分析部分还会搜集有关源程序的信息，并把信息存在一个称为符号表（symbol table）的数据结构中。符号表将和中间表示形式一起传送给综合部分。</p><p>综合部分：根据中间表示和符号表中的信息来构造用户期待的目标程序。</p><p>分析部分经常被称为编译器的前端（front end），而综合部分被称为后端（back end）。</p><p>问题3：如何设计和实现一个编译器？</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编译器的步骤"></a>编译器的步骤<a class="hash-link" href="#编译器的步骤" title="Direct link to heading">#</a></h2><p>编译器的步骤：</p><p><img alt="image-20210313182027486" src="/assets/images/image-20210313182027486-9f32111378dff1dcb41673cedc7ba2b8.png"></p><p><img alt="image-20210313184934801" src="/assets/images/image-20210313184934801-26456e486d01a3263a4f2772001af68c.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="词法分析"></a>词法分析<a class="hash-link" href="#词法分析" title="Direct link to heading">#</a></h3><p>编译器的第一个步骤：叫<code>词法分析：lexical analysis</code> 或者<code>扫描：scanning </code>。</p><p>词法分析器读入组成源程序的字符流，并将它们组成有意义的<code>词素：lexeme</code>。</p><p>对于每个词素，词法分析器产生如下形式的<code>词法单元（token）</code>作为输出：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;token-name, attribute-value&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>这个词法单元被 传给下个步骤，即语法分析。</p><p>比如一个源程序：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">position = initial + rate* 60</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>7个词素：</p><ol><li><p>position</p></li><li><p>=</p></li><li><p>initial</p></li><li><ul><li></li></ul></li><li><p>rate</p></li><li><ul><li></li></ul></li><li><p>60</p></li></ol><p>进过词法分析得到7个词法单元：</p><ol><li><code>&lt;id 1&gt;</code>		1指向position对应的符号表项目。</li><li><code>&lt;=&gt;</code>              这个标识符不需要词法分量，所以不需要属性值。</li><li><code>&lt;id 2&gt;</code></li><li><code>&lt;+&gt;</code></li><li><code>&lt;id 3&gt;</code></li><li><code>&lt;*&gt;</code></li><li><code>&lt;60&gt;</code></li></ol><p>经过词法分析后</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">position = initial + rate* 60</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>变成：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;id 1&gt; &lt;=&gt; &lt;id 2&gt; &lt;+&gt; &lt;id 3&gt; &lt;*&gt; &lt;60&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="语法分析"></a>语法分析<a class="hash-link" href="#语法分析" title="Direct link to heading">#</a></h3><p>语法分析（syntax analysis） 或解析（parsing）</p><p>常用的表示方法是语法树（syntax tree）。</p><blockquote><p>这一步就是要生成一棵树。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="语义分析"></a>语义分析<a class="hash-link" href="#语义分析" title="Direct link to heading">#</a></h3><p>语义分析（ semantic   analysis） </p><p>一个重要部分是类型检查。比如数组的下标必须是整形。如果用浮点数作为数组下标就应该报错。</p><p>也可能允许某些类型的转换。比如整形转为浮点型。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="中间代码生成"></a>中间代码生成<a class="hash-link" href="#中间代码生成" title="Direct link to heading">#</a></h3><p>将中间表示（可能是语法树）形式翻译成中间表示代码。</p><p>易于生成，且能够被轻松翻译为目标机器上的语言。</p><p>三地址代码（three-adress code）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="代码优化"></a>代码优化<a class="hash-link" href="#代码优化" title="Direct link to heading">#</a></h3><p>有机器无关优化和机器相关优化。</p><p>不同的编译器所做的代码优化工作差异很大。</p><p>有些简单的优化工作可以可以极大地提高目标程序的运行效率。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="代码生成"></a>代码生成<a class="hash-link" href="#代码生成" title="Direct link to heading">#</a></h3><p>输入： 源程序的中间表示形式。</p><p>输出：目标语言。</p><p>代码生成的一个重要的方面是合理分配寄存器。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="符号表管理"></a>符号表管理<a class="hash-link" href="#符号表管理" title="Direct link to heading">#</a></h3><ol><li><p>变量</p><p>记录源程序中使用的变量的名字。并搜集和每个名字各种属性有关的信息。这些属性提供一个名字的存储分配，类型，作用域等信息。</p></li></ol><ol start="2"><li>过程</li></ol><p>也就是我们所说的函数。还包括，参数的数量，类型，传递方法，返回类型。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="将多个步骤组合成趟"></a>将多个步骤组合成趟<a class="hash-link" href="#将多个步骤组合成趟" title="Direct link to heading">#</a></h3><p>多个步骤的活动会被组合成一趟（pass）。每趟读入一个输入文件并产生一个输出文件。</p><p>特定语言的前端和特定目标机定的后端。</p><p>不同的前端和某个目标机的结合。</p><p>相同的前端和不同的目标机后端结合，建立针对不同目标机的编译器。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编译器构造工具"></a>编译器构造工具<a class="hash-link" href="#编译器构造工具" title="Direct link to heading">#</a></h3><p>写编译器的工具</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编程语言的发展历程"></a>编程语言的发展历程<a class="hash-link" href="#编程语言的发展历程" title="Direct link to heading">#</a></h2><p>程序设计语言的发展历程。</p><p>通过语言的代来分类：</p><p>第一代：机器语言</p><p>第二代：汇编语言</p><p>第三代：高级程序设计语言（Fortran，Cobol，Lisp，C，C++, C#, java）</p><p>第四代：为特定应用设计的语言。（数据库的SQL，生成报告的NOMAD，文本排版的postscript）</p><p>第五代：基于逻辑个约束的语言。（Prolog，OPS5）</p><p>强制式语言（imperative）</p><p>声明式语言（declarative）</p><p>冯诺依曼语言。</p><p>面向对象语言。（object-oriented language）</p><p>脚本语言。（scripting language）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编程语言对编译器的影响"></a>编程语言对编译器的影响<a class="hash-link" href="#编程语言对编译器的影响" title="Direct link to heading">#</a></h3><p>编译器本身就是一个大程序。</p><p>编译器和语言相互影响。</p><p>编译器对程序的高效运行至关重要。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="构建一个编译器相关科学"></a>构建一个编译器相关科学<a class="hash-link" href="#构建一个编译器相关科学" title="Direct link to heading">#</a></h2><p>接受一个问题，写出抓住问题关键特性的数学抽象表示，并用数学技术来解决他。</p><p>编译器设计和实现中的建模。</p><p>有穷状态机，正则表达式。</p><p>上下文无关法。</p><p>树形结构。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编译技术的应用"></a>编译技术的应用<a class="hash-link" href="#编译技术的应用" title="Direct link to heading">#</a></h2><p>高级程序设计语言的实现。</p><p>高级程序设计语言，编程比较容易但是效率比较低。优化编译器，可以弥补高层次抽象而引入的低效率。</p><p>低级程序设计语言，编程比较困难效率比较高。</p><p>针对计算机体系结构的优化</p><ul><li>并行性</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="程序设计语言基础"></a>程序设计语言基础<a class="hash-link" href="#程序设计语言基础" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="静态和动态的区别："></a>静态和动态的区别：<a class="hash-link" href="#静态和动态的区别：" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编译时"></a>编译时<a class="hash-link" href="#编译时" title="Direct link to heading">#</a></h4><p>静态策略（static policy）或者说是编译时刻（compile time）决定。</p><p>编译时顾名思义就是正在编译的时候。</p><p>编译时就是简单的作一些翻译工作,比如检查老兄你有没有粗心写错啥关键字了啊.有啥词法分析,语法分析之类的过程.就像个老师检查学生的作文中有没有错别字和病句一样.如果发现啥错误编译器就告诉你.如果你用微软的VS的话,点下build.那就开始编译,如果下面有errors或者warning信息,那都是编译器检查出来的.所谓这时的错误就叫编译时错误,这个过程中做的啥类型检查也就叫编译时类型检查,或静态类型检查(所谓静态嘛就是没把真把代码放内存中运行起来,而只是把代码当作文本来扫描下).</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="运行时"></a>运行时<a class="hash-link" href="#运行时" title="Direct link to heading">#</a></h4><p>动态策略(dynamic policy) 或者说是运行时刻（run time）决定。</p><p>编译时就是简单的作一些翻译工作,比如检查老兄你有没有粗心写错啥关键字了啊.有啥词法分析,语法分析之类的过程.就像个老师检查学生的作文中有没有错别字和病句一样.如果发现啥错误编译器就告诉你.如果你用微软的VS的话,点下build.那就开始编译,如果下面有errors或者warning信息,那都是编译器检查出来的.所谓这时的错误就叫编译时错误,这个过程中做的啥类型检查也就叫编译时类型检查,或静态类型检查(所谓静态嘛就是没把真把代码放内存中运行起来,而只是把代码当作文本来扫描下).</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="举例说明"></a>举例说明<a class="hash-link" href="#举例说明" title="Direct link to heading">#</a></h4><p>可能光讲概念你还是迷糊.还分别用C++和C#来举个简单点的例子.数组越界检查的例子(开发工具用的微软的VS)</p><p>C++中</p><p>int arr[] = {1,2,3};</p><p>int result = arr[4];</p><p>cout&lt;&lt;result&lt;&lt;endl;</p><p>上面的代码你一瞧你知道是错误的代码,数组越界了.但用编译器一编译,一点错都没.可见编译器其实还是挺笨的,还没你脑瓜子那么聪明啊.然后开始运行,Start Dubugging.于是报错了,于是你想虽然编译器笨了点,但运行起来时发现了错误也还不算太坏.但实际上运行时做数组的越界检查不是C++里面支持的特性,这里你dubug是VS中的一些工具给你做的检查.你如果点运行时选的是release而不是dubug的话会发现一切正常运行,但得到的结果不确定的.
————————————————
版权声明：本文为CSDN博主「聪明的笨蛋」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：<a href="https://blog.csdn.net/weiwenhp/article/details/8107203" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weiwenhp/article/details/8107203</a></p><p>Q.下面的代码片段中，行A和行B所标识的代码有什么区别呢？</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class ConstantFolding {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static final int number1 = 5;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static final int number2 = 6;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int number3 = 5;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int number4= 6;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main(String[ ] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int product1 = number1 * number2; //line A</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int product2 = number3 * number4; //line B</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>A.在行A的代码中，product的值是在编译期计算的，行B则是在运行时计算的。如果你使用Java反编译器（例如，jd-gui）来反编译ConstantFolding.class文件的话，那么你就会从下面的结果里得到答案。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class ConstantFolding {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static final int number1 = 5;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static final int number2 = 6;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int number3 = 5;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int number4 = 6;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main(String[ ] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int product1 = 30;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int product2 = number3 * number4;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>参考：<a href="https://www.cnblogs.com/downey/p/4946807.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/downey/p/4946807.html</a></p><p>【iOS沉思录】Objective-C语言的动态性总结(编译时与运行时) ：<a href="https://blog.csdn.net/cordova/article/details/53876682" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/cordova/article/details/53876682</a></p><p><img alt="image-20210314114129401" src="/assets/images/image-20210314114129401-bed6e33f6497e2245ee4feb4accaf39f.png"></p><p>名字到位置的动态绑定和静态绑定。</p><p>位置到值的动态绑定和静态绑定。</p><p><img alt="C_complie" src="/assets/images/GCC_CompilationProcess-f6d7922e1ff8c9d0c26245683ec2553c.png"></p><p>参考： <a href="https://www.cnblogs.com/CarpenterLee/p/5994681.html" target="_blank" rel="noopener noreferrer">C语言编译过程详解</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="x64-asm-常用汇编指令"></a>x64 ASM 常用汇编指令<a class="hash-link" href="#x64-asm-常用汇编指令" title="Direct link to heading">#</a></h2><p><a href="https://blog.csdn.net/thisinnocence/article/details/50936470?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-2&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/thisinnocence/article/details/50936470?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-2&amp;spm=1001.2101.3001.4242</a></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">双目运算</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">addq S, D D = D + S</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">subq S, D D = D - S</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">imulq S, D D = D * S</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">xorq S, D D = D ^ S</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">orq S, D D = D | S</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">andq S, D D = D &amp; S</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>dwarf 栈解析格式小结</p><p><a href="https://blog.csdn.net/bme314/article/details/107769543" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/bme314/article/details/107769543</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="dwarf简介"></a>dwarf简介<a class="hash-link" href="#dwarf简介" title="Direct link to heading">#</a></h2><p><a href="https://blog.csdn.net/helloworlddm/article/details/76785319" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/helloworlddm/article/details/76785319</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="llvm"></a>llvm<a class="hash-link" href="#llvm" title="Direct link to heading">#</a></h2><p><a href="https://github.com/llvm-mirror/libcxx/blob/master/include/__tree" target="_blank" rel="noopener noreferrer">https://github.com/llvm-mirror/libcxx/blob/master/include/__tree</a></p><p>自己写一遍编译器：</p><p>参考：两周自制一个脚本编译器。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="abi"></a>ABI<a class="hash-link" href="#abi" title="Direct link to heading">#</a></h2><blockquote><p>找不到符号！</p><p>ld: symbol(s) not found for architecture x86_64</p></blockquote><p>动态库的方法或者变量的地址不能随意更改，比如open这个方法可能已经被无数上层库或者应用程序依赖使用了，所以不能轻易更改，链接的老地址找不到相应的符号就要报错，更改之后就得重新编译，这个问题就大了。 主要针对的是动态库可能出问题的场景。我们的C++的sdk用了一个c接口对外提供服务，目的就是保持动态库的ABI兼容。</p><p>ABI：<code>main</code>使用到了<code>Add</code>这个<code>API</code>，这个<code>API</code>包含再一个<code>myso</code>动态库里面，现在设计到一个符号寻找机制，即编译器需要去<code>myso</code>动态库里面寻找<code>Add</code>这个符号，那符号的命名规则不一致会导致什么结果？如<code>gcc1.0</code>版本的符号命名规则是再函数前面加一个<code>_</code>，即最后<code>Add</code>符号名称<code>_Add</code>, <code>gcc2.0</code>版本的符号命名规则是再函数后面加一个<code>_</code>, 即最后Add符号名称<code>Add_</code>。思考一个问题，<code>myso</code>是利用<code>gcc1.0</code>版本编译，<code>main</code>使用<code>gcc2.0</code>版本编译，会出现是什么问题？ 编译器会提示你<code>Add_</code>符号未定义，这里说的符号导出规则也就是属于<code>ABI</code>兼容问题。</p><p>作者：spider集控团队
链接：<a href="https://juejin.cn/post/6894179449996312589" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6894179449996312589</a>
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>二进制兼容</p><ul><li><a href="https://juejin.cn/post/6894179449996312589" target="_blank" rel="noopener noreferrer">细谈ABI (Application Binary interface)</a></li><li><a href="https://blog.csdn.net/u010942902/article/details/103975622" target="_blank" rel="noopener noreferrer">C++ ABI探究和兼容性问题</a></li></ul><p><a href="http://jyywiki.cn/ICS/2020/slides/7.slides#/2/2" target="_blank" rel="noopener noreferrer">Application Binary Interface (ABI)</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="链接报错"></a>链接报错<a class="hash-link" href="#链接报错" title="Direct link to heading">#</a></h3><p>场景2 运行可执行文件时候出现错误 /usr/lib/libstdc++.so.6: version `GLIBCXX_3.4.20’ not found
参考<a href="https://gcc.gnu.org/onlinedocs/libstdc++/faq.html#faq.how_to_set_paths" target="_blank" rel="noopener noreferrer">https://gcc.gnu.org/onlinedocs/libstdc++/faq.html#faq.how_to_set_paths</a>
这个错误是连接器报的错误，原因是可执行文件是用比较新的GCC编译出来的，但是现在运行时候被连接到了老的libstdc++.so.6库， 其实也就是ABI不匹配了。
————————————————
版权声明：本文为CSDN博主「wqfhenanxc」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：<a href="https://blog.csdn.net/wqfhenanxc/article/details/111307596" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/wqfhenanxc/article/details/111307596</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="c库"></a>C库<a class="hash-link" href="#c库" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="libc"></a>libc<a class="hash-link" href="#libc" title="Direct link to heading">#</a></h3><p>libc：Linux下原来的标准C库，后来逐渐被glibc取代。在此之前除了有libc，还有klibc,uclibc。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="glibc"></a>glibc<a class="hash-link" href="#glibc" title="Direct link to heading">#</a></h3><p>glibc：也就是传说中的GNU C Library,现在只要知道用的最多的是glibc就行了，主流的一些linux操作系统如 Debian, Ubuntu，Redhat等用的都是glibc。</p><p><strong>glibc都做了些什么</strong></p><p>glibc是Linux系统中最底层的API，几乎其它任何的运行库都要依赖glibc。 glibc最主要的功能就是对系统调用的封装，你想想看，你怎么能在C代码中直接用fopen函数就能打开文件？ 打开文件最终还是要触发系统中的sys_open系统调用，而这中间的处理过程都是glibc来完成的。<a href="http://www.chongh.wiki/blog/2016/04/08/linux-syscalls/" target="_blank" rel="noopener noreferrer">这篇文章</a>详细介绍了glibc是如何与上层应用程序和系统调用交互的。除了封装系统调用，glibc自身也提供了一些上层应用函数必要的功能,如string,malloc,stdlib,linuxthreads,locale,signal等等。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="eglibc"></a>eglibc<a class="hash-link" href="#eglibc" title="Direct link to heading">#</a></h3><p> 这里的e是Embedded的意思，也就是前面说到的变种glibc。eglibc的主要特性是为了更好的支持嵌入式架构，可以支持不同的shell(包括嵌入式)，但它是二进制兼容glibc的，就是说如果你的代码之前依赖eglibc库，那么换成glibc后也不需要重新编译。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="glib"></a>glib<a class="hash-link" href="#glib" title="Direct link to heading">#</a></h3><p>glib也是个c程序库，不过比较轻量级，glib将C语言中的数据类型统一封装成自己的数据类型，提供了C语言常用的数据结构的定义以及处理函数，有趣的宏以及可移植的封装等(注：glib是可移植的，说明你可以在linux下，也可以在windows下使用它）。那它跟glibc有什么关系吗？其实并没有，除非你的程序代码会用到glib库中的数据结构或者函数，glib库在ubuntu系统中并不会默认安装(可以通过apt-get install libglib2.0-dev手动安装)，著名的GTK+和Gnome底层用的都是glib库。想更详细了解glib？ 可以参考<a href="https://developer.gnome.org/glib/" target="_blank" rel="noopener noreferrer">这里</a></p><p><strong>影响重大</strong></p><p>你要时刻知道glibc/eglibc的影响有多大，不管你之前部署的什么程序，linux系统的ls,cd,mv,ps等等全都得依赖它，很多人在更换/升级都有过惨痛的教训，甚至让整个系统奔溃无法启动。所以，强烈不建议更换/升级这些库！</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="c库-1"></a>C++库<a class="hash-link" href="#c库-1" title="Direct link to heading">#</a></h2><ul><li>libc++/libstdc++ 两个都是C++标准库</li></ul><p>libc++/libstdc++,这两个库有关系吗？有。两个都是C++标准库。libc++是针对clang编译器特别重写的C++标准库，那libstdc++自然就是gcc的事儿了。libstdc++与gcc的关系就像clang与libc++. 其中的区别这里不作详细介绍了。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="libc-1"></a>libc++<a class="hash-link" href="#libc-1" title="Direct link to heading">#</a></h3><p>libc++是针对clang编译器特别重写的C++标准库。</p><p><a href="https://libcxx.llvm.org/" target="_blank" rel="noopener noreferrer">https://libcxx.llvm.org/</a></p><p>文档： <a href="https://libcxx.llvm.org/docs/" target="_blank" rel="noopener noreferrer">https://libcxx.llvm.org/docs/</a> </p><p>源码：<a href="https://github.com/llvm/llvm-project" target="_blank" rel="noopener noreferrer">https://github.com/llvm/llvm-project</a>     libcxx文件夹</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="libstdc"></a>libstdc++<a class="hash-link" href="#libstdc" title="Direct link to heading">#</a></h3><ul><li>与gcc捆绑</li></ul><p>libstdc++与gcc是捆绑在一起的，也就是说安装gcc的时候会把libstdc++装上。</p><ul><li>不与内核打交道</li></ul><p>相比glibc，libstdc++虽然提供了c++程序的标准库，但它并不与内核打交道。对于系统级别的事件，libstdc++首先是会与glibc交互，才能和内核通信。相比glibc来说，libstdc++就显得没那么基础了。</p><p><a href="https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/index.html" target="_blank" rel="noopener noreferrer">https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/index.html</a></p><p><a href="https://github.com/gcc-mirror/gcc" target="_blank" rel="noopener noreferrer">https://github.com/gcc-mirror/gcc</a></p><p>源码： <a href="git://gcc.gnu.org/git/gcc.git" target="_blank" rel="noopener noreferrer">git://gcc.gnu.org/git/gcc.git</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编译器-gcc和g"></a>编译器 gcc和g++<a class="hash-link" href="#编译器-gcc和g" title="Direct link to heading">#</a></h2><ul><li>gcc可以编译c++</li></ul><p>后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序。</p><p>在编译阶段，g++会调用gcc,对于c++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库联接，需要这样，gcc -lstdc++, 所以如果你的Makefile文件并没有手动加上libstdc++库，一般就会提示错误，要求你安装g++编译器了。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编译实践"></a>编译实践<a class="hash-link" href="#编译实践" title="Direct link to heading">#</a></h2><p>增加C++支持</p><p>在单独编写一个C或C++的项目时，如果该项目需要引用到第三方 库，那么编译阶段需要配置参数“extra-cflags，-I”来指定引用头文件的位 置，链接阶段需要配置参数“ld-flags，-L”来指定静态库的位置，并且使 用-l来指定引用的是哪一个库。在C++的编译中，如果需要在程序的执行 过程中带入一些宏(define的常量)，那么就应该在“extra-cflags”的后面增 加自己需要定义的宏，例如-DAUTO_TEST，这就相当于在程序中编写了 如下一行代码:</p><p>define AUTO_TEST</p><p>那么在Xcode中，应该如何指定头文件、第三方库，以及预定义宏 呢?其实，Xcode里面已经存在了对应的参数设置，只需要在Build Settings中设置这些参数即可。首先对应于-I来指定头文件的目录，Xcode 使用Search Paths来设置头文件的搜索路径，通常会用到Header Search Paths选项来指定头文件的搜索路径。其中预定义变量$(SRCROOT)和$ (PROJECT_DIR)都是项目的根目录，可以基于这两个预定义变量再加上 相对路径来指定头文件所在的具体位置;预定义宏在Other C Flags选项 中，可以写入-DAUTO_TEST，表示定义了AUTO_TEST宏;在指定第三 方库时，-L对应到Xcode中就是other Link flags选项，其中可以写入需要 链接的库文件;在Xcode项目中直接添加一个静态库文件，Xcode会默认 在Build phases选项的Link Binary with Library里加入该静态库，但是如果 Xcode没有自动加入该静态库的话，就需要开发者手动加一下，这里其实 也是-L的一种表示方式。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">➜  /Users/dingyusong pkg-config --cflags --libs libavcodec</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">-I/usr/local/Cellar/ffmpeg/4.4/include -L/usr/local/Cellar/ffmpeg/4.4/lib -lavcodec</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">➜  /Users/dingyusong gcc encode_video.c `pkg-config --cflags --libs libavcodec` -o encode_video</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>gcc的-l -I -L：<a href="https://www.jianshu.com/p/8e846269e5f7" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/8e846269e5f7</a></p><ul><li><p>编译阶段需要配置参数“extra-cflags，-I”来指定引用头文件的位置，</p></li><li><p>链接阶段需要配置参数“ld-flags，-L”来指定静态库的位置，并且使 用-l来指定引用的是哪一个库。</p></li></ul><p>放在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接了</p><p>如果不在/lib和/usr/lib和/usr/local/lib里面，那么就要<code>-L </code>指明目录</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">-lworld`表示在上面的lib的路径中寻找libworld.so动态库文件（如果gcc编译选项中加入了“-static”表示寻找`libworld.a`静态库文件），程序链接的库名是`world</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>pkg-config 可以很方便的帮我们解决查找头文件和库文件的位置问题。</p><p><code>pkg-config --cflags --libs libavcodec</code></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="交叉编译"></a>交叉编译<a class="hash-link" href="#交叉编译" title="Direct link to heading">#</a></h2><p>大部分的嵌入式开发平台都提供了本身平台交叉编译所 需要的交叉工具编译链，通过该交叉工具编译链，开发者就能在PC上编 译出可以运行在ARM平台下的程序了。</p><p>参考：音视频开发进阶指南-交叉编译</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="automakeautoconf"></a>Automake/Autoconf<a class="hash-link" href="#automakeautoconf" title="Direct link to heading">#</a></h2><p><a href="https://blog.csdn.net/yunhua_lee/article/details/6172614" target="_blank" rel="noopener noreferrer">大型项目使用Automake/Autoconf完成编译配置(1)——提纲挈领</a></p><p><a href="https://blog.csdn.net/yunhua_lee/article/details/6172617" target="_blank" rel="noopener noreferrer">大型项目使用Automake/Autoconf完成编译配置(2)——步步为营</a></p><p><a href="https://www.jianshu.com/p/17e777868d6b" target="_blank" rel="noopener noreferrer">Automake的使用</a></p><p><a href="https://gcc.gnu.org/install/configure.html" target="_blank" rel="noopener noreferrer">https://gcc.gnu.org/install/configure.html</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="swift编译器"></a>Swift编译器<a class="hash-link" href="#swift编译器" title="Direct link to heading">#</a></h2><ul><li><a href="https://swift.org/swift-compiler/" target="_blank" rel="noopener noreferrer">https://swift.org/swift-compiler/</a></li><li><a href="https://www.jianshu.com/p/7c894f9b7b02" target="_blank" rel="noopener noreferrer">Swift编译器结构分析</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="经验之谈"></a>经验之谈<a class="hash-link" href="#经验之谈" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="编译和运行"></a>编译和运行<a class="hash-link" href="#编译和运行" title="Direct link to heading">#</a></h3><p>在编程的过程中，难免会经历修改代码 → 编译 → 运行 → 修改代码……这样的循环。你会选择怎么做呢？新手每次都键入命令 (或者他发现 Ctrl-p 可以重复命令，或者在终端里按上箭头)。</p><ul><li>之后，有同学人发现，可以把命令写在一行里，比如 <code>gcc a.c &amp;&amp; ./a.out</code>，一键就能编译运行了。</li><li>再之后会发现可以写个 Makefile (就像这个实验一样)，用 <code>make test</code> 跑完所有测试。</li><li>再之后会发现可以每次在文件改动以后自动运行所有测试……有个神奇的命令叫 <code>inotifywait</code>。</li></ul><p>参考: <a href="http://jyywiki.cn/OS/2021/labs/M1" target="_blank" rel="noopener noreferrer">http://jyywiki.cn/OS/2021/labs/M1</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="参考"></a>参考<a class="hash-link" href="#参考" title="Direct link to heading">#</a></h2><ul><li><p>编译原理（哈工大）：<a href="https://www.bilibili.com/video/BV1zW411t7YE" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1zW411t7YE</a>  课件已经存储到丁的百度云</p></li><li><p><a href="https://www.icourse163.org/course/HIT-1002123007" target="_blank" rel="noopener noreferrer">https://www.icourse163.org/course/HIT-1002123007</a></p></li><li><p><a href="https://www.icourse163.org/topics/2018NationalLevelMOOC/" target="_blank" rel="noopener noreferrer">https://www.icourse163.org/topics/2018NationalLevelMOOC/</a></p></li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="dys-typora-open://mine/survival/docs/编程基础/编译原理/编译原理.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/编程基础/计算机系统基础/计算机系统基础"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 计算机系统基础</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/编程基础/编译原理/程序员的自我修养"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">程序员的自我修养 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#简介" class="table-of-contents__link">简介</a></li><li><a href="#编译器的步骤" class="table-of-contents__link">编译器的步骤</a><ul><li><a href="#词法分析" class="table-of-contents__link">词法分析</a></li><li><a href="#语法分析" class="table-of-contents__link">语法分析</a></li><li><a href="#语义分析" class="table-of-contents__link">语义分析</a></li><li><a href="#中间代码生成" class="table-of-contents__link">中间代码生成</a></li><li><a href="#代码优化" class="table-of-contents__link">代码优化</a></li><li><a href="#代码生成" class="table-of-contents__link">代码生成</a></li><li><a href="#符号表管理" class="table-of-contents__link">符号表管理</a></li><li><a href="#将多个步骤组合成趟" class="table-of-contents__link">将多个步骤组合成趟</a></li><li><a href="#编译器构造工具" class="table-of-contents__link">编译器构造工具</a></li></ul></li><li><a href="#编程语言的发展历程" class="table-of-contents__link">编程语言的发展历程</a><ul><li><a href="#编程语言对编译器的影响" class="table-of-contents__link">编程语言对编译器的影响</a></li></ul></li><li><a href="#构建一个编译器相关科学" class="table-of-contents__link">构建一个编译器相关科学</a></li><li><a href="#编译技术的应用" class="table-of-contents__link">编译技术的应用</a></li><li><a href="#程序设计语言基础" class="table-of-contents__link">程序设计语言基础</a><ul><li><a href="#静态和动态的区别：" class="table-of-contents__link">静态和动态的区别：</a></li></ul></li><li><a href="#x64-asm-常用汇编指令" class="table-of-contents__link">x64 ASM 常用汇编指令</a></li><li><a href="#dwarf简介" class="table-of-contents__link">dwarf简介</a></li><li><a href="#llvm" class="table-of-contents__link">llvm</a></li><li><a href="#abi" class="table-of-contents__link">ABI</a><ul><li><a href="#链接报错" class="table-of-contents__link">链接报错</a></li></ul></li><li><a href="#c库" class="table-of-contents__link">C库</a><ul><li><a href="#libc" class="table-of-contents__link">libc</a></li><li><a href="#glibc" class="table-of-contents__link">glibc</a></li><li><a href="#eglibc" class="table-of-contents__link">eglibc</a></li><li><a href="#glib" class="table-of-contents__link">glib</a></li></ul></li><li><a href="#c库-1" class="table-of-contents__link">C++库</a><ul><li><a href="#libc-1" class="table-of-contents__link">libc++</a></li><li><a href="#libstdc" class="table-of-contents__link">libstdc++</a></li></ul></li><li><a href="#编译器-gcc和g" class="table-of-contents__link">编译器 gcc和g++</a></li><li><a href="#编译实践" class="table-of-contents__link">编译实践</a></li><li><a href="#交叉编译" class="table-of-contents__link">交叉编译</a></li><li><a href="#automakeautoconf" class="table-of-contents__link">Automake/Autoconf</a></li><li><a href="#swift编译器" class="table-of-contents__link">Swift编译器</a></li><li><a href="#经验之谈" class="table-of-contents__link">经验之谈</a><ul><li><a href="#编译和运行" class="table-of-contents__link">编译和运行</a></li></ul></li><li><a href="#参考" class="table-of-contents__link">参考</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.9888532b.js"></script>
<script src="/runtime~main.73fb2e0e.js"></script>
<script src="/main.a2e30791.js"></script>
<script src="/1.fa235d9f.js"></script>
<script src="/2.8423217f.js"></script>
<script src="/257.8905f2ed.js"></script>
<script src="/258.3860215e.js"></script>
<script src="/935f2afb.ce536a1e.js"></script>
<script src="/17896441.d8a5f7af.js"></script>
<script src="/07bc5dd7.67eb6c76.js"></script>
</body>
</html>