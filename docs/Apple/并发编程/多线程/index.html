<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Blog Atom Feed"><title data-react-helmet="true">多线程 | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="多线程 | My Site"><meta data-react-helmet="true" name="description" content="title: iOS开发之多线程"><meta data-react-helmet="true" property="og:description" content="title: iOS开发之多线程"><meta data-react-helmet="true" property="og:url" content="http://localhost:9999//docs/Apple/并发编程/多线程"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="http://localhost:9999//docs/Apple/并发编程/多线程"><link rel="stylesheet" href="/styles.8cfbcdec.css">
<link rel="preload" href="/styles.4ec932fe.js" as="script">
<link rel="preload" href="/runtime~main.3425bbd6.js" as="script">
<link rel="preload" href="/main.4d172be4.js" as="script">
<link rel="preload" href="/1.978a979f.js" as="script">
<link rel="preload" href="/284.9b127a42.js" as="script">
<link rel="preload" href="/285.87bc8610.js" as="script">
<link rel="preload" href="/935f2afb.0ad17a86.js" as="script">
<link rel="preload" href="/283.46b48473.js" as="script">
<link rel="preload" href="/53c63f6e.552b2725.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a><a class="navbar__item navbar__link" href="/docs/">基础</a><a class="navbar__item navbar__link" href="/docs/编程语言/编程语言">语言</a><a class="navbar__item navbar__link" href="/docs/工具/常用工具">工具</a><a class="navbar__item navbar__link" href="/docs/应用开发/应用开发">应用开发</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/Apple/iOS开发/iOS开发">Apple</a><a class="navbar__item navbar__link" href="/docs/音视频/音视频">音视频</a><a class="navbar__item navbar__link" href="/docs/项目/项目">项目</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Search" aria-label="Search" class="navbar__search-input search-bar"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">My Site</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">基础</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/编程语言/编程语言">语言</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/工具/常用工具">工具</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/应用开发/应用开发">应用开发</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/Apple/iOS开发/iOS开发">Apple</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/音视频/音视频">音视频</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/项目/项目">项目</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">多线程</h1></header><div class="markdown"><p>title: iOS开发之多线程
toc: true
date: 2018-10-02 21:41:12
tags:  [应用开发 , iOS, Objective-C,多线程]
categories: [iOS]</p><hr><p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>Apple 官方多线程编程指南</p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i" target="_blank" rel="noopener noreferrer">Threading Programming Guide</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="ios中的常见多线程方案"></a>iOS中的常见多线程方案<a class="hash-link" href="#ios中的常见多线程方案" title="Direct link to heading">#</a></h2><p><img alt="image-20211012221444455" src="/assets/images/image-20211012221444455-a98d78fca0e8c44336e2bfb90d77feba.png"></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="pthread"></a>pthread<a class="hash-link" href="#pthread" title="Direct link to heading">#</a></h1><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="nsthread"></a>NSThread<a class="hash-link" href="#nsthread" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="创建线程"></a>创建线程<a class="hash-link" href="#创建线程" title="Direct link to heading">#</a></h2><p>instance method：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (instancetype)init API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)) NS_DESIGNATED_INITIALIZER;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (instancetype)initWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>使用实例方法手动创建的线程，都需要我们自己管理该线程，不只是启动，还有该线程使用完毕后的资源回收。</p><p>class method：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>使用类方法创建的线程，会自启动。</p><p>开一个子线程执行某任务，完成后回到主线程更新UI，实现线程通信，举个例子。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">//线程通信</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (IBAction)communication:(id)sender {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //开一个子线程执行某任务，完成后回到主线程更新UI，实现线程通信</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [NSThread detachNewThreadSelector:@selector(communicationTask) toTarget:self withObject:nil];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//线程通信任务</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)communicationTask {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;当前线程%@&quot;,[NSThread currentThread]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //模拟一个3秒的任务，完成后到主线程更新UI</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [NSThread sleepForTimeInterval:3];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [self performSelectorOnMainThread:@selector(updateUI:) withObject:[UIColor redColor] waitUntilDone:YES];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//更新UI</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)updateUI:(UIColor *)color {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    self.view.backgroundColor = color;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;我变红了%@&quot;,[NSThread currentThread]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="切换线程"></a>切换线程<a class="hash-link" href="#切换线程" title="Direct link to heading">#</a></h2><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@interface NSObject (NSThreadPerformAdditions)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // equivalent to the first method with kCFRunLoopCommonModes</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // equivalent to the first method with kCFRunLoopCommonModes</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="线程同步"></a>线程同步<a class="hash-link" href="#线程同步" title="Direct link to heading">#</a></h2><p>需要自己加锁，下面的两个NSOperation和GCD则没有这个问题。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="synchronized-object-"></a><code>@synchronized (object) {}</code><a class="hash-link" href="#synchronized-object-" title="Direct link to heading">#</a></h3><p>括号里的参数可以填任意对象，但是要注意的是，必须填写线程共有的变量才能实现上锁，局部变量是无效的，原因是，如果用局部变量，就会创建多个锁，这些锁之间并无关联，所以与不上锁没有区别：</p><p>因为在锁内进行数据操作时，其它线程都会阻塞在外面，这个时候，其实线程不是并发执行的，所以我们不难想到，锁内执行的任务越少，那么这段代码执行的效率就越高。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="nslock"></a>NSLock<a class="hash-link" href="#nslock" title="Direct link to heading">#</a></h3><p>当然也可以用<code>NSLock</code>来进行上锁，使用<code>NSLock</code>需要创建一个<code>NSLock</code>实例，然后调用<code>lock</code>和<code>unlock</code>方法来进行加锁和解锁的操作。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="nsthread延时"></a>NSThread延时<a class="hash-link" href="#nsthread延时" title="Direct link to heading">#</a></h2><p>　　此方式在主线程和子线程中均可执行。是一种阻塞的执行方式，建方放到子线程中，以免卡住界面，没有找到取消执行的方法。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">[NSThread sleepForTimeInterval:3];//延时当前线程</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="常用方法"></a>常用方法<a class="hash-link" href="#常用方法" title="Direct link to heading">#</a></h2><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">//设置名字</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [thread setName:@&quot;myThread&quot;];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //设置优先级，由0到1.0的浮点数指定，其中1.0是最高优先级。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [thread setThreadPriority:1];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //退出当前线程</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [NSThread exit];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //睡眠 单位是秒</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [NSThread sleepForTimeInterval:1];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //获取当前线程</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [NSThread currentThread];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //获取主线程</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [NSThread mainThread];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //判断是否在主线程</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [NSThread isMainThread];</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>参考文档：</p><ul><li><a href="https://www.cnblogs.com/zhanglinfeng/p/4980536.html" target="_blank" rel="noopener noreferrer">ios 多线程之NSThread篇举例详解</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="总结："></a>总结：<a class="hash-link" href="#总结：" title="Direct link to heading">#</a></h2><ol><li><p>构造器(类方法)方式创建子线程会自动启动，不需要管理比如：启动和取消。实例方法创建的需要。</p></li><li><p>在子线程中执行performSelector方法如果是带 afterDelay 的延时函数，会在内部创建一个 NSTimer，然后添加到当前线程的 Runloop 中。也就是如果当前线程没有开启 runloop，该方法会失效。在子线程中，需要启动 runloop(注意调用顺序)。</p></li></ol><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="gcd"></a>GCD<a class="hash-link" href="#gcd" title="Direct link to heading">#</a></h1><p>GCD中有2个用来执行任务的函数
用同步的方式执行任务
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);
queue：队列
block：任务</p><p>用异步的方式执行任务
dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</p><p>GCD源码：<a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="noopener noreferrer">https://github.com/apple/swift-corelibs-libdispatch</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="队列类型"></a>队列类型<a class="hash-link" href="#队列类型" title="Direct link to heading">#</a></h2><ul><li><p>串行队列</p></li><li><p>并行队列</p></li></ul><p>Grand Central Dispatch</p><p>队列：queue</p><p>GCD的队列可以分为2大类型
并发队列（Concurrent Dispatch Queue）
可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）
并发功能只有在异步（dispatch_async）函数下才有效</p><p>串行队列（Serial Dispatch Queue）
让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="容易混淆的术语"></a>容易混淆的术语<a class="hash-link" href="#容易混淆的术语" title="Direct link to heading">#</a></h3><p>有4个术语比较容易混淆：同步、异步、并发、串行
同步和异步主要影响：能不能开启新的线程
同步：在当前线程中执行任务，不具备开启新线程的能力
异步：在新的线程中执行任务，具备开启新线程的能力</p><p>并发和串行主要影响：任务的执行方式
并发：多个任务并发（同时）执行
串行：一个任务执行完毕后，再执行下一个任务</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="各种队列的执行效果"></a>各种队列的执行效果<a class="hash-link" href="#各种队列的执行效果" title="Direct link to heading">#</a></h3><p><img alt="image-20211012221637033" src="/assets/images/image-20211012221637033-d566f79f3dbc22a7c4a7a63c1c7bb0ba.png"></p><p><img alt="image-20211012221705193" src="/assets/images/image-20211012221705193-d17d9eb00c7d3250efa276101fa76c6d.png"></p><p><img alt="image-20211012221718972" src="/assets/images/image-20211012221718972-bff6a2d35a611cd5a58f32d3c055b58a.png"></p><p><img alt="image-20211012221729605" src="/assets/images/image-20211012221729605-de40da2cceb4b8abf94cf379f9b36c3f.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="队列组的使用"></a>队列组的使用<a class="hash-link" href="#队列组的使用" title="Direct link to heading">#</a></h2><p>思考：如何用gcd实现以下功能
异步并发执行任务1、任务2
等任务1、任务2都执行完毕后，再回到主线程执行任务3</p><p><img alt="image-20211012221805814" src="/assets/images/image-20211012221805814-8a7b8cd7f917af5c7d5744bfacfdd94b.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多线程的安全隐患"></a>多线程的安全隐患<a class="hash-link" href="#多线程的安全隐患" title="Direct link to heading">#</a></h2><p>资源共享
1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源
比如多个线程访问同一个对象、同一个变量、同一个文件</p><p>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多线程安全隐患示例01--存钱取钱"></a>多线程安全隐患示例01 – 存钱取钱<a class="hash-link" href="#多线程安全隐患示例01--存钱取钱" title="Direct link to heading">#</a></h3><p><img alt="image-20211012221908391" src="/assets/images/image-20211012221908391-32f91b991d9fc925fff09a68a1b24637.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多线程安全隐患示例02--卖票"></a>多线程安全隐患示例02 – 卖票<a class="hash-link" href="#多线程安全隐患示例02--卖票" title="Direct link to heading">#</a></h4><p><img alt="image-20211012221925458" src="/assets/images/image-20211012221925458-9744a4f6f64ba650b63897a02c7e03a4.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多线程安全隐患分析"></a>多线程安全隐患分析<a class="hash-link" href="#多线程安全隐患分析" title="Direct link to heading">#</a></h2><p><img alt="image-20211012222022293" src="/assets/images/image-20211012222022293-47c3c48303fc24ae734d24da87ec1cc8.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="多线程安全隐患的解决方案"></a>多线程安全隐患的解决方案<a class="hash-link" href="#多线程安全隐患的解决方案" title="Direct link to heading">#</a></h3><p>解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后次序进行）
常见的线程同步技术是：加锁</p><p><img alt="image-20211012222051472" src="/assets/images/image-20211012222051472-5c1a17de84ef215aaaf116b91d6c4586.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="ios中的线程同步方案"></a>iOS中的线程同步方案<a class="hash-link" href="#ios中的线程同步方案" title="Direct link to heading">#</a></h2><ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="gnustep"></a>GNUstep<a class="hash-link" href="#gnustep" title="Direct link to heading">#</a></h2><p>GNUstep是GNU计划的项目之一，它将Cocoa的OC库重新开源实现了一遍</p><p>源码地址：<a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener noreferrer">http://www.gnustep.org/resources/downloads.php</a></p><p>虽然GNUstep不是苹果官方源码，但还是具有一定的参考价值</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="osspinlock"></a>OSSpinLock<a class="hash-link" href="#osspinlock" title="Direct link to heading">#</a></h2><p>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源
目前已经不再安全，可能会出现优先级反转问题
如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁
需要导入头文件<code>#import &lt;libkern/OSAtomic.h&gt;</code></p><p><img alt="image-20211012222225397" src="/assets/images/image-20211012222225397-b284bbffa5f81336b70cc74ab385b2ef.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="os_unfair_lock"></a>os_unfair_lock<a class="hash-link" href="#os_unfair_lock" title="Direct link to heading">#</a></h2><p>os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持
从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等
需要导入头文件<code>#import &lt;os/lock.h&gt;</code></p><p><img alt="image-20211012222300997" src="/assets/images/image-20211012222300997-c1003c7c20c0d644dbc162eff6c8053b.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="pthread_mutex"></a>pthread_mutex<a class="hash-link" href="#pthread_mutex" title="Direct link to heading">#</a></h2><p>mutex叫做”互斥锁”，等待锁的线程会处于休眠状态
需要导入头文件<code>#import &lt;pthread.h&gt;</code></p><p><img alt="image-20211012222332114" src="/assets/images/image-20211012222332114-34ca89a417b24d2c6114cb80197bf82a.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="pthread_mutex--递归锁"></a>pthread_mutex – 递归锁<a class="hash-link" href="#pthread_mutex--递归锁" title="Direct link to heading">#</a></h2><p><img alt="image-20211012222350094" src="/assets/images/image-20211012222350094-467075266e14f5bac9d13cc2eed40571.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="pthread_mutex--条件"></a>pthread_mutex – 条件<a class="hash-link" href="#pthread_mutex--条件" title="Direct link to heading">#</a></h3><p><img alt="image-20211012222409190" src="/assets/images/image-20211012222409190-816d829a4f3cc70c48f30d57fcdc2c2a.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="nslock、nsrecursivelock"></a>NSLock、NSRecursiveLock<a class="hash-link" href="#nslock、nsrecursivelock" title="Direct link to heading">#</a></h2><p><img alt="image-20211012222427549" src="/assets/images/image-20211012222427549-eaf518a018b8996d59063bd2f392fcc6.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="nscondition"></a>NSCondition<a class="hash-link" href="#nscondition" title="Direct link to heading">#</a></h2><p>NSCondition是对mutex和cond的封装</p><p><img alt="image-20211012222449591" src="/assets/images/image-20211012222449591-55ede44f22884c98dba219222a82b3e9.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="nsconditionlock"></a>NSConditionLock<a class="hash-link" href="#nsconditionlock" title="Direct link to heading">#</a></h2><p>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值</p><p><img alt="image-20211012222529178" src="/assets/images/image-20211012222529178-7973f894a48a42b955eba9750a93abf9.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="dispatch_semaphore"></a>dispatch_semaphore<a class="hash-link" href="#dispatch_semaphore" title="Direct link to heading">#</a></h2><p>semaphore叫做”信号量”
信号量的初始值，可以用来控制线程并发访问的最大数量
信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</p><p><img alt="image-20211012222558323" src="/assets/images/image-20211012222558323-ae2cac1dc78a1038116303ee4563af4e.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="dispatch_queue"></a>dispatch_queue<a class="hash-link" href="#dispatch_queue" title="Direct link to heading">#</a></h2><p><img alt="image-20211012222617203" src="/assets/images/image-20211012222617203-56c747cfe66d62fe8206a339fef5da55.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="synchronized"></a>@synchronized<a class="hash-link" href="#synchronized" title="Direct link to heading">#</a></h2><p>@synchronized是对mutex递归锁的封装
源码查看：objc4中的objc-sync.mm文件
@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p><p><img alt="image-20211012222700373" src="/assets/images/image-20211012222700373-b2b8e5d7a7587506bdc46a94165a42b5.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="ios线程同步方案性能比较"></a>iOS线程同步方案性能比较<a class="hash-link" href="#ios线程同步方案性能比较" title="Direct link to heading">#</a></h2><p>性能从高到低排序
os_unfair_lock
OSSpinLock
dispatch_semaphore
pthread_mutex
dispatch_queue(DISPATCH_QUEUE_SERIAL)
NSLock
NSCondition
pthread_mutex(recursive)
NSRecursiveLock
NSConditionLock
@synchronized</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="自旋锁、互斥锁比较"></a>自旋锁、互斥锁比较<a class="hash-link" href="#自旋锁、互斥锁比较" title="Direct link to heading">#</a></h2><p>什么情况使用自旋锁比较划算？
预计线程等待锁的时间很短
加锁的代码（临界区）经常被调用，但竞争情况很少发生
CPU资源不紧张
多核处理器</p><p>什么情况使用互斥锁比较划算？
预计线程等待锁的时间较长
单核处理器
临界区有IO操作
临界区代码复杂或者循环量大
临界区竞争非常激烈</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="atomic"></a>atomic<a class="hash-link" href="#atomic" title="Direct link to heading">#</a></h2><p>atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁
可以参考源码objc4的objc-accessors.mm
它并不能保证使用属性的过程是线程安全的</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="ios中的读写安全方案"></a>iOS中的读写安全方案<a class="hash-link" href="#ios中的读写安全方案" title="Direct link to heading">#</a></h2><p>思考如何实现以下场景
同一时间，只能有1个线程进行写的操作
同一时间，允许有多个线程进行读的操作
同一时间，不允许既有写的操作，又有读的操作</p><p>上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作，iOS中的实现方案有
pthread_rwlock：读写锁
dispatch_barrier_async：异步栅栏调用</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="pthread_rwlock"></a>pthread_rwlock<a class="hash-link" href="#pthread_rwlock" title="Direct link to heading">#</a></h3><p><img alt="image-20211012222903167" src="/assets/images/image-20211012222903167-dfab229fd95c17fc23ce2c86078ffac7.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="dispatch_barrier_async"></a>dispatch_barrier_async<a class="hash-link" href="#dispatch_barrier_async" title="Direct link to heading">#</a></h2><p>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的
如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</p><p><img alt="image-20211012222946256" src="/assets/images/image-20211012222946256-c90dc4c9b4b21496184627034cafcd9c.png"></p><p><img alt="image-20211012222957778" src="/assets/images/image-20211012222957778-d3931cc0ed99faed07e04b043339b9ac.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="执行方式"></a>执行方式<a class="hash-link" href="#执行方式" title="Direct link to heading">#</a></h2><p>同步：sync</p><p>异步：async</p><p>dispatch_async();</p><p>立即返回。不阻塞线程。如果执行的是串行队列，则同时只有一个线程在执行，如果执行的是并发队列，则同时可有多个线程执行。</p><p>dispatch_sync();</p><p>立即执行。阻塞线程。他的队列任务执行完成才能继续往下走。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_sync(dispatch_get_main_queue(), ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;3&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.myqueue&quot;, DISPATCH_QUEUE_SERIAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;Start&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (NSInteger i = 0; i&lt;10; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dispatch_sync(queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            [NSThread sleepForTimeInterval:1];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            NSLog(@&quot;%tu&quot;,i);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;End&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;0&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_async(queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dispatch_sync(queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            NSLog(@&quot;2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;3&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;4&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      /*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      执行方式针对的都是队列,同步执行串行队列，同步执行并发队列，异步执行串行队列，异步执行，并发队列。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      执行方式：说的是是否阻塞当前线程，执行的对象是队列！。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      队列：先进先出管理，及是否支持并发。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.dys.demo&quot;, DISPATCH_QUEUE_SERIAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_async(queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;3&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_sync(queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;4&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;5&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>理解：立即执行，阻塞线程的意思。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="线程同步-1"></a>线程同步<a class="hash-link" href="#线程同步-1" title="Direct link to heading">#</a></h2><p>实际开发中有很多复杂业务，比如说在用户登录的时候需要同步多种信息，而这些信息从不同的接口获取，只有所有信息全部同步结束才可以正常操作，同步各种信息应该各自在子线程进行，我们可以异步执行并发队列中的任务来做这些耗时操作，但是我们怎么知道所有任务都执行完了呢？</p><p>GCD为我们提供了另一个东西，叫做Group（调度组）。调度组是用来协调一个或多个任务提交到队列异步触发的。 应用程序可以使用调度组等待所有调度组中的所有任务的完成。</p><p>所有异步队列执行完毕后得到一个通知。</p><p>group</p><ol><li><p>notify</p></li><li><p>enter，leave，wait</p></li></ol><p>任务：block</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="最大并发控制"></a>最大并发控制<a class="hash-link" href="#最大并发控制" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)test_0_13 {   </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;000&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_group_t group = dispatch_group_create();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (NSInteger i = 0; i &lt; 100; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dispatch_group_async(group, queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            sleep(2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            NSLog(@&quot;%tu :%@&quot;,i,[NSThread currentThread]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            dispatch_semaphore_signal(semaphore);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;101&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><a href="https://www.jianshu.com/p/9d5417ae07d2" target="_blank" rel="noopener noreferrer">iOS 多线程开发GCD如何控制最大并发数</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="延时处理"></a>延时处理<a class="hash-link" href="#延时处理" title="Direct link to heading">#</a></h2><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), self.queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;2秒后打印&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //其内部使用的是 dispatch_time_t 管理时间，而不是 NSTimer。在指定时间追加处理到 dispatch_queue</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_async(self.queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        [self performSelector:@selector(log6) withObject:nil afterDelay:2];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        [[NSRunLoop currentRunLoop] run];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//        在子线程中调用performSelector:afterDelay,要开启runloop，而使用dispatch_after 则无需关系runloop</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>注意在子线程中 dispatch_after 和  performSelector:afterDelay 的区别。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="常驻子线程"></a>常驻子线程<a class="hash-link" href="#常驻子线程" title="Direct link to heading">#</a></h2><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (NSThread *)shareThread {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    static dispatch_once_t onceToken;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    static NSThread *thread = nil;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_once(&amp;onceToken, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadStart) object:nil];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        [thread setName:@&quot;com.dys.demo&quot;];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        [thread start];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return thread;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)threadStart {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;threadStart&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //添加runloop后在再次调用即可执行threadTest,说明线程没有死亡</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSRunLoop *runloop = [NSRunLoop currentRunLoop];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [runloop addPort:[NSPort port] forMode:NSRunLoopCommonModes];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [runloop run];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)threadTest {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;threadTest&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)test_0_21 {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [self performSelector:@selector(threadTest) onThread:[self shareThread] withObject:nil waitUntilDone:NO];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="nsoperation"></a>NSOperation<a class="hash-link" href="#nsoperation" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="operate"></a>operate<a class="hash-link" href="#operate" title="Direct link to heading">#</a></h2><ul><li>NSBlockOperation</li><li>NSInvocationOperation</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="nsoperatequeue"></a>NSOperateQueue<a class="hash-link" href="#nsoperatequeue" title="Direct link to heading">#</a></h2><p>默认是并行队列，属性maxnum设置为1则可视为并行队列。</p><p>执行方式：默认异步执行</p><p>不知道你有没有注意到，<code>NSOperationQueue</code>本身并没有并发队列和串行队列的选项，它默认是并发队列，但是，它有一个<code>maxConcurrentOperationCount</code>属性（代表了最大并发数，也就是最多能够开几条线程执行操作），如果最大并发数量为1，它就变成了类似串行队列的模样。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="线程同步-2"></a>线程同步<a class="hash-link" href="#线程同步-2" title="Direct link to heading">#</a></h2><p>addDependency</p><p>任务：NSOperate子类（block，selector）</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="cocoatouch实践"></a>CocoaTouch实践<a class="hash-link" href="#cocoatouch实践" title="Direct link to heading">#</a></h1><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)removeSubLayerOf:(UIView *)view {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (CALayer *layer in view.layer.sublayers) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dispatch_async(dispatch_get_main_queue(), ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            [layer removeFromSuperlayer];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><a href="https://stackoverflow.com/questions/14854480/collection-calayerarray-0x1ed8faa0-was-mutated-while-being-enumerated" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/14854480/collection-calayerarray-0x1ed8faa0-was-mutated-while-being-enumerated</a></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)yyi_removeEvent{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!(self.model.startDate &amp;&amp; self.model.endDate &amp;&amp; self.model.title)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        [self yyi_dealWithResult:NO error:@&quot;参数异常&quot;];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSPredicate *predicate = [self.model.calendarEventStore predicateForEventsWithStartDate:self.model.startDate endDate:self.model.endDate calendars:nil];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    __block BOOL isHasIEtem = NO;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    [self.model.calendarEventStore enumerateEventsMatchingPredicate:predicate usingBlock:^(EKEvent * _Nonnull event, BOOL * _Nonnull stop) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if ([event.title isEqualToString:self.model.title]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            isHasIEtem = YES;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            NSError *error;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            BOOL success = [self.model.calendarEventStore removeEvent:event span:EKSpanThisEvent commit:YES error:&amp;error];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            [self yyi_dealWithResult:success error:error.localizedDescription];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!isHasIEtem) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        [self yyi_dealWithResult:NO error:@&quot;无此项&quot;];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>迭代器（枚举器中对界面的操作要切换到主线程！）否则就是在子线程操作UI，会造成Crash。</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="进程同步"></a>进程同步<a class="hash-link" href="#进程同步" title="Direct link to heading">#</a></h1><p>卖票问题</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="临界资源与临界区"></a>临界资源与临界区<a class="hash-link" href="#临界资源与临界区" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="信号量"></a>信号量<a class="hash-link" href="#信号量" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="死锁"></a>死锁<a class="hash-link" href="#死锁" title="Direct link to heading">#</a></h2><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-objective-c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)test_0_4 {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_sync(dispatch_get_main_queue(), ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    NSLog(@&quot;3&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    /*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     同步添加任务到主队列会发生死锁。主队列是串行队列。同步执行。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">- (void)test_0_6 {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    /*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     Thread 3: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    dispatch_async(queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;1&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dispatch_sync(queue, ^{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            NSLog(@&quot;2&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        NSLog(@&quot;3&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>串行队列和同步操作组合会造成死锁。</p><p>串行队列：执行完当前的任务才能执行下一个任务。</p><p>同步操作：执行完这个同步任务，才能继续往下走。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="进程间通信"></a>进程间通信<a class="hash-link" href="#进程间通信" title="Direct link to heading">#</a></h2><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="线程安全"></a>线程安全<a class="hash-link" href="#线程安全" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="同步锁"></a>同步锁<a class="hash-link" href="#同步锁" title="Direct link to heading">#</a></h2><p>Lock 锁：<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener noreferrer">不再安全的 OSSpinLock</a></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="参考文档"></a>参考文档<a class="hash-link" href="#参考文档" title="Direct link to heading">#</a></h1><ul><li><p><a href="https://www.jianshu.com/p/9e9316b52575" target="_blank" rel="noopener noreferrer">OC-多线程的理解和使用</a></p></li><li><p><a href="https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Multithreading.html" target="_blank" rel="noopener noreferrer">https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Multithreading.html</a></p></li></ul><hr><p>原创文章，转载请保留原文链接，未经授权拒绝转载，谢谢。</p><p>联系作者：<a href="mailto:dys90@qq.com" target="_blank" rel="noopener noreferrer">dys90@qq.com</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="dys-typora-open://mine/survival/docs/Apple/并发编程/多线程.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#ios中的常见多线程方案" class="table-of-contents__link">iOS中的常见多线程方案</a></li><li><a href="#创建线程" class="table-of-contents__link">创建线程</a></li><li><a href="#切换线程" class="table-of-contents__link">切换线程</a></li><li><a href="#线程同步" class="table-of-contents__link">线程同步</a><ul><li><a href="#synchronized-object-" class="table-of-contents__link"><code>@synchronized (object) {}</code></a></li><li><a href="#nslock" class="table-of-contents__link">NSLock</a></li></ul></li><li><a href="#nsthread延时" class="table-of-contents__link">NSThread延时</a></li><li><a href="#常用方法" class="table-of-contents__link">常用方法</a></li><li><a href="#总结：" class="table-of-contents__link">总结：</a></li><li><a href="#队列类型" class="table-of-contents__link">队列类型</a><ul><li><a href="#容易混淆的术语" class="table-of-contents__link">容易混淆的术语</a></li><li><a href="#各种队列的执行效果" class="table-of-contents__link">各种队列的执行效果</a></li></ul></li><li><a href="#队列组的使用" class="table-of-contents__link">队列组的使用</a></li><li><a href="#多线程的安全隐患" class="table-of-contents__link">多线程的安全隐患</a><ul><li><a href="#多线程安全隐患示例01--存钱取钱" class="table-of-contents__link">多线程安全隐患示例01 – 存钱取钱</a></li></ul></li><li><a href="#多线程安全隐患分析" class="table-of-contents__link">多线程安全隐患分析</a><ul><li><a href="#多线程安全隐患的解决方案" class="table-of-contents__link">多线程安全隐患的解决方案</a></li></ul></li><li><a href="#ios中的线程同步方案" class="table-of-contents__link">iOS中的线程同步方案</a></li><li><a href="#gnustep" class="table-of-contents__link">GNUstep</a></li><li><a href="#osspinlock" class="table-of-contents__link">OSSpinLock</a></li><li><a href="#os_unfair_lock" class="table-of-contents__link">os_unfair_lock</a></li><li><a href="#pthread_mutex" class="table-of-contents__link">pthread_mutex</a></li><li><a href="#pthread_mutex--递归锁" class="table-of-contents__link">pthread_mutex – 递归锁</a><ul><li><a href="#pthread_mutex--条件" class="table-of-contents__link">pthread_mutex – 条件</a></li></ul></li><li><a href="#nslock、nsrecursivelock" class="table-of-contents__link">NSLock、NSRecursiveLock</a></li><li><a href="#nscondition" class="table-of-contents__link">NSCondition</a></li><li><a href="#nsconditionlock" class="table-of-contents__link">NSConditionLock</a></li><li><a href="#dispatch_semaphore" class="table-of-contents__link">dispatch_semaphore</a></li><li><a href="#dispatch_queue" class="table-of-contents__link">dispatch_queue</a></li><li><a href="#synchronized" class="table-of-contents__link">@synchronized</a></li><li><a href="#ios线程同步方案性能比较" class="table-of-contents__link">iOS线程同步方案性能比较</a></li><li><a href="#自旋锁、互斥锁比较" class="table-of-contents__link">自旋锁、互斥锁比较</a></li><li><a href="#atomic" class="table-of-contents__link">atomic</a></li><li><a href="#ios中的读写安全方案" class="table-of-contents__link">iOS中的读写安全方案</a><ul><li><a href="#pthread_rwlock" class="table-of-contents__link">pthread_rwlock</a></li></ul></li><li><a href="#dispatch_barrier_async" class="table-of-contents__link">dispatch_barrier_async</a></li><li><a href="#执行方式" class="table-of-contents__link">执行方式</a></li><li><a href="#线程同步-1" class="table-of-contents__link">线程同步</a><ul><li><a href="#最大并发控制" class="table-of-contents__link">最大并发控制</a></li></ul></li><li><a href="#延时处理" class="table-of-contents__link">延时处理</a></li><li><a href="#常驻子线程" class="table-of-contents__link">常驻子线程</a></li><li><a href="#operate" class="table-of-contents__link">operate</a></li><li><a href="#nsoperatequeue" class="table-of-contents__link">NSOperateQueue</a></li><li><a href="#线程同步-2" class="table-of-contents__link">线程同步</a></li><li><a href="#临界资源与临界区" class="table-of-contents__link">临界资源与临界区</a></li><li><a href="#信号量" class="table-of-contents__link">信号量</a></li><li><a href="#死锁" class="table-of-contents__link">死锁</a></li><li><a href="#进程间通信" class="table-of-contents__link">进程间通信</a></li><li><a href="#同步锁" class="table-of-contents__link">同步锁</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.4ec932fe.js"></script>
<script src="/runtime~main.3425bbd6.js"></script>
<script src="/main.4d172be4.js"></script>
<script src="/1.978a979f.js"></script>
<script src="/284.9b127a42.js"></script>
<script src="/285.87bc8610.js"></script>
<script src="/935f2afb.0ad17a86.js"></script>
<script src="/283.46b48473.js"></script>
<script src="/53c63f6e.552b2725.js"></script>
</body>
</html>